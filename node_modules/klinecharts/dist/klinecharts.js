/**
 * @license
 * KLineChart v9.0.0-alpha7
 * Copyright (c) 2019 lihu.
 * Licensed under Apache License 2.0 https://www.apache.org/licenses/LICENSE-2.0
 */
(function (global, factory) {
typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
typeof define === 'function' && define.amd ? define(['exports'], factory) :
(global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.klinecharts = {}));
})(this, (function (exports) { 'use strict';

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ID {
    constructor() {
        this._baseId = 1;
    }
    next(prefix) {
        const timestamp = new Date().getTime();
        if (timestamp === this._prevIdTimestamp) {
            ++this._baseId;
        }
        else {
            this._baseId = 1;
        }
        this._prevIdTimestamp = timestamp;
        return `${prefix !== null && prefix !== void 0 ? prefix : ''}${timestamp}_${this._baseId}`;
    }
}
const id = new ID();
function createId(prefix) {
    return id.next(prefix);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Create dom
 * @param tagName
 * @param styles
 * @return {*}
 */
function createDom(tagName, styles) {
    var _a;
    const dom = document.createElement(tagName);
    const s = styles !== null && styles !== void 0 ? styles : {};
    for (const key in s) {
        (dom.style)[key] = (_a = s[key]) !== null && _a !== void 0 ? _a : '';
    }
    return dom;
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let measureCtx;
/**
 * Get pixel ratio
 * @param canvas
 * @returns {number}
 */
function getPixelRatio(canvas) {
    var _a, _b, _c;
    return (_c = (_b = (_a = canvas.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.devicePixelRatio) !== null && _c !== void 0 ? _c : 2;
}
function createFont(size, weight, family) {
    return `${weight !== null && weight !== void 0 ? weight : 'normal'} ${size !== null && size !== void 0 ? size : 12}px ${family !== null && family !== void 0 ? family : 'Helvetica Neue'}`;
}
/**
 * Measure the width of text
 * @param text
 * @returns {number}
 */
function calcTextWidth(text, size, weight, family) {
    if (measureCtx === undefined) {
        const canvas = document.createElement('canvas');
        const pixelRatio = getPixelRatio(canvas);
        measureCtx = canvas.getContext('2d');
        measureCtx.scale(pixelRatio, pixelRatio);
    }
    measureCtx.font = createFont(size, weight, family);
    return Math.round(measureCtx.measureText(text).width);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function merge(target, source) {
    if ((!isObject(target) && !isObject(source))) {
        return;
    }
    for (const key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
            const targetProp = target[key];
            const sourceProp = source[key];
            if (isObject(sourceProp) &&
                isObject(targetProp) &&
                !isArray(sourceProp) &&
                !isArray(targetProp)) {
                merge(targetProp, sourceProp);
            }
            else {
                if (isValid(source[key])) {
                    target[key] = source[key];
                }
            }
        }
    }
}
function clone(target) {
    if (!isObject(target) || !isArray(target)) {
        return target;
    }
    let copy;
    if (isArray(target)) {
        copy = [];
    }
    else {
        copy = {};
    }
    for (const key in target) {
        if (Object.prototype.hasOwnProperty.call(target, key)) {
            const v = target[key];
            if (isObject(v)) {
                copy[key] = clone(v);
            }
            else {
                copy[key] = v;
            }
        }
    }
    return copy;
}
function isArray(value) {
    return Object.prototype.toString.call(value) === '[object Array]';
}
function isFunction(value) {
    return typeof value === 'function';
}
function isObject(value) {
    return (typeof value === 'object');
}
function isNumber(value) {
    return typeof value === 'number' && !isNaN(value);
}
function isValid(value) {
    return value !== null && value !== undefined;
}
function isBoolean(value) {
    return typeof value === 'boolean';
}
function isString(value) {
    return typeof value === 'string';
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function log(message, style, api, invalidParam, append) {
    {
        const apiStr = api !== '' ? `Call api ${api}${invalidParam !== '' || append !== '' ? ', ' : '.'},` : '';
        const invalidParamStr = invalidParam !== '' ? `invalid parameter ${invalidParam}${append !== '' ? ', ' : '.'}` : '';
        const appendStr = append !== '' ? append : '';
        console.log(message, style, apiStr, invalidParamStr, appendStr);
    }
}
function logWarn(api, invalidParam, append) {
    log('%c😑 klinecharts warning: \n%s%s%s', 'color:#fcaf17;font-weight:bold', api, invalidParam, append !== null && append !== void 0 ? append : '');
}
function logError(api, invalidParam, append) {
    log('%c😟 klinecharts error: \n%s%s%s', 'color:#ed1941;font-weight:bold', api, invalidParam, append !== null && append !== void 0 ? append : '');
}
function logTag() {
    log('%c❤️ Welcome to klinecharts. Version is 9.0.0-alpha7', 'border-radius:2px;border:dashed 1px #2196F3;padding:26px 20px;font-size:14px;color:#2196F3', '', '', '');
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const reEscapeChar = /\\(\\)?/g;
const rePropName = RegExp('[^.[\\]]+' + '|' +
    '\\[(?:' +
    '([^"\'][^[]*)' + '|' +
    '(["\'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2' +
    ')\\]' + '|' +
    '(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))', 'g');
function formatValue(data, key, defaultValue) {
    if (isValid(data)) {
        const path = [];
        key.replace(rePropName, (subString, ...args) => {
            let k = subString;
            if (isValid(args[1])) {
                k = args[2].replace(reEscapeChar, '$1');
            }
            else if (isValid(args[0])) {
                k = args[0].trim();
            }
            path.push(k);
            return '';
        });
        let value = data;
        let index = 0;
        const length = path.length;
        while (isValid(value) && index < length) {
            value = value === null || value === void 0 ? void 0 : value[path[index++]];
        }
        return isValid(value) ? value : (defaultValue !== null && defaultValue !== void 0 ? defaultValue : '--');
    }
    return defaultValue !== null && defaultValue !== void 0 ? defaultValue : '--';
}
function formatDate(dateTimeFormat, timestamp, format) {
    const dateTimeString = dateTimeFormat.format(new Date(timestamp));
    const dateTimeStringArray = dateTimeString.split(', ');
    const dateStringArray = dateTimeStringArray[0].split('/');
    const timeStringArray = dateTimeStringArray[1].split(':');
    const date = {
        YYYY: dateStringArray[2],
        MM: dateStringArray[0],
        DD: dateStringArray[1],
        HH: timeStringArray[0] === '24' ? '00' : timeStringArray[0],
        mm: timeStringArray[1],
        ss: timeStringArray[2]
    };
    return format.replace(/YYYY|MM|DD|HH|mm|ss/g, key => date[key]);
}
function formatPrecision(value, precision) {
    const v = +value;
    if (isNumber(v)) {
        return v.toFixed(precision !== null && precision !== void 0 ? precision : 2);
    }
    return `${v}`;
}
function formatBigNumber(value) {
    const v = +value;
    if (isNumber(v)) {
        if (value > 1000000000) {
            return `${+((v / 1000000000).toFixed(3))}B`;
        }
        if (value > 1000000) {
            return `${+((v / 1000000).toFixed(3))}M`;
        }
        if (value > 1000) {
            return `${+((v / 1000).toFixed(3))}K`;
        }
        return `${value}`;
    }
    return '--';
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Binary search for the nearest result
 * @param dataList
 * @param valueKey
 * @param targetValue
 * @return {number}
 */
function binarySearchNearest(dataList, valueKey, targetValue) {
    let left = 0;
    let right = 0;
    for (right = dataList.length - 1; left !== right;) {
        const midIndex = Math.floor((right + left) / 2);
        const mid = right - left;
        const midValue = dataList[midIndex][valueKey];
        if (targetValue === dataList[left][valueKey]) {
            return left;
        }
        if (targetValue === dataList[right][valueKey]) {
            return right;
        }
        if (targetValue === midValue) {
            return midIndex;
        }
        if (targetValue > midValue) {
            left = midIndex;
        }
        else {
            right = midIndex;
        }
        if (mid <= 2) {
            break;
        }
    }
    return left;
}
/**
 * 优化数字
 * @param value
 * @return {number|number}
 */
function nice(value) {
    const exponent = Math.floor(log10(value));
    const exp10 = index10(exponent);
    const f = value / exp10; // 1 <= f < 10
    let nf = 0;
    if (f < 1.5) {
        nf = 1;
    }
    else if (f < 2.5) {
        nf = 2;
    }
    else if (f < 3.5) {
        nf = 3;
    }
    else if (f < 4.5) {
        nf = 4;
    }
    else if (f < 5.5) {
        nf = 5;
    }
    else if (f < 6.5) {
        nf = 6;
    }
    else {
        nf = 8;
    }
    value = nf * exp10;
    return exponent >= -20 ? +value.toFixed(exponent < 0 ? -exponent : 0) : value;
}
/**
 * 四舍五入
 * @param value
 * @param precision
 * @return {number}
 */
function round(value, precision) {
    if (precision == null) {
        precision = 10;
    }
    precision = Math.min(Math.max(0, precision), 20);
    const v = (+value).toFixed(precision);
    return +v;
}
/**
 * 获取小数位数
 * @param value
 * @return {number|number}
 */
function getPrecision(value) {
    const str = value.toString();
    const eIndex = str.indexOf('e');
    if (eIndex > 0) {
        const precision = +str.slice(eIndex + 1);
        return precision < 0 ? -precision : 0;
    }
    else {
        const dotIndex = str.indexOf('.');
        return dotIndex < 0 ? 0 : str.length - 1 - dotIndex;
    }
}
function getMaxMin(dataList, maxKey, minKey) {
    const maxMin = [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER];
    dataList.forEach(data => {
        var _a, _b;
        maxMin[0] = Math.max((_a = data[maxKey]) !== null && _a !== void 0 ? _a : data, maxMin[0]);
        maxMin[1] = Math.min((_b = data[minKey]) !== null && _b !== void 0 ? _b : data, maxMin[1]);
    });
    return maxMin;
}
/**
 * 10为底的对数函数
 * @param value
 * @return {number}
 */
function log10(value) {
    return Math.log(value) / Math.log(10);
}
/**
 * 10的指数函数
 * @param value
 * @return {number}
 */
function index10(value) {
    return Math.pow(10, value);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getDefaultGridStyle() {
    return {
        show: true,
        horizontal: {
            show: true,
            size: 1,
            color: '#EDEDED',
            style: "dashed" /* LineType.DASHED */,
            dashedValue: [2, 2]
        },
        vertical: {
            show: true,
            size: 1,
            color: '#EDEDED',
            style: "dashed" /* LineType.DASHED */,
            dashedValue: [2, 2]
        }
    };
}
/**
 * Get default candle style
 * @type {{area: {backgroundColor: [{offset: number, color: string}, {offset: number, color: string}], lineColor: string, lineSize: number, value: string}, bar: {noChangeColor: string, upColor: string, downColor: string}, tooltip: {rect: {offsetTop: number, fillColor: string, borderColor: string, paddingBottom: number, borderRadius: number, paddingRight: number, borderSize: number, offsetLeft: number, paddingTop: number, paddingLeft: number, offsetRight: number}, showRule: string, values: null, showType: string, text: {marginRight: number, size: number, color: string, weight: string, marginBottom: number, family: string, marginTop: number, marginLeft: number}, labels: string[]}, type: string, priceMark: {high: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, last: {noChangeColor: string, upColor: string, line: {dashValue: number[], size: number, show: boolean, style: string}, show: boolean, text: {paddingBottom: number, size: number, color: string, paddingRight: number, show: boolean, weight: string, paddingTop: number, family: string, paddingLeft: number}, downColor: string}, low: {textMargin: number, textSize: number, color: string, textFamily: string, show: boolean, textWeight: string}, show: boolean}}}
 */
function getDefaultCandleStyle() {
    return {
        type: "candle_solid" /* CandleType.CANDLE_SOLID */,
        bar: {
            upColor: '#26A69A',
            downColor: '#EF5350',
            noChangeColor: '#999999'
        },
        area: {
            lineSize: 2,
            lineColor: '#1677FF',
            value: 'close',
            backgroundColor: [{
                    offset: 0,
                    color: 'rgba(22, 119, 255, 0.01)'
                }, {
                    offset: 1,
                    color: 'rgba(22, 119, 255, 0.2)'
                }]
        },
        priceMark: {
            show: true,
            high: {
                show: true,
                color: '#76808F',
                textOffset: 5,
                textSize: 10,
                textFamily: 'Helvetica Neue',
                textWeight: 'normal'
            },
            low: {
                show: true,
                color: '#76808F',
                textOffset: 5,
                textSize: 10,
                textFamily: 'Helvetica Neue',
                textWeight: 'normal'
            },
            last: {
                show: true,
                upColor: '#26A69A',
                downColor: '#EF5350',
                noChangeColor: '#888888',
                line: {
                    show: true,
                    style: "dashed" /* LineType.DASHED */,
                    dashedValue: [4, 4],
                    size: 1
                },
                text: {
                    show: true,
                    style: "fill" /* PolygonType.FILL */,
                    size: 12,
                    paddingLeft: 4,
                    paddingTop: 4,
                    paddingRight: 4,
                    paddingBottom: 4,
                    borderStyle: "solid" /* LineType.SOLID */,
                    borderSize: 1,
                    borderDashedValue: [2, 2],
                    color: '#FFFFFF',
                    family: 'Helvetica Neue',
                    weight: 'normal',
                    borderRadius: 2
                }
            }
        },
        tooltip: {
            showRule: "always" /* TooltipShowRule.ALWAYS */,
            showType: "standard" /* TooltipShowType.STANDARD */,
            custom: null,
            defaultValue: 'n/a',
            rect: {
                paddingLeft: 0,
                paddingRight: 0,
                paddingTop: 0,
                paddingBottom: 6,
                offsetLeft: 8,
                offsetTop: 8,
                offsetRight: 8,
                borderRadius: 4,
                borderSize: 1,
                borderColor: '#F2F3F5',
                color: '#FEFEFE'
            },
            text: {
                size: 12,
                family: 'Helvetica Neue',
                weight: 'normal',
                color: '#76808F',
                marginLeft: 8,
                marginTop: 6,
                marginRight: 8,
                marginBottom: 0
            }
        }
    };
}
/**
 * Get default indicator style
 */
function getDefaultIndicatorStyle() {
    return {
        ohlc: {
            upColor: 'rgba(38, 166, 154, .65)',
            downColor: 'rgba(239, 83, 80, .65)',
            noChangeColor: '#888888'
        },
        bars: [{
                style: "fill" /* PolygonType.FILL */,
                borderStyle: "solid" /* LineType.SOLID */,
                borderSize: 1,
                borderDashedValue: [2, 2],
                upColor: 'rgba(38, 166, 154, .65)',
                downColor: 'rgba(239, 83, 80, .65)',
                noChangeColor: '#888888'
            }],
        lines: [
            {
                style: "solid" /* LineType.SOLID */,
                smooth: false,
                size: 1,
                dashedValue: [2, 2],
                color: '#FF9600'
            }, {
                style: "solid" /* LineType.SOLID */,
                smooth: false,
                size: 1,
                dashedValue: [2, 2],
                color: '#9D65C9'
            }, {
                style: "solid" /* LineType.SOLID */,
                smooth: false,
                size: 1,
                dashedValue: [2, 2],
                color: '#1677FF'
            }, {
                style: "solid" /* LineType.SOLID */,
                smooth: false,
                size: 1,
                dashedValue: [2, 2],
                color: '#E11D74'
            }, {
                style: "solid" /* LineType.SOLID */,
                smooth: false,
                size: 1,
                dashedValue: [2, 2],
                color: '#01C5C4'
            }
        ],
        circles: [{
                style: "fill" /* PolygonType.FILL */,
                borderStyle: "solid" /* LineType.SOLID */,
                borderSize: 1,
                borderDashedValue: [2, 2],
                upColor: 'rgba(38, 166, 154, .65)',
                downColor: 'rgba(239, 83, 80, .65)',
                noChangeColor: '#888888'
            }],
        lastValueMark: {
            show: false,
            text: {
                show: false,
                style: "fill" /* PolygonType.FILL */,
                color: '#FFFFFF',
                size: 12,
                family: 'Helvetica Neue',
                weight: 'normal',
                borderStyle: "solid" /* LineType.SOLID */,
                borderSize: 1,
                borderDashedValue: [2, 2],
                paddingLeft: 4,
                paddingTop: 4,
                paddingRight: 4,
                paddingBottom: 4,
                borderRadius: 2
            }
        },
        tooltip: {
            showRule: "always" /* TooltipShowRule.ALWAYS */,
            showType: "standard" /* TooltipShowType.STANDARD */,
            showName: true,
            showParams: true,
            defaultValue: 'n/a',
            text: {
                size: 12,
                family: 'Helvetica Neue',
                weight: 'normal',
                color: '#76808F',
                marginTop: 6,
                marginRight: 8,
                marginBottom: 0,
                marginLeft: 8
            }
        }
    };
}
function getDefaultXAxisStyle() {
    return {
        show: true,
        size: 'auto',
        axisLine: {
            show: true,
            color: '#DDDDDD',
            size: 1
        },
        tickText: {
            show: true,
            color: '#76808F',
            size: 12,
            family: 'Helvetica Neue',
            weight: 'normal',
            marginStart: 4,
            marginEnd: 4
        },
        tickLine: {
            show: true,
            size: 1,
            length: 3,
            color: '#DDDDDD'
        }
    };
}
function getDefaultYAxisStyle() {
    return {
        show: true,
        size: 'auto',
        type: "normal" /* YAxisType.NORMAL */,
        position: "right" /* YAxisPosition.RIGHT */,
        inside: false,
        reverse: false,
        axisLine: {
            show: true,
            color: '#DDDDDD',
            size: 1
        },
        tickText: {
            show: true,
            color: '#76808F',
            size: 12,
            family: 'Helvetica Neue',
            weight: 'normal',
            marginStart: 4,
            marginEnd: 4
        },
        tickLine: {
            show: true,
            size: 1,
            length: 3,
            color: '#DDDDDD'
        }
    };
}
function getDefaultCrosshairStyle() {
    return {
        show: true,
        horizontal: {
            show: true,
            line: {
                show: true,
                style: "dashed" /* LineType.DASHED */,
                dashedValue: [4, 2],
                size: 1,
                color: '#76808F'
            },
            text: {
                show: true,
                style: "fill" /* PolygonType.FILL */,
                color: '#FFFFFF',
                size: 12,
                family: 'Helvetica Neue',
                weight: 'normal',
                borderStyle: "solid" /* LineType.SOLID */,
                borderDashedValue: [2, 2],
                borderSize: 1,
                borderColor: '#686D76',
                borderRadius: 2,
                paddingLeft: 4,
                paddingRight: 4,
                paddingTop: 4,
                paddingBottom: 4,
                backgroundColor: '#686D76'
            }
        },
        vertical: {
            show: true,
            line: {
                show: true,
                style: "dashed" /* LineType.DASHED */,
                dashedValue: [4, 2],
                size: 1,
                color: '#76808F'
            },
            text: {
                show: true,
                style: "fill" /* PolygonType.FILL */,
                color: '#FFFFFF',
                size: 12,
                family: 'Helvetica Neue',
                weight: 'normal',
                borderStyle: "solid" /* LineType.SOLID */,
                borderDashedValue: [2, 2],
                borderSize: 1,
                borderRadius: 2,
                borderColor: '#686D76',
                paddingLeft: 4,
                paddingRight: 4,
                paddingTop: 4,
                paddingBottom: 4,
                backgroundColor: '#686D76'
            }
        }
    };
}
function getDefaultOverlayStyle() {
    return {
        point: {
            color: '#1677FF',
            borderColor: 'rgba(22, 119, 255, 0.35)',
            borderSize: 1,
            radius: 5,
            activeColor: '#1677FF',
            activeBorderColor: 'rgba(22, 119, 255, 0.35)',
            activeBorderSize: 3,
            activeRadius: 5
        },
        line: {
            style: "solid" /* LineType.SOLID */,
            smooth: false,
            color: '#1677FF',
            size: 1,
            dashedValue: [2, 2]
        },
        rect: {
            style: "fill" /* PolygonType.FILL */,
            color: 'rgba(22, 119, 255, 0.25)',
            borderColor: '#1677FF',
            borderSize: 1,
            borderRadius: 0,
            borderStyle: "solid" /* LineType.SOLID */,
            borderDashedValue: [2, 2]
        },
        polygon: {
            style: "fill" /* PolygonType.FILL */,
            color: '#1677FF',
            borderColor: '#1677FF',
            borderSize: 1,
            borderStyle: "solid" /* LineType.SOLID */,
            borderDashedValue: [2, 2]
        },
        circle: {
            style: "fill" /* PolygonType.FILL */,
            color: 'rgba(22, 119, 255, 0.25)',
            borderColor: '#1677FF',
            borderSize: 1,
            borderStyle: "solid" /* LineType.SOLID */,
            borderDashedValue: [2, 2]
        },
        arc: {
            style: "solid" /* LineType.SOLID */,
            color: '#1677FF',
            size: 1,
            dashedValue: [2, 2]
        },
        text: {
            color: '#1677FF',
            size: 12,
            family: 'Helvetica Neue',
            weight: 'normal'
        },
        rectText: {
            style: "fill" /* PolygonType.FILL */,
            color: '#FFFFFF',
            size: 12,
            family: 'Helvetica Neue',
            weight: 'normal',
            borderStyle: "solid" /* LineType.SOLID */,
            borderDashedValue: [2, 2],
            borderSize: 1,
            borderRadius: 2,
            borderColor: '#1677FF',
            paddingLeft: 4,
            paddingRight: 4,
            paddingTop: 4,
            paddingBottom: 4,
            backgroundColor: '#1677FF'
        }
    };
}
function getDefaultSeparatorStyle() {
    return {
        size: 1,
        color: '#DDDDDD',
        fill: true,
        activeBackgroundColor: 'rgba(33, 150, 243, 0.08)'
    };
}
function getDefaultStyles() {
    return {
        grid: getDefaultGridStyle(),
        candle: getDefaultCandleStyle(),
        indicator: getDefaultIndicatorStyle(),
        xAxis: getDefaultXAxisStyle(),
        yAxis: getDefaultYAxisStyle(),
        separator: getDefaultSeparatorStyle(),
        crosshair: getDefaultCrosshairStyle(),
        overlay: getDefaultOverlayStyle()
    };
}
function getDefaultCustomApi() {
    return {
        formatDate,
        formatBigNumber
    };
}
const defaultLocale = 'en-US';

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BarSpaceLimitContants = {
    MIN: 1,
    MAX: 50
};
const DEFAULT_BAR_SPACE = 6;
const DEFAULT_OFFSET_RIGHT_DISTANCE = 50;
class TimeScaleStore {
    constructor(chartStore) {
        /**
         * Time foramt
         */
        this._dateTimeFormat = this._buildDateTimeFormat();
        /**
         * Scale enabled flag
         */
        this._zoomEnabled = true;
        /**
         * Scroll enabled flag
         */
        this._scrollEnabled = true;
        /**
         * Is loding data flag
         */
        this._loading = true;
        /**
         * Load more data callback
         */
        this._loadMoreCallback = null;
        /**
         * Whether there are more flag
         */
        this._more = true;
        /**
         * Total space of drawing area
         */
        this._totalBarSpace = 0;
        /**
         * Space occupied by a single piece of data
         */
        this._barSpace = DEFAULT_BAR_SPACE;
        /**
         * Distance from the last data to the right of the drawing area
         */
        this._offsetRightDistance = DEFAULT_OFFSET_RIGHT_DISTANCE;
        /**
         * The number of bar to the right of the drawing area from the last data when scrolling starts
         */
        this._startScrollOffsetRightBarCount = 0;
        /**
         * Scroll to the leftmost and rightmost visible bar
         */
        this._minVisibleBarCount = { left: 2, right: 2 };
        /**
         * Start and end points of visible area data index
         */
        this._visibleRange = { from: 0, to: 0 };
        this._chartStore = chartStore;
        this._gapBarSpace = this._calcGapBarSpace();
        this._offsetRightBarCount = this._offsetRightDistance / this._barSpace;
    }
    _calcGapBarSpace() {
        const rateSpace = Math.floor(this._barSpace * 0.82);
        const floorSpace = Math.floor(this._barSpace);
        const optimalSpace = Math.min(rateSpace, floorSpace - 1);
        return Math.max(1, optimalSpace);
    }
    /**
     * adjust visible range
     */
    adjustVisibleRange() {
        var _a;
        const dataList = this._chartStore.getDataList();
        const dataCount = dataList.length;
        const barCount = this._totalBarSpace / this._barSpace;
        const maxRightOffsetBarCount = barCount - Math.min(this._minVisibleBarCount.left, dataCount);
        if (this._offsetRightBarCount > maxRightOffsetBarCount) {
            this._offsetRightBarCount = maxRightOffsetBarCount;
        }
        const minRightOffsetBarCount = -dataCount + Math.min(this._minVisibleBarCount.right, dataCount);
        if (this._offsetRightBarCount < minRightOffsetBarCount) {
            this._offsetRightBarCount = minRightOffsetBarCount;
        }
        let to = Math.round(this._offsetRightBarCount + dataCount + 0.5);
        if (to > dataCount) {
            to = dataCount;
        }
        let from = Math.round(to - barCount) - 1;
        if (from < 0) {
            from = 0;
        }
        this._visibleRange = { from, to };
        this._chartStore.getActionStore().execute("onVisibleDataChange" /* ActionType.onVisibleRangeChange */, { from, to });
        this._chartStore.adjustVisibleDataList();
        // More processing and loading, more loading if there are callback methods and no data is being loaded
        if (from === 0 && this._more && !this._loading && this._loadMoreCallback !== null) {
            this._loading = true;
            const firstData = dataList[0];
            this._loadMoreCallback((_a = firstData === null || firstData === void 0 ? void 0 : firstData.timestamp) !== null && _a !== void 0 ? _a : null);
        }
    }
    setMore(more) {
        this._more = more;
        return this;
    }
    setLoading(loading) {
        this._loading = loading;
        return this;
    }
    getDateTimeFormat() {
        return this._dateTimeFormat;
    }
    _buildDateTimeFormat(timezone) {
        const options = {
            hour12: false,
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit'
        };
        if (timezone !== undefined) {
            options.timeZone = timezone;
        }
        let dateTimeFormat = null;
        try {
            dateTimeFormat = new Intl.DateTimeFormat('en', options);
        }
        catch (e) {
            logWarn('', '', 'Timezone is error!!!');
        }
        return dateTimeFormat;
    }
    setTimezone(timezone) {
        const dateTimeFormat = this._buildDateTimeFormat(timezone);
        if (dateTimeFormat !== null) {
            this._dateTimeFormat = dateTimeFormat;
        }
    }
    getTimezone() {
        return this._dateTimeFormat.resolvedOptions().timeZone;
    }
    getBarSpace() {
        return {
            bar: this._barSpace,
            halfBar: this._barSpace / 2,
            gapBar: this._gapBarSpace,
            halfGapBar: this._gapBarSpace / 2
        };
    }
    setBarSpace(barSpace, adjustBeforeFunc) {
        if (barSpace < BarSpaceLimitContants.MIN || barSpace > BarSpaceLimitContants.MAX || this._barSpace === barSpace) {
            return;
        }
        this._barSpace = barSpace;
        this._gapBarSpace = this._calcGapBarSpace();
        adjustBeforeFunc === null || adjustBeforeFunc === void 0 ? void 0 : adjustBeforeFunc();
        this.adjustVisibleRange();
        this._chartStore.getCrosshairStore().recalculate(true);
        this._chartStore.getChart().adjustPaneViewport(false, true, true, true);
    }
    setTotalBarSpace(totalSpace) {
        if (this._totalBarSpace !== totalSpace) {
            this._totalBarSpace = totalSpace;
            this.adjustVisibleRange();
            this._chartStore.getCrosshairStore().recalculate(true);
        }
        return this;
    }
    setOffsetRightDistance(distance, isUpdate) {
        this._offsetRightDistance = distance;
        this._offsetRightBarCount = distance / this._barSpace;
        if (isUpdate !== null && isUpdate !== void 0 ? isUpdate : false) {
            this.adjustVisibleRange();
            this._chartStore.getCrosshairStore().recalculate(true);
            this._chartStore.getChart().adjustPaneViewport(false, true, true, true);
        }
        return this;
    }
    resetOffsetRightDistance() {
        this.setOffsetRightDistance(this._offsetRightDistance);
    }
    getOffsetRightDistance() {
        return this._offsetRightDistance;
    }
    getOffsetRightBarCount() {
        return this._offsetRightBarCount;
    }
    setOffsetRightBarCount(barCount) {
        this._offsetRightBarCount = barCount;
        return this;
    }
    setLeftMinVisibleBarCount(barCount) {
        this._minVisibleBarCount.left = barCount;
        return this;
    }
    setRightMinVisibleBarCount(barCount) {
        this._minVisibleBarCount.right = barCount;
        return this;
    }
    getVisibleRange() {
        return this._visibleRange;
    }
    startScroll() {
        this._startScrollOffsetRightBarCount = this._offsetRightBarCount;
    }
    scroll(distance) {
        if (!this._scrollEnabled) {
            return;
        }
        const distanceBarCount = distance / this._barSpace;
        this._chartStore.getActionStore().execute("onScroll" /* ActionType.onScroll */);
        this._offsetRightBarCount = this._startScrollOffsetRightBarCount - distanceBarCount;
        this.adjustVisibleRange();
        this._chartStore.getCrosshairStore().recalculate(true);
        this._chartStore.getChart().adjustPaneViewport(false, true, true, true);
    }
    getDataByDataIndex(dataIndex) {
        var _a;
        return (_a = this._chartStore.getDataList()[dataIndex]) !== null && _a !== void 0 ? _a : null;
    }
    coordinateToFloatIndex(x) {
        const dataCount = this._chartStore.getDataList().length;
        const deltaFromRight = (this._totalBarSpace - x) / this._barSpace;
        const index = dataCount + this._offsetRightBarCount - deltaFromRight;
        return Math.round(index * 1000000) / 1000000;
    }
    dataIndexToTimestamp(dataIndex) {
        var _a;
        const data = this.getDataByDataIndex(dataIndex);
        return (_a = data === null || data === void 0 ? void 0 : data.timestamp) !== null && _a !== void 0 ? _a : null;
    }
    timestampToDataIndex(timestamp) {
        const dataList = this._chartStore.getDataList();
        if (dataList.length === 0) {
            return 0;
        }
        return binarySearchNearest(dataList, 'timestamp', timestamp);
    }
    dataIndexToCoordinate(dataIndex) {
        const dataCount = this._chartStore.getDataList().length;
        const deltaFromRight = dataCount + this._offsetRightBarCount - dataIndex;
        return this._totalBarSpace - (deltaFromRight - 0.5) * this._barSpace;
    }
    coordinateToDataIndex(x) {
        return Math.ceil(this.coordinateToFloatIndex(x)) - 1;
    }
    zoom(scale, coordinate) {
        if (!this._zoomEnabled) {
            return;
        }
        if ((coordinate === null || coordinate === void 0 ? void 0 : coordinate.x) === undefined) {
            const crosshair = this._chartStore.getCrosshairStore().get();
            coordinate = { x: (crosshair === null || crosshair === void 0 ? void 0 : crosshair.x) !== undefined ? crosshair.x : this._totalBarSpace / 2 };
        }
        this._chartStore.getActionStore().execute("onZoom" /* ActionType.onZoom */);
        const floatIndex = this.coordinateToFloatIndex(coordinate.x);
        const barSpace = this._barSpace + scale * (this._barSpace / 10);
        this.setBarSpace(barSpace, () => {
            this._offsetRightBarCount += (floatIndex - this.coordinateToFloatIndex(coordinate === null || coordinate === void 0 ? void 0 : coordinate.x));
        });
    }
    setZoomEnabled(enabled) {
        this._zoomEnabled = enabled;
        return this;
    }
    getZoomEnabled() {
        return this._zoomEnabled;
    }
    setScrollEnabled(enabled) {
        this._scrollEnabled = enabled;
        return this;
    }
    getScrollEnabled() {
        return this._scrollEnabled;
    }
    setLoadMoreCallback(callback) {
        this._loadMoreCallback = callback;
        return this;
    }
    clear() {
        this._more = true;
        this._loading = true;
        this._visibleRange = { from: 0, to: 0 };
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function eachFigures(kLineDataList, indicator, dataIndex, defaultStyles, eachFigureCallback) {
    const result = indicator.result;
    const figures = indicator.figures;
    const styles = indicator.styles;
    const circleStyles = formatValue(styles, 'circles', defaultStyles.circles);
    const circleStyleCount = circleStyles.length;
    const barStyles = formatValue(styles, 'bars', defaultStyles.bars);
    const barStyleCount = barStyles.length;
    const lineStyles = formatValue(styles, 'lines', defaultStyles.lines);
    const lineStyleCount = lineStyles.length;
    let circleCount = 0;
    let barCount = 0;
    let lineCount = 0;
    let typeCount = 0;
    let defaultFigureStyles;
    let defaultFigureStyle;
    let defaultFigureColor;
    figures.forEach(figure => {
        var _a, _b, _c, _d;
        switch (figure.type) {
            case 'circle': {
                defaultFigureStyles = circleStyles[circleCount % circleStyleCount];
                defaultFigureStyle = defaultFigureStyles.style;
                defaultFigureColor = defaultFigureStyles.noChangeColor;
                typeCount = circleCount;
                circleCount++;
                break;
            }
            case 'bar': {
                defaultFigureStyles = barStyles[barCount % barStyleCount];
                defaultFigureStyle = defaultFigureStyles.style;
                defaultFigureColor = defaultFigureStyles.noChangeColor;
                typeCount = barCount;
                barCount++;
                break;
            }
            case 'line': {
                defaultFigureStyles = lineStyles[lineCount % lineStyleCount];
                defaultFigureStyle = defaultFigureStyles.style;
                defaultFigureColor = defaultFigureStyles.color;
                typeCount = lineCount;
                lineCount++;
                break;
            }
        }
        if (isValid(defaultFigureStyles)) {
            const cbData = {
                prev: { kLineData: kLineDataList[dataIndex - 1], indicatorData: result[dataIndex - 1] },
                current: { kLineData: kLineDataList[dataIndex], indicatorData: result[dataIndex] },
                next: { kLineData: kLineDataList[dataIndex + 1], indicatorData: result[dataIndex + 1] }
            };
            const figureStyles = (_b = (_a = figure.styles) === null || _a === void 0 ? void 0 : _a.call(figure, cbData, indicator, defaultStyles)) !== null && _b !== void 0 ? _b : { style: defaultFigureStyle, color: defaultFigureColor };
            eachFigureCallback(figure, {
                style: ((_c = figureStyles.style) !== null && _c !== void 0 ? _c : defaultFigureStyle),
                color: (_d = figureStyles.color) !== null && _d !== void 0 ? _d : defaultFigureColor
            }, defaultFigureStyles, typeCount);
        }
    });
}
class IndicatorImp {
    constructor(indicator) {
        this.result = [];
        this._precisionFlag = false;
        const { name, shortName, series, calcParams, figures, precision, shouldOhlc, shouldFormatBigNumber, minValue, maxValue, styles, extendData, regenerateFigures, createTooltipDataSource, draw } = indicator;
        this.name = name;
        this.shortName = shortName !== null && shortName !== void 0 ? shortName : name;
        this.series = series !== null && series !== void 0 ? series : "normal" /* IndicatorSeries.NORMAL */;
        this.precision = precision !== null && precision !== void 0 ? precision : 4;
        this.calcParams = calcParams !== null && calcParams !== void 0 ? calcParams : [];
        this.figures = figures !== null && figures !== void 0 ? figures : [];
        this.shouldOhlc = shouldOhlc !== null && shouldOhlc !== void 0 ? shouldOhlc : false;
        this.shouldFormatBigNumber = shouldFormatBigNumber !== null && shouldFormatBigNumber !== void 0 ? shouldFormatBigNumber : false;
        this.minValue = minValue !== null && minValue !== void 0 ? minValue : null;
        this.maxValue = maxValue !== null && maxValue !== void 0 ? maxValue : null;
        this.styles = styles !== null && styles !== void 0 ? styles : null;
        this.extendData = extendData;
        this.regenerateFigures = regenerateFigures !== null && regenerateFigures !== void 0 ? regenerateFigures : null;
        this.createTooltipDataSource = createTooltipDataSource !== null && createTooltipDataSource !== void 0 ? createTooltipDataSource : null;
        this.draw = draw !== null && draw !== void 0 ? draw : null;
    }
    setShortName(shortName) {
        if (this.shortName !== shortName) {
            this.shortName = shortName;
            return true;
        }
        return false;
    }
    setSeries(series) {
        if (this.series !== series) {
            this.series = series;
            return true;
        }
        return false;
    }
    setPrecision(precision, flag) {
        const f = flag !== null && flag !== void 0 ? flag : false;
        const optimalPrecision = Math.floor(precision);
        if (optimalPrecision !== this.precision && precision >= 0 && (!f || (f && !this._precisionFlag))) {
            this.precision = optimalPrecision;
            if (!f) {
                this._precisionFlag = true;
            }
            return true;
        }
        return false;
    }
    setCalcParams(params) {
        var _a, _b;
        this.calcParams = params;
        this.figures = (_b = (_a = this.regenerateFigures) === null || _a === void 0 ? void 0 : _a.call(this, params)) !== null && _b !== void 0 ? _b : this.figures;
        return true;
    }
    setShouldOhlc(shouldOhlc) {
        if (this.shouldOhlc !== shouldOhlc) {
            this.shouldOhlc = shouldOhlc;
            return true;
        }
        return false;
    }
    setShouldFormatBigNumber(shouldFormatBigNumber) {
        if (this.shouldFormatBigNumber !== shouldFormatBigNumber) {
            this.shouldFormatBigNumber = shouldFormatBigNumber;
            return true;
        }
        return false;
    }
    setStyles(styles) {
        if (this.styles !== styles) {
            this.styles = styles;
            return true;
        }
        return false;
    }
    setExtendData(extendData) {
        if (this.extendData !== extendData) {
            this.extendData = extendData;
            return true;
        }
        return false;
    }
    setFigures(figures) {
        if (this.figures !== figures) {
            this.figures = figures;
            return true;
        }
        return false;
    }
    setMinValue(value) {
        if (this.minValue !== value) {
            this.minValue = value;
            return true;
        }
        return false;
    }
    setMaxValue(value) {
        if (this.maxValue !== value) {
            this.maxValue = value;
            return true;
        }
        return false;
    }
    setRegenerateFigures(callback) {
        if (this.regenerateFigures !== callback) {
            this.regenerateFigures = callback;
            return true;
        }
        return false;
    }
    setCreateTooltipDataSource(callback) {
        if (this.createTooltipDataSource !== callback) {
            this.createTooltipDataSource = callback;
            return true;
        }
        return false;
    }
    setDraw(callback) {
        if (this.draw !== callback) {
            this.draw = callback;
            return true;
        }
        return false;
    }
    async calcIndicator(dataList) {
        try {
            const result = await this.calc(dataList, this);
            this.result = result;
            return true;
        }
        catch (e) {
            return false;
        }
    }
    static extend(template) {
        class Custom extends IndicatorImp {
            constructor() {
                super(template);
            }
            calc(dataList, indicator) {
                return template.calc(dataList, indicator);
            }
        }
        return Custom;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * averager price
 */
const averagePrice = {
    name: 'AVP',
    shortName: 'AVP',
    series: "price" /* IndicatorSeries.PRICE */,
    precision: 2,
    figures: [
        { key: 'avp', title: 'AVP: ', type: 'line' }
    ],
    calc: (dataList) => {
        let totalTurnover = 0;
        let totalVolume = 0;
        return dataList.map((kLineData) => {
            var _a, _b;
            const avp = {};
            const turnover = (_a = kLineData === null || kLineData === void 0 ? void 0 : kLineData.turnover) !== null && _a !== void 0 ? _a : 0;
            const volume = (_b = kLineData === null || kLineData === void 0 ? void 0 : kLineData.volume) !== null && _b !== void 0 ? _b : 0;
            totalTurnover += turnover;
            totalVolume += volume;
            if (totalVolume !== 0) {
                avp.avp = totalTurnover / totalVolume;
            }
            return avp;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const awesomeOscillator = {
    name: 'AO',
    shortName: 'AO',
    calcParams: [5, 34],
    figures: [{
            key: 'ao',
            title: 'AO: ',
            type: 'bar',
            baseValue: 0,
            styles: (data, indicator, defaultStyles) => {
                var _a, _b, _c, _d;
                const { prev, current } = data;
                const prevAo = (_b = (_a = prev.indicatorData) === null || _a === void 0 ? void 0 : _a.ao) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
                const currentAo = (_d = (_c = current.indicatorData) === null || _c === void 0 ? void 0 : _c.ao) !== null && _d !== void 0 ? _d : Number.MIN_SAFE_INTEGER;
                let color;
                if (currentAo > prevAo) {
                    color = formatValue(indicator.styles, 'bars[0].upColor', (defaultStyles.bars)[0].upColor);
                }
                else {
                    color = formatValue(indicator.styles, 'bars[0].downColor', (defaultStyles.bars)[0].downColor);
                }
                const style = currentAo > prevAo ? 'stroke' : 'fill';
                return { color, style };
            }
        }],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const maxPeriod = Math.max(params[0], params[1]);
        let shortSum = 0;
        let longSum = 0;
        let short = 0;
        let long = 0;
        return dataList.map((kLineData, i) => {
            const ao = {};
            const middle = (kLineData.low + kLineData.high) / 2;
            shortSum += middle;
            longSum += middle;
            if (i >= params[0] - 1) {
                short = shortSum / params[0];
                const agoKLineData = dataList[i - (params[0] - 1)];
                shortSum -= ((agoKLineData.low + agoKLineData.high) / 2);
            }
            if (i >= params[1] - 1) {
                long = longSum / params[1];
                const agoKLineData = dataList[i - (params[1] - 1)];
                longSum -= ((agoKLineData.low + agoKLineData.high) / 2);
            }
            if (i >= maxPeriod - 1) {
                ao.ao = short - long;
            }
            return ao;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * BIAS
 * 乖离率=[(当日收盘价-N日平均价)/N日平均价]*100%
 */
const bias = {
    name: 'BIAS',
    shortName: 'BIAS',
    calcParams: [6, 12, 24],
    figures: [
        { key: 'bias1', title: 'BIAS6: ', type: 'line' },
        { key: 'bias2', title: 'BIAS12: ', type: 'line' },
        { key: 'bias3', title: 'BIAS24: ', type: 'line' }
    ],
    regenerateFigures: (params) => {
        return params.map((p, i) => {
            return { key: `bias${i + 1}`, title: `BIAS${p}: `, type: 'line' };
        });
    },
    calc: (dataList, indicator) => {
        const { calcParams: params, figures } = indicator;
        const closeSums = [];
        return dataList.map((kLineData, i) => {
            const bias = {};
            const close = kLineData.close;
            params.forEach((p, index) => {
                var _a;
                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;
                if (i >= p - 1) {
                    const mean = closeSums[index] / params[index];
                    bias[figures[index].key] = (close - mean) / mean * 100;
                    closeSums[index] -= dataList[i - (p - 1)].close;
                }
            });
            return bias;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 计算布林指标中的标准差
 * @param dataList
 * @param ma
 * @return {number}
 */
function getBollMd(dataList, ma) {
    const dataSize = dataList.length;
    let sum = 0;
    dataList.forEach(data => {
        const closeMa = data.close - ma;
        sum += closeMa * closeMa;
    });
    sum = Math.abs(sum);
    return Math.sqrt(sum / dataSize);
}
/**
 * BOLL
 */
const bollingerBands = {
    name: 'BOLL',
    shortName: 'BOLL',
    series: "price" /* IndicatorSeries.PRICE */,
    calcParams: [20, 2],
    precision: 2,
    shouldOhlc: true,
    figures: [
        { key: 'up', title: 'UP: ', type: 'line' },
        { key: 'mid', title: 'MID: ', type: 'line' },
        { key: 'dn', title: 'DN: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const p = params[0] - 1;
        let closeSum = 0;
        return dataList.map((kLineData, i) => {
            const close = kLineData.close;
            const boll = {};
            closeSum += close;
            if (i >= p) {
                boll.mid = closeSum / params[0];
                const md = getBollMd(dataList.slice(i - p, i + 1), boll.mid);
                boll.up = boll.mid + params[1] * md;
                boll.dn = boll.mid - params[1] * md;
                closeSum -= dataList[i - p].close;
            }
            return boll;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * BRAR
 * 默认参数是26。
 * 公式N日BR=N日内（H－CY）之和除以N日内（CY－L）之和*100，
 * 其中，H为当日最高价，L为当日最低价，CY为前一交易日的收盘价，N为设定的时间参数。
 * N日AR=(N日内（H－O）之和除以N日内（O－L）之和)*100，
 * 其中，H为当日最高价，L为当日最低价，O为当日开盘价，N为设定的时间参数
 *
 */
const brar = {
    name: 'BRAR',
    shortName: 'BRAR',
    calcParams: [26],
    figures: [
        { key: 'br', title: 'BR: ', type: 'line' },
        { key: 'ar', title: 'AR: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let hcy = 0;
        let cyl = 0;
        let ho = 0;
        let ol = 0;
        return dataList.map((kLineData, i) => {
            var _a, _b;
            const brar = {};
            const high = kLineData.high;
            const low = kLineData.low;
            const open = kLineData.open;
            const prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
            ho += (high - open);
            ol += (open - low);
            hcy += (high - prevClose);
            cyl += (prevClose - low);
            if (i >= params[0] - 1) {
                if (ol !== 0) {
                    brar.ar = ho / ol * 100;
                }
                else {
                    brar.ar = 0;
                }
                if (cyl !== 0) {
                    brar.br = hcy / cyl * 100;
                }
                else {
                    brar.br = 0;
                }
                const agoKLineData = dataList[i - (params[0] - 1)];
                const agoHigh = agoKLineData.high;
                const agoLow = agoKLineData.low;
                const agoOpen = agoKLineData.open;
                const agoPreClose = ((_b = dataList[i - params[0]]) !== null && _b !== void 0 ? _b : dataList[i - (params[0] - 1)]).close;
                hcy -= (agoHigh - agoPreClose);
                cyl -= (agoPreClose - agoLow);
                ho -= (agoHigh - agoOpen);
                ol -= (agoOpen - agoLow);
            }
            return brar;
        });
    }
};

/**
 * 多空指标
 * 公式: BBI = (MA(CLOSE, M) + MA(CLOSE, N) + MA(CLOSE, O) + MA(CLOSE, P)) / 4
 *
 */
const bullAndBearIndex = {
    name: 'BBI',
    shortName: 'BBI',
    series: "price" /* IndicatorSeries.PRICE */,
    precision: 2,
    calcParams: [3, 6, 12, 24],
    shouldOhlc: true,
    figures: [
        { key: 'bbi', title: 'BBI: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const maxPeriod = Math.max(...params);
        const closeSums = [];
        const mas = [];
        return dataList.map((kLineData, i) => {
            const bbi = {};
            const close = kLineData.close;
            params.forEach((p, index) => {
                var _a;
                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;
                if (i >= p - 1) {
                    mas[index] = closeSums[index] / p;
                    closeSums[index] -= dataList[i - (p - 1)].close;
                }
            });
            if (i >= maxPeriod - 1) {
                let maSum = 0;
                mas.forEach(ma => {
                    maSum += ma;
                });
                bbi.bbi = maSum / 4;
            }
            return bbi;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * CCI
 * CCI（N日）=（TP－MA）÷MD÷0.015
 * 其中，TP=（最高价+最低价+收盘价）÷3
 * MA=近N日TP价的累计之和÷N
 * MD=近N日TP - 当前MA绝对值的累计之和÷N
 *
 */
const commodityChannelIndex = {
    name: 'CCI',
    shortName: 'CCI',
    calcParams: [20],
    figures: [
        { key: 'cci', title: 'CCI: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const p = params[0] - 1;
        let tpSum = 0;
        const tpList = [];
        return dataList.map((kLineData, i) => {
            const cci = {};
            const tp = (kLineData.high + kLineData.low + kLineData.close) / 3;
            tpSum += tp;
            tpList.push(tp);
            if (i >= p) {
                const maTp = tpSum / params[0];
                const sliceTpList = tpList.slice(i - p, i + 1);
                let sum = 0;
                sliceTpList.forEach(tp => {
                    sum += Math.abs(tp - maTp);
                });
                const md = sum / params[0];
                cci.cci = md !== 0 ? (tp - maTp) / md / 0.015 : 0;
                const agoTp = (dataList[i - p].high + dataList[i - p].low + dataList[i - p].close) / 3;
                tpSum -= agoTp;
            }
            return cci;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http:*www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * MID:=REF(HIGH+LOW,1)/2;
 * CR:SUM(MAX(0,HIGH-MID),N)/SUM(MAX(0,MID-LOW),N)*100;
 * MA1:REF(MA(CR,M1),M1/2.5+1);
 * MA2:REF(MA(CR,M2),M2/2.5+1);
 * MA3:REF(MA(CR,M3),M3/2.5+1);
 * MA4:REF(MA(CR,M4),M4/2.5+1);
 * MID赋值:(昨日最高价+昨日最低价)/2
 * 输出带状能量线:0和最高价-MID的较大值的N日累和/0和MID-最低价的较大值的N日累和*100
 * 输出MA1:M1(5)/2.5+1日前的CR的M1(5)日简单移动平均
 * 输出MA2:M2(10)/2.5+1日前的CR的M2(10)日简单移动平均
 * 输出MA3:M3(20)/2.5+1日前的CR的M3(20)日简单移动平均
 * 输出MA4:M4/2.5+1日前的CR的M4日简单移动平均
 *
 */
const currentRatio = {
    name: 'CR',
    shortName: 'CR',
    calcParams: [26, 10, 20, 40, 60],
    figures: [
        { key: 'cr', title: 'CR: ', type: 'line' },
        { key: 'ma1', title: 'MA1: ', type: 'line' },
        { key: 'ma2', title: 'MA2: ', type: 'line' },
        { key: 'ma3', title: 'MA3: ', type: 'line' },
        { key: 'ma4', title: 'MA4: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const ma1ForwardPeriod = Math.ceil(params[1] / 2.5 + 1);
        const ma2ForwardPeriod = Math.ceil(params[2] / 2.5 + 1);
        const ma3ForwardPeriod = Math.ceil(params[3] / 2.5 + 1);
        const ma4ForwardPeriod = Math.ceil(params[4] / 2.5 + 1);
        let ma1Sum = 0;
        const ma1List = [];
        let ma2Sum = 0;
        const ma2List = [];
        let ma3Sum = 0;
        const ma3List = [];
        let ma4Sum = 0;
        const ma4List = [];
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a, _b, _c, _d, _e;
            const cr = {};
            const prevData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;
            const prevMid = (prevData.high + prevData.close + prevData.low + prevData.open) / 4;
            const highSubPreMid = Math.max(0, kLineData.high - prevMid);
            const preMidSubLow = Math.max(0, prevMid - kLineData.low);
            if (i >= params[0] - 1) {
                if (preMidSubLow !== 0) {
                    cr.cr = highSubPreMid / preMidSubLow * 100;
                }
                else {
                    cr.cr = 0;
                }
                ma1Sum += cr.cr;
                ma2Sum += cr.cr;
                ma3Sum += cr.cr;
                ma4Sum += cr.cr;
                if (i >= params[0] + params[1] - 2) {
                    ma1List.push(ma1Sum / params[1]);
                    if (i >= params[0] + params[1] + ma1ForwardPeriod - 3) {
                        cr.ma1 = ma1List[ma1List.length - 1 - ma1ForwardPeriod];
                    }
                    ma1Sum -= ((_b = result[i - (params[1] - 1)].cr) !== null && _b !== void 0 ? _b : 0);
                }
                if (i >= params[0] + params[2] - 2) {
                    ma2List.push(ma2Sum / params[2]);
                    if (i >= params[0] + params[2] + ma2ForwardPeriod - 3) {
                        cr.ma2 = ma2List[ma2List.length - 1 - ma2ForwardPeriod];
                    }
                    ma2Sum -= ((_c = result[i - (params[2] - 1)].cr) !== null && _c !== void 0 ? _c : 0);
                }
                if (i >= params[0] + params[3] - 2) {
                    ma3List.push(ma3Sum / params[3]);
                    if (i >= params[0] + params[3] + ma3ForwardPeriod - 3) {
                        cr.ma3 = ma3List[ma3List.length - 1 - ma3ForwardPeriod];
                    }
                    ma3Sum -= ((_d = result[i - (params[3] - 1)].cr) !== null && _d !== void 0 ? _d : 0);
                }
                if (i >= params[0] + params[4] - 2) {
                    ma4List.push(ma4Sum / params[4]);
                    if (i >= params[0] + params[4] + ma4ForwardPeriod - 3) {
                        cr.ma4 = ma4List[ma4List.length - 1 - ma4ForwardPeriod];
                    }
                    ma4Sum -= ((_e = result[i - (params[4] - 1)].cr) !== null && _e !== void 0 ? _e : 0);
                }
            }
            result.push(cr);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * DMA
 * 公式：DIF:MA(CLOSE,N1)-MA(CLOSE,N2);DIFMA:MA(DIF,M)
 */
const differentOfMovingAverage = {
    name: 'DMA',
    shortName: 'DMA',
    calcParams: [10, 50, 10],
    figures: [
        { key: 'dma', title: 'DMA: ', type: 'line' },
        { key: 'ama', title: 'AMA: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const maxPeriod = Math.max(params[0], params[1]);
        let closeSum1 = 0;
        let closeSum2 = 0;
        let dmaSum = 0;
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a;
            const dma = {};
            const close = kLineData.close;
            closeSum1 += close;
            closeSum2 += close;
            let ma1 = 0;
            let ma2 = 0;
            if (i >= params[0] - 1) {
                ma1 = closeSum1 / params[0];
                closeSum1 -= dataList[i - (params[0] - 1)].close;
            }
            if (i >= params[1] - 1) {
                ma2 = closeSum2 / params[1];
                closeSum2 -= dataList[i - (params[1] - 1)].close;
            }
            if (i >= maxPeriod - 1) {
                const dif = ma1 - ma2;
                dma.dma = dif;
                dmaSum += dif;
                if (i >= maxPeriod + params[2] - 2) {
                    dma.ama = dmaSum / params[2];
                    dmaSum -= ((_a = result[i - (params[2] - 1)].dma) !== null && _a !== void 0 ? _a : 0);
                }
            }
            result.push(dma);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * DMI
 *
 * MTR:=EXPMEMA(MAX(MAX(HIGH-LOW,ABS(HIGH-REF(CLOSE,1))),ABS(REF(CLOSE,1)-LOW)),N)
 * HD :=HIGH-REF(HIGH,1);
 * LD :=REF(LOW,1)-LOW;
 * DMP:=EXPMEMA(IF(HD>0&&HD>LD,HD,0),N);
 * DMM:=EXPMEMA(IF(LD>0&&LD>HD,LD,0),N);
 *
 * PDI: DMP*100/MTR;
 * MDI: DMM*100/MTR;
 * ADX: EXPMEMA(ABS(MDI-PDI)/(MDI+PDI)*100,MM);
 * ADXR:EXPMEMA(ADX,MM);
 * 公式含义：
 * MTR赋值:最高价-最低价和最高价-昨收的绝对值的较大值和昨收-最低价的绝对值的较大值的N日指数平滑移动平均
 * HD赋值:最高价-昨日最高价
 * LD赋值:昨日最低价-最低价
 * DMP赋值:如果HD>0并且HD>LD,返回HD,否则返回0的N日指数平滑移动平均
 * DMM赋值:如果LD>0并且LD>HD,返回LD,否则返回0的N日指数平滑移动平均
 * 输出PDI:DMP*100/MTR
 * 输出MDI:DMM*100/MTR
 * 输出ADX:MDI-PDI的绝对值/(MDI+PDI)*100的MM日指数平滑移动平均
 * 输出ADXR:ADX的MM日指数平滑移动平均
 *
 */
const directionalMovementIndex = {
    name: 'DMI',
    shortName: 'DMI',
    calcParams: [14, 6],
    figures: [
        { key: 'pdi', title: 'PDI: ', type: 'line' },
        { key: 'mdi', title: 'MDI: ', type: 'line' },
        { key: 'adx', title: 'ADX: ', type: 'line' },
        { key: 'adxr', title: 'ADXR: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let trSum = 0;
        let hSum = 0;
        let lSum = 0;
        let mtr = 0;
        let dmp = 0;
        let dmm = 0;
        let dxSum = 0;
        let adx = 0;
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a, _b;
            const dmi = {};
            const prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;
            const preClose = prevKLineData.close;
            const high = kLineData.high;
            const low = kLineData.low;
            const hl = high - low;
            const hcy = Math.abs(high - preClose);
            const lcy = Math.abs(preClose - low);
            const hhy = high - prevKLineData.high;
            const lyl = prevKLineData.low - low;
            const tr = Math.max(Math.max(hl, hcy), lcy);
            const h = (hhy > 0 && hhy > lyl) ? hhy : 0;
            const l = (lyl > 0 && lyl > hhy) ? lyl : 0;
            trSum += tr;
            hSum += h;
            lSum += l;
            if (i >= params[0] - 1) {
                if (i > params[0] - 1) {
                    mtr = mtr - mtr / params[0] + tr;
                    dmp = dmp - dmp / params[0] + h;
                    dmm = dmm - dmm / params[0] + l;
                }
                else {
                    mtr = trSum;
                    dmp = hSum;
                    dmm = lSum;
                }
                let pdi = 0;
                let mdi = 0;
                if (mtr !== 0) {
                    pdi = dmp * 100 / mtr;
                    mdi = dmm * 100 / mtr;
                }
                dmi.pdi = pdi;
                dmi.mdi = mdi;
                let dx = 0;
                if (mdi + pdi !== 0) {
                    dx = Math.abs((mdi - pdi)) / (mdi + pdi) * 100;
                }
                dxSum += dx;
                if (i >= params[0] * 2 - 2) {
                    if (i > params[0] * 2 - 2) {
                        adx = (adx * (params[0] - 1) + dx) / params[0];
                    }
                    else {
                        adx = dxSum / params[0];
                    }
                    dmi.adx = adx;
                    if (i >= params[0] * 2 + params[1] - 3) {
                        dmi.adxr = (((_b = result[i - (params[1] - 1)].adx) !== null && _b !== void 0 ? _b : 0) + adx) / 2;
                    }
                }
            }
            result.push(dmi);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 *
 * EMV 简易波动指标
 * 公式：
 * A=（今日最高+今日最低）/2
 * B=（前日最高+前日最低）/2
 * C=今日最高-今日最低
 * EM=（A-B）*C/今日成交额
 * EMV=N日内EM的累和
 * MAEMV=EMV的M日的简单移动平均
 *
 */
const easeOfMovementValue = {
    name: 'EMV',
    shortName: 'EMV',
    calcParams: [14, 9],
    figures: [
        { key: 'emv', title: 'EMV: ', type: 'line' },
        { key: 'maEmv', title: 'MAEMV: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let emSum = 0;
        let emvSum = 0;
        const emList = [];
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a, _b, _c;
            const emv = {};
            const prevKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;
            const high = kLineData.high;
            const low = kLineData.low;
            const turnover = (_b = kLineData.turnover) !== null && _b !== void 0 ? _b : 0;
            const halfHl = (high + low) / 2;
            const prevHalfHl = (prevKLineData.high + prevKLineData.low) / 2;
            const hl = high - low;
            let em = 0;
            if (turnover !== 0) {
                em = (halfHl - prevHalfHl) * hl / turnover;
            }
            emList.push(em);
            emSum += em;
            if (i >= params[0] - 1) {
                emv.emv = emSum;
                emSum -= emList[i - (params[0] - 1)];
                emvSum += emv.emv;
                if (i >= params[0] + params[1] - 2) {
                    emv.maEmv = emvSum / params[1];
                    emvSum -= ((_c = result[i - (params[1] - 1)].emv) !== null && _c !== void 0 ? _c : 0);
                }
            }
            result.push(emv);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * EMA 指数移动平均
 */
const exponentialMovingAverage = {
    name: 'EMA',
    shortName: 'EMA',
    series: "price" /* IndicatorSeries.PRICE */,
    calcParams: [6, 12, 20],
    precision: 2,
    shouldOhlc: true,
    figures: [
        { key: 'ema1', title: 'EMA6: ', type: 'line' },
        { key: 'ema2', title: 'EMA12: ', type: 'line' },
        { key: 'ema3', title: 'EMA20: ', type: 'line' }
    ],
    regenerateFigures: (params) => {
        return params.map((p, i) => {
            return { key: `ema${i + 1}`, title: `EMA${p}: `, type: 'line' };
        });
    },
    calc: (dataList, indicator) => {
        const { calcParams: params, figures } = indicator;
        let closeSum = 0;
        const emaValues = [];
        return dataList.map((kLineData, i) => {
            const ema = {};
            const close = kLineData.close;
            closeSum += close;
            params.forEach((p, index) => {
                if (i >= p - 1) {
                    if (i > p - 1) {
                        emaValues[index] = (2 * close + (p - 1) * emaValues[index]) / (p + 1);
                    }
                    else {
                        emaValues[index] = closeSum / p;
                    }
                    ema[figures[index].key] = emaValues[index];
                }
            });
            return ema;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * mtm
 * 公式 MTM（N日）=C－CN
 */
const momentum = {
    name: 'MTM',
    shortName: 'MTM',
    calcParams: [12, 6],
    figures: [
        { key: 'mtm', title: 'MTM: ', type: 'line' },
        { key: 'maMtm', title: 'MAMTM: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let mtmSum = 0;
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a;
            const mtm = {};
            if (i >= params[0]) {
                const close = kLineData.close;
                const agoClose = dataList[i - params[0]].close;
                mtm.mtm = close - agoClose;
                mtmSum += mtm.mtm;
                if (i >= params[0] + params[1] - 1) {
                    mtm.maMtm = mtmSum / params[1];
                    mtmSum -= ((_a = result[i - (params[1] - 1)].mtm) !== null && _a !== void 0 ? _a : 0);
                }
            }
            result.push(mtm);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * MA 移动平均
 */
const movingAverage = {
    name: 'MA',
    shortName: 'MA',
    series: "price" /* IndicatorSeries.PRICE */,
    calcParams: [5, 10, 30, 60],
    precision: 2,
    shouldOhlc: true,
    figures: [
        { key: 'ma5', title: 'MA5: ', type: 'line' },
        { key: 'ma10', title: 'MA10: ', type: 'line' },
        { key: 'ma30', title: 'MA30: ', type: 'line' },
        { key: 'ma60', title: 'MA60: ', type: 'line' }
    ],
    regenerateFigures: (params) => {
        return params.map((p, i) => {
            return { key: `ma${i + 1}`, title: `MA${p}: `, type: 'line' };
        });
    },
    calc: (dataList, indicator) => {
        const { calcParams: params, figures } = indicator;
        const closeSums = [];
        return dataList.map((kLineData, i) => {
            const ma = {};
            const close = kLineData.close;
            params.forEach((p, index) => {
                var _a;
                closeSums[index] = ((_a = closeSums[index]) !== null && _a !== void 0 ? _a : 0) + close;
                if (i >= p - 1) {
                    ma[figures[index].key] = closeSums[index] / p;
                    closeSums[index] -= dataList[i - (p - 1)].close;
                }
            });
            return ma;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * MACD：参数快线移动平均、慢线移动平均、移动平均，
 * 默认参数值12、26、9。
 * 公式：⒈首先分别计算出收盘价12日指数平滑移动平均线与26日指数平滑移动平均线，分别记为EMA(12）与EMA(26）。
 * ⒉求这两条指数平滑移动平均线的差，即：DIFF = EMA(SHORT) － EMA(LONG)。
 * ⒊再计算DIFF的M日的平均的指数平滑移动平均线，记为DEA。
 * ⒋最后用DIFF减DEA，得MACD。MACD通常绘制成围绕零轴线波动的柱形图。MACD柱状大于0涨颜色，小于0跌颜色。
 */
const movingAverageConvergenceDivergence = {
    name: 'MACD',
    shortName: 'MACD',
    calcParams: [12, 26, 9],
    figures: [
        { key: 'dif', title: 'DIF: ', type: 'line' },
        { key: 'dea', title: 'DEA: ', type: 'line' },
        {
            key: 'macd',
            title: 'MACD: ',
            type: 'bar',
            baseValue: 0,
            styles: (data, indicator, defaultStyles) => {
                var _a, _b, _c, _d;
                const { prev, current } = data;
                const prevMacd = (_b = (_a = prev.indicatorData) === null || _a === void 0 ? void 0 : _a.macd) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
                const currentMacd = (_d = (_c = current.indicatorData) === null || _c === void 0 ? void 0 : _c.macd) !== null && _d !== void 0 ? _d : Number.MIN_SAFE_INTEGER;
                let color;
                if (currentMacd > 0) {
                    color = formatValue(indicator.styles, 'bars[0].upColor', (defaultStyles.bars)[0].upColor);
                }
                else if (currentMacd < 0) {
                    color = formatValue(indicator.styles, 'bars[0].downColor', (defaultStyles.bars)[0].downColor);
                }
                else {
                    color = formatValue(indicator.styles, 'bars[0].noChangeColor', (defaultStyles.bars)[0].noChangeColor);
                }
                const style = prevMacd < currentMacd ? 'stroke' : 'fill';
                return { style, color };
            }
        }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let closeSum = 0;
        let emaShort;
        let emaLong;
        let dif = 0;
        let difSum = 0;
        let dea = 0;
        const maxPeriod = Math.max(params[0], params[1]);
        return dataList.map((kLineData, i) => {
            const macd = {};
            const close = kLineData.close;
            closeSum += close;
            if (i >= params[0] - 1) {
                if (i > params[0] - 1) {
                    emaShort = (2 * close + (params[0] - 1) * emaShort) / (params[0] + 1);
                }
                else {
                    emaShort = closeSum / params[0];
                }
            }
            if (i >= params[1] - 1) {
                if (i > params[1] - 1) {
                    emaLong = (2 * close + (params[1] - 1) * emaLong) / (params[1] + 1);
                }
                else {
                    emaLong = closeSum / params[1];
                }
            }
            if (i >= maxPeriod - 1) {
                dif = emaShort - emaLong;
                macd.dif = dif;
                difSum += dif;
                if (i >= maxPeriod + params[2] - 2) {
                    if (i > maxPeriod + params[2] - 2) {
                        dea = (dif * 2 + dea * (params[2] - 1)) / (params[2] + 1);
                    }
                    else {
                        dea = difSum / params[2];
                    }
                    macd.macd = (dif - dea) * 2;
                    macd.dea = dea;
                }
            }
            return macd;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * OBV
 * OBV = REF(OBV) + sign * V
 */
const onBalanceVolume = {
    name: 'OBV',
    shortName: 'OBV',
    calcParams: [30],
    figures: [
        { key: 'obv', title: 'OBV: ', type: 'line' },
        { key: 'maObv', title: 'MAOBV: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let obvSum = 0;
        let oldObv = 0;
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a, _b, _c, _d;
            const preKLineData = (_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData;
            if (kLineData.close < preKLineData.close) {
                oldObv -= ((_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0);
            }
            else if (kLineData.close > preKLineData.close) {
                oldObv += ((_c = kLineData.volume) !== null && _c !== void 0 ? _c : 0);
            }
            const obv = { obv: oldObv };
            obvSum += oldObv;
            if (i >= params[0] - 1) {
                obv.maObv = obvSum / params[0];
                obvSum -= ((_d = result[i - (params[0] - 1)].obv) !== null && _d !== void 0 ? _d : 0);
            }
            result.push(obv);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 价量趋势指标
 * 公式:
 * X = (CLOSE - REF(CLOSE, 1)) / REF(CLOSE, 1) * VOLUME
 * PVT = SUM(X)
 *
 */
const priceAndVolumeTrend = {
    name: 'PVT',
    shortName: 'PVT',
    figures: [
        { key: 'pvt', title: 'PVT: ', type: 'line' }
    ],
    calc: (dataList) => {
        let sum = 0;
        return dataList.map((kLineData, i) => {
            var _a, _b;
            const pvt = {};
            const close = kLineData.close;
            const volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 1;
            const prevClose = ((_b = dataList[i - 1]) !== null && _b !== void 0 ? _b : kLineData).close;
            let x = 0;
            const total = prevClose * volume;
            if (total !== 0) {
                x = (close - prevClose) / total;
            }
            sum += x;
            pvt.pvt = sum;
            return pvt;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * PSY
 * 公式：PSY=N日内的上涨天数/N×100%。
 */
const psychologicalLine = {
    name: 'PSY',
    shortName: 'PSY',
    calcParams: [12, 6],
    figures: [
        { key: 'psy', title: 'PSY: ', type: 'line' },
        { key: 'maPsy', title: 'MAPSY: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let upCount = 0;
        let psySum = 0;
        const upList = [];
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a, _b;
            const psy = {};
            const prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
            const upFlag = kLineData.close - prevClose > 0 ? 1 : 0;
            upList.push(upFlag);
            upCount += upFlag;
            if (i >= params[0] - 1) {
                psy.psy = upCount / params[0] * 100;
                psySum += psy.psy;
                if (i >= params[0] + params[1] - 2) {
                    psy.maPsy = psySum / params[1];
                    psySum -= ((_b = result[i - (params[1] - 1)].psy) !== null && _b !== void 0 ? _b : 0);
                }
                upCount -= upList[i - (params[0] - 1)];
            }
            result.push(psy);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 变动率指标
 * 公式：ROC = (CLOSE - REF(CLOSE, N)) / REF(CLOSE, N)
 */
const rateOfChange = {
    name: 'ROC',
    shortName: 'ROC',
    calcParams: [12, 6],
    figures: [
        { key: 'roc', title: 'ROC: ', type: 'line' },
        { key: 'maRoc', title: 'MAROC: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const result = [];
        let rocSum = 0;
        dataList.forEach((kLineData, i) => {
            var _a, _b;
            const roc = {};
            if (i >= params[0] - 1) {
                const close = kLineData.close;
                const agoClose = ((_a = dataList[i - params[0]]) !== null && _a !== void 0 ? _a : dataList[i - (params[0] - 1)]).close;
                if (agoClose !== 0) {
                    roc.roc = (close - agoClose) / agoClose * 100;
                }
                else {
                    roc.roc = 0;
                }
                rocSum += roc.roc;
                if (i >= params[0] - 1 + params[1] - 1) {
                    roc.maRoc = rocSum / params[1];
                    rocSum -= ((_b = result[i - (params[1] - 1)].roc) !== null && _b !== void 0 ? _b : 0);
                }
            }
            result.push(roc);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * RSI
 * RSI = SUM(MAX(CLOSE - REF(CLOSE,1),0),N) / SUM(ABS(CLOSE - REF(CLOSE,1)),N) × 100
 */
const relativeStrengthIndex = {
    name: 'RSI',
    shortName: 'RSI',
    calcParams: [6, 12, 24],
    figures: [
        { key: 'rsi1', title: 'RSI1: ', type: 'line' },
        { key: 'rsi2', title: 'RSI2: ', type: 'line' },
        { key: 'rsi3', title: 'RSI3: ', type: 'line' }
    ],
    regenerateFigures: (params) => {
        return params.map((_, index) => {
            const num = index + 1;
            return { key: `rsi${num}`, title: `RSI${num}: `, type: 'line' };
        });
    },
    calc: (dataList, indicator) => {
        const { calcParams: params, figures } = indicator;
        const sumCloseAs = [];
        const sumCloseBs = [];
        return dataList.map((kLineData, i) => {
            var _a;
            const rsi = {};
            const prevClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
            const tmp = kLineData.close - prevClose;
            params.forEach((p, index) => {
                var _a, _b, _c;
                if (tmp > 0) {
                    sumCloseAs[index] = ((_a = sumCloseAs[index]) !== null && _a !== void 0 ? _a : 0) + tmp;
                }
                else {
                    sumCloseBs[index] = ((_b = sumCloseBs[index]) !== null && _b !== void 0 ? _b : 0) + Math.abs(tmp);
                }
                if (i >= p - 1) {
                    if (sumCloseBs[index] !== 0) {
                        rsi[figures[index].key] = 100 - (100.0 / (1 + sumCloseAs[index] / sumCloseBs[index]));
                    }
                    else {
                        rsi[figures[index].key] = 0;
                    }
                    const agoData = dataList[i - (p - 1)];
                    const agoPreData = (_c = dataList[i - p]) !== null && _c !== void 0 ? _c : agoData;
                    const agoTmp = agoData.close - agoPreData.close;
                    if (agoTmp > 0) {
                        sumCloseAs[index] -= agoTmp;
                    }
                    else {
                        sumCloseBs[index] -= Math.abs(agoTmp);
                    }
                }
            });
            return rsi;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * sma
 */
const simpleMovingAverage = {
    name: 'SMA',
    shortName: 'SMA',
    series: "price" /* IndicatorSeries.PRICE */,
    calcParams: [12, 2],
    precision: 2,
    figures: [
        { key: 'sma', title: 'SMA: ', type: 'line' }
    ],
    shouldOhlc: true,
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let closeSum = 0;
        let smaValue = 0;
        return dataList.map((kLineData, i) => {
            const sma = {};
            const close = kLineData.close;
            closeSum += close;
            if (i >= params[0] - 1) {
                if (i > params[0] - 1) {
                    smaValue = (close * params[1] + smaValue * (params[0] - params[1] + 1)) / (params[0] + 1);
                }
                else {
                    smaValue = closeSum / params[0];
                }
                sma.sma = smaValue;
            }
            return sma;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * KDJ
 *
 * 当日K值=2/3×前一日K值+1/3×当日RSV
 * 当日D值=2/3×前一日D值+1/3×当日K值
 * 若无前一日K 值与D值，则可分别用50来代替。
 * J值=3*当日K值-2*当日D值
 */
const stoch = {
    name: 'KDJ',
    shortName: 'KDJ',
    calcParams: [9, 3, 3],
    figures: [
        { key: 'k', title: 'K: ', type: 'line' },
        { key: 'd', title: 'D: ', type: 'line' },
        { key: 'j', title: 'J: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a, _b, _c, _d;
            const kdj = {};
            const close = kLineData.close;
            if (i >= params[0] - 1) {
                const lhn = getMaxMin(dataList.slice(i - (params[0] - 1), i + 1), 'high', 'low');
                const hn = lhn[0];
                const ln = lhn[1];
                const hnSubLn = hn - ln;
                const rsv = (close - ln) / (hnSubLn === 0 ? 1 : hnSubLn) * 100;
                kdj.k = ((params[1] - 1) * ((_b = (_a = result[i - 1]) === null || _a === void 0 ? void 0 : _a.k) !== null && _b !== void 0 ? _b : 50) + rsv) / params[1];
                kdj.d = ((params[2] - 1) * ((_d = (_c = result[i - 1]) === null || _c === void 0 ? void 0 : _c.d) !== null && _d !== void 0 ? _d : 50) + kdj.k) / params[2];
                kdj.j = 3.0 * kdj.k - 2.0 * kdj.d;
            }
            result.push(kdj);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stopAndReverse = {
    name: 'SAR',
    shortName: 'SAR',
    series: "price" /* IndicatorSeries.PRICE */,
    calcParams: [2, 2, 20],
    precision: 2,
    shouldOhlc: true,
    figures: [
        {
            key: 'sar',
            title: 'SAR: ',
            type: 'circle',
            styles: (data, indicator, defaultStyles) => {
                var _a, _b;
                const { current } = data;
                const sar = (_b = (_a = current.indicatorData) === null || _a === void 0 ? void 0 : _a.sar) !== null && _b !== void 0 ? _b : Number.MIN_SAFE_INTEGER;
                const kLineData = current.kLineData;
                const halfHL = ((kLineData === null || kLineData === void 0 ? void 0 : kLineData.high) + (kLineData === null || kLineData === void 0 ? void 0 : kLineData.low)) / 2;
                const color = sar < halfHL
                    ? formatValue(indicator.styles, 'circles[0].upColor', (defaultStyles.circles)[0].upColor)
                    : formatValue(indicator.styles, 'circles[0].downColor', (defaultStyles.circles)[0].downColor);
                return { color };
            }
        }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        const startAf = params[0] / 100;
        const step = params[1] / 100;
        const maxAf = params[2] / 100;
        // 加速因子
        let af = startAf;
        // 极值
        let ep = -100;
        // 判断是上涨还是下跌  false：下跌
        let isIncreasing = false;
        let sar = 0;
        return dataList.map((kLineData, i) => {
            // 上一个周期的sar
            const preSar = sar;
            const high = kLineData.high;
            const low = kLineData.low;
            if (isIncreasing) {
                // 上涨
                if (ep === -100 || ep < high) {
                    // 重新初始化值
                    ep = high;
                    af = Math.min(af + step, maxAf);
                }
                sar = preSar + af * (ep - preSar);
                const lowMin = Math.min(dataList[Math.max(1, i) - 1].low, low);
                if (sar > kLineData.low) {
                    sar = ep;
                    // 重新初始化值
                    af = startAf;
                    ep = -100;
                    isIncreasing = !isIncreasing;
                }
                else if (sar > lowMin) {
                    sar = lowMin;
                }
            }
            else {
                if (ep === -100 || ep > low) {
                    // 重新初始化值
                    ep = low;
                    af = Math.min(af + step, maxAf);
                }
                sar = preSar + af * (ep - preSar);
                const highMax = Math.max(dataList[Math.max(1, i) - 1].high, high);
                if (sar < kLineData.high) {
                    sar = ep;
                    // 重新初始化值
                    af = 0;
                    ep = -100;
                    isIncreasing = !isIncreasing;
                }
                else if (sar < highMax) {
                    sar = highMax;
                }
            }
            return { sar };
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http:*www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * trix
 *
 * TR=收盘价的N日指数移动平均的N日指数移动平均的N日指数移动平均；
 * TRIX=(TR-昨日TR)/昨日TR*100；
 * MATRIX=TRIX的M日简单移动平均；
 * 默认参数N设为12，默认参数M设为9；
 * 默认参数12、9
 * 公式：MTR:=EMA(EMA(EMA(CLOSE,N),N),N)
 * TRIX:(MTR-REF(MTR,1))/REF(MTR,1)*100;
 * TRMA:MA(TRIX,M)
 *
 */
const tripleExponentiallySmoothedAverage = {
    name: 'TRIX',
    shortName: 'TRIX',
    calcParams: [12, 9],
    figures: [
        { key: 'trix', title: 'TRIX: ', type: 'line' },
        { key: 'maTrix', title: 'MATRIX: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let closeSum = 0;
        let ema1;
        let ema2;
        let oldTr;
        let ema1Sum = 0;
        let ema2Sum = 0;
        let trixSum = 0;
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a;
            const trix = {};
            const close = kLineData.close;
            closeSum += close;
            if (i >= params[0] - 1) {
                if (i > params[0] - 1) {
                    ema1 = (2 * close + (params[0] - 1) * ema1) / (params[0] + 1);
                }
                else {
                    ema1 = closeSum / params[0];
                }
                ema1Sum += ema1;
                if (i >= params[0] * 2 - 2) {
                    if (i > params[0] * 2 - 2) {
                        ema2 = (2 * ema1 + (params[0] - 1) * ema2) / (params[0] + 1);
                    }
                    else {
                        ema2 = ema1Sum / params[0];
                    }
                    ema2Sum += ema2;
                    if (i >= params[0] * 3 - 3) {
                        let tr;
                        let trixValue = 0;
                        if (i > params[0] * 3 - 3) {
                            tr = (2 * ema2 + (params[0] - 1) * oldTr) / (params[0] + 1);
                            trixValue = (tr - oldTr) / oldTr * 100;
                        }
                        else {
                            tr = ema2Sum / params[0];
                        }
                        oldTr = tr;
                        trix.trix = trixValue;
                        trixSum += trixValue;
                        if (i >= params[0] * 3 + params[1] - 4) {
                            trix.maTrix = trixSum / params[1];
                            trixSum -= ((_a = result[i - (params[1] - 1)].trix) !== null && _a !== void 0 ? _a : 0);
                        }
                    }
                }
            }
            result.push(trix);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const volume = {
    name: 'VOL',
    shortName: 'VOL',
    series: "volume" /* IndicatorSeries.VOLUME */,
    calcParams: [5, 10, 20],
    shouldFormatBigNumber: true,
    precision: 0,
    minValue: 0,
    figures: [
        { key: 'ma1', title: 'MA5: ', type: 'line' },
        { key: 'ma2', title: 'MA10: ', type: 'line' },
        { key: 'ma3', title: 'MA20: ', type: 'line' },
        {
            key: 'volume',
            title: 'VOLUME: ',
            type: 'bar',
            baseValue: 0,
            styles: (data, indicator, defaultStyles) => {
                const kLineData = data.current.kLineData;
                let color;
                if (kLineData.close > kLineData.open) {
                    color = formatValue(indicator.styles, 'bars[0].upColor', (defaultStyles.bars)[0].upColor);
                }
                else if (kLineData.close < kLineData.open) {
                    color = formatValue(indicator.styles, 'bars[0].downColor', (defaultStyles.bars)[0].downColor);
                }
                else {
                    color = formatValue(indicator.styles, 'bars[0].noChangeColor', (defaultStyles.bars)[0].noChangeColor);
                }
                return { color };
            }
        }
    ],
    regenerateFigures: (params) => {
        const figures = params.map((p, i) => {
            return { key: `ma${i + 1}`, title: `MA${p}: `, type: 'line' };
        });
        figures.push({
            key: 'volume',
            title: 'VOLUME: ',
            type: 'bar',
            baseValue: 0,
            styles: (data, indicator, defaultStyles) => {
                const kLineData = data.current.kLineData;
                let color;
                if (kLineData.close > kLineData.open) {
                    color = formatValue(indicator.styles, 'bars[0].upColor', (defaultStyles.bars)[0].upColor);
                }
                else if (kLineData.close < kLineData.open) {
                    color = formatValue(indicator.styles, 'bars[0].downColor', (defaultStyles.bars)[0].downColor);
                }
                else {
                    color = formatValue(indicator.styles, 'bars[0].noChangeColor', (defaultStyles.bars)[0].noChangeColor);
                }
                return { color };
            }
        });
        return figures;
    },
    calc: (dataList, indicator) => {
        const { calcParams: params, figures } = indicator;
        const volSums = [];
        return dataList.map((kLineData, i) => {
            var _a;
            const volume = (_a = kLineData.volume) !== null && _a !== void 0 ? _a : 0;
            const vol = { volume };
            params.forEach((p, index) => {
                var _a, _b;
                volSums[index] = ((_a = volSums[index]) !== null && _a !== void 0 ? _a : 0) + volume;
                if (i >= p - 1) {
                    vol[figures[index].key] = volSums[index] / p;
                    volSums[index] -= ((_b = dataList[i - (p - 1)].volume) !== null && _b !== void 0 ? _b : 0);
                }
            });
            return vol;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * VR
 * VR=（UVS+1/2PVS）/（DVS+1/2PVS）
 * 24天以来凡是股价上涨那一天的成交量都称为AV，将24天内的AV总和相加后称为UVS
 * 24天以来凡是股价下跌那一天的成交量都称为BV，将24天内的BV总和相加后称为DVS
 * 24天以来凡是股价不涨不跌，则那一天的成交量都称为CV，将24天内的CV总和相加后称为PVS
 *
 */
const volumeRatio = {
    name: 'VR',
    shortName: 'VR',
    calcParams: [26, 6],
    figures: [
        { key: 'vr', title: 'VR: ', type: 'line' },
        { key: 'maVr', title: 'MAVR: ', type: 'line' }
    ],
    calc: (dataList, indicator) => {
        const params = indicator.calcParams;
        let uvs = 0;
        let dvs = 0;
        let pvs = 0;
        let vrSum = 0;
        const result = [];
        dataList.forEach((kLineData, i) => {
            var _a, _b, _c, _d, _e;
            const vr = {};
            const close = kLineData.close;
            const preClose = ((_a = dataList[i - 1]) !== null && _a !== void 0 ? _a : kLineData).close;
            const volume = (_b = kLineData.volume) !== null && _b !== void 0 ? _b : 0;
            if (close > preClose) {
                uvs += volume;
            }
            else if (close < preClose) {
                dvs += volume;
            }
            else {
                pvs += volume;
            }
            if (i >= params[0] - 1) {
                const halfPvs = pvs / 2;
                if (dvs + halfPvs === 0) {
                    vr.vr = 0;
                }
                else {
                    vr.vr = (uvs + halfPvs) / (dvs + halfPvs) * 100;
                }
                vrSum += vr.vr;
                if (i >= params[0] + params[1] - 2) {
                    vr.maVr = vrSum / params[1];
                    vrSum -= ((_c = result[i - (params[1] - 1)].vr) !== null && _c !== void 0 ? _c : 0);
                }
                const agoData = dataList[i - (params[0] - 1)];
                const agoPreData = (_d = dataList[i - params[0]]) !== null && _d !== void 0 ? _d : agoData;
                const agoClose = agoData.close;
                const agoVolume = (_e = agoData.volume) !== null && _e !== void 0 ? _e : 0;
                if (agoClose > agoPreData.close) {
                    uvs -= agoVolume;
                }
                else if (agoClose < agoPreData.close) {
                    dvs -= agoVolume;
                }
                else {
                    pvs -= agoVolume;
                }
            }
            result.push(vr);
        });
        return result;
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * WR
 * 公式 WR(N) = 100 * [ C - HIGH(N) ] / [ HIGH(N)-LOW(N) ]
 */
const williamsR = {
    name: 'WR',
    shortName: 'WR',
    calcParams: [6, 10, 14],
    figures: [
        { key: 'wr1', title: 'WR1: ', type: 'line' },
        { key: 'wr2', title: 'WR2: ', type: 'line' },
        { key: 'wr3', title: 'WR3: ', type: 'line' }
    ],
    regenerateFigures: (params) => {
        return params.map((_, i) => {
            return { key: `wr${i + 1}`, title: `WR${i + 1}: `, type: 'line' };
        });
    },
    calc: (dataList, indicator) => {
        const { calcParams: params, figures } = indicator;
        return dataList.map((kLineData, i) => {
            const wr = {};
            const close = kLineData.close;
            params.forEach((param, index) => {
                const p = param - 1;
                if (i >= p) {
                    const hln = getMaxMin(dataList.slice(i - p, i + 1), 'high', 'low');
                    const hn = hln[0];
                    const ln = hln[1];
                    const hnSubLn = hn - ln;
                    wr[figures[index].key] = hnSubLn === 0 ? 0 : (close - hn) / hnSubLn * 100;
                }
            });
            return wr;
        });
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const indicators = {};
const extensions$2 = [
    averagePrice, awesomeOscillator, bias, bollingerBands, brar,
    bullAndBearIndex, commodityChannelIndex, currentRatio, differentOfMovingAverage,
    directionalMovementIndex, easeOfMovementValue, exponentialMovingAverage, momentum,
    movingAverage, movingAverageConvergenceDivergence, onBalanceVolume, priceAndVolumeTrend,
    psychologicalLine, rateOfChange, relativeStrengthIndex, simpleMovingAverage,
    stoch, stopAndReverse, tripleExponentiallySmoothedAverage, volume, volumeRatio, williamsR
];
extensions$2.forEach((indicator) => {
    indicators[indicator.name] = IndicatorImp.extend(indicator);
});
function registerIndicator(indicator) {
    indicators[indicator.name] = IndicatorImp.extend(indicator);
}
function getIndicatorClass(name) {
    var _a;
    return (_a = indicators[name]) !== null && _a !== void 0 ? _a : null;
}
function getSupportedIndicators() {
    return Object.keys(indicators);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndicatorStore {
    constructor(chartStore) {
        this._instances = new Map();
        this._chartStore = chartStore;
    }
    _overrideInstance(instance, indicator) {
        const { shortName, series, calcParams, precision, figures, minValue, maxValue, shouldOhlc, shouldFormatBigNumber, styles, extendData, regenerateFigures, createTooltipDataSource, draw, calc } = indicator;
        let updateFlag = false;
        if (shortName !== undefined && instance.setShortName(shortName)) {
            updateFlag = true;
        }
        if (series !== undefined && instance.setSeries(series)) {
            updateFlag = true;
        }
        let calcFlag = false;
        if (calcParams !== undefined && instance.setCalcParams(calcParams)) {
            updateFlag = true;
            calcFlag = true;
        }
        if (figures !== undefined && instance.setFigures(figures)) {
            updateFlag = true;
            calcFlag = true;
        }
        if (minValue !== undefined && instance.setMinValue(minValue)) {
            updateFlag = true;
        }
        if (maxValue !== undefined && instance.setMinValue(maxValue)) {
            updateFlag = true;
        }
        if (precision !== undefined && instance.setPrecision(precision)) {
            updateFlag = true;
        }
        if (shouldOhlc !== undefined && instance.setShouldOhlc(shouldOhlc)) {
            updateFlag = true;
        }
        if (shouldFormatBigNumber !== undefined && instance.setShouldFormatBigNumber(shouldFormatBigNumber)) {
            updateFlag = true;
        }
        if (styles !== undefined && instance.setStyles(styles)) {
            updateFlag = true;
        }
        if (extendData !== undefined && instance.setExtendData(extendData)) {
            updateFlag = true;
            calcFlag = true;
        }
        if (regenerateFigures !== undefined && instance.setRegenerateFigures(regenerateFigures)) {
            updateFlag = true;
        }
        if (createTooltipDataSource !== undefined && instance.setCreateTooltipDataSource(createTooltipDataSource)) {
            updateFlag = true;
        }
        if (draw !== undefined && instance.setDraw(draw)) {
            updateFlag = true;
        }
        if (calc !== undefined) {
            instance.calc = calc;
            calcFlag = true;
        }
        return [updateFlag, calcFlag];
    }
    async addInstance(indicator, paneId, isStack) {
        var _a;
        const { name } = indicator;
        let paneInstances = this._instances.get(paneId);
        if ((_a = paneInstances === null || paneInstances === void 0 ? void 0 : paneInstances.has(name)) !== null && _a !== void 0 ? _a : false) {
            return await Promise.reject(new Error('Duplicate indicators.'));
        }
        if (paneInstances === undefined) {
            paneInstances = new Map();
            this._instances.set(paneId, paneInstances);
        }
        const IndicatorClazz = getIndicatorClass(name);
        const instance = new IndicatorClazz();
        this._overrideInstance(instance, indicator);
        if (!isStack) {
            paneInstances.clear();
        }
        paneInstances.set(name, instance);
        return await instance.calcIndicator(this._chartStore.getDataList());
    }
    getInstances(paneId) {
        var _a;
        return (_a = this._instances.get(paneId)) !== null && _a !== void 0 ? _a : new Map();
    }
    removeInstance(paneId, name) {
        let removed = false;
        if (this._instances.has(paneId)) {
            const paneInstances = this._instances.get(paneId);
            if (name !== undefined) {
                if (paneInstances.has(name)) {
                    paneInstances.delete(name);
                    removed = true;
                }
            }
            else {
                paneInstances.clear();
                removed = true;
            }
            if (paneInstances.size === 0) {
                this._instances.delete(paneId);
            }
        }
        return removed;
    }
    hasInstances(paneId) {
        return this._instances.has(paneId);
    }
    async calcInstance(name, paneId) {
        var _a;
        const tasks = [];
        if (name !== undefined) {
            if (paneId !== undefined) {
                const paneInstances = this._instances.get(paneId);
                if ((_a = paneInstances === null || paneInstances === void 0 ? void 0 : paneInstances.has(name)) !== null && _a !== void 0 ? _a : false) {
                    const instance = paneInstances === null || paneInstances === void 0 ? void 0 : paneInstances.get(name);
                    tasks.push(instance.calcIndicator(this._chartStore.getDataList()));
                }
            }
            else {
                this._instances.forEach(paneInstances => {
                    if (paneInstances.has(name)) {
                        const instance = paneInstances === null || paneInstances === void 0 ? void 0 : paneInstances.get(name);
                        tasks.push(instance.calcIndicator(this._chartStore.getDataList()));
                    }
                });
            }
        }
        else {
            this._instances.forEach(paneInstances => {
                paneInstances.forEach(instance => {
                    tasks.push(instance.calcIndicator(this._chartStore.getDataList()));
                });
            });
        }
        return await Promise.all(tasks);
    }
    getInstanceByPaneId(paneId, name) {
        var _a;
        if (paneId !== undefined) {
            const paneInstances = this._instances.get(paneId);
            if (name !== undefined) {
                return (_a = paneInstances === null || paneInstances === void 0 ? void 0 : paneInstances.get(name)) !== null && _a !== void 0 ? _a : null;
            }
            return paneInstances !== null && paneInstances !== void 0 ? paneInstances : null;
        }
        return this._instances;
    }
    setSeriesPrecision(precision) {
        this._instances.forEach(paneInstances => {
            paneInstances.forEach(instance => {
                if (instance.series === "price" /* IndicatorSeries.PRICE */) {
                    instance.setPrecision(precision.price, true);
                }
                if (instance.series === "volume" /* IndicatorSeries.VOLUME */) {
                    instance.setPrecision(precision.volume, true);
                }
            });
        });
    }
    async override(indicator, paneId) {
        const { name } = indicator;
        let instances = new Map();
        if (paneId !== null) {
            if (this._instances.has(paneId)) {
                instances.set(paneId, this._instances.get(paneId));
            }
        }
        else {
            instances = this._instances;
        }
        const tasks = [];
        instances.forEach(paneInstances => {
            if (paneInstances.has(name)) {
                const instance = paneInstances.get(name);
                const overrideResult = this._overrideInstance(instance, indicator);
                if (overrideResult[1]) {
                    tasks.push(instance.calcIndicator(this._chartStore.getDataList()));
                }
            }
        });
        return await Promise.all(tasks);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CrosshairStore {
    constructor(chartStore) {
        this._crosshair = {};
        this._chartStore = chartStore;
    }
    /**
       * 设置十字光标点信息
       * @param crosshair
       * @param notInvalidate
       */
    set(crosshair, notInvalidate) {
        const dataList = this._chartStore.getDataList();
        const cr = crosshair !== null && crosshair !== void 0 ? crosshair : {};
        let realDataIndex;
        let dataIndex;
        if (cr.x !== undefined) {
            realDataIndex = this._chartStore.getTimeScaleStore().coordinateToDataIndex(cr.x);
            if (realDataIndex < 0) {
                dataIndex = 0;
            }
            else if (realDataIndex > dataList.length - 1) {
                dataIndex = dataList.length - 1;
            }
            else {
                dataIndex = realDataIndex;
            }
        }
        else {
            realDataIndex = dataList.length - 1;
            dataIndex = realDataIndex;
        }
        const kLineData = dataList[dataIndex];
        const realX = this._chartStore.getTimeScaleStore().dataIndexToCoordinate(realDataIndex);
        const prevCrosshair = { x: this._crosshair.x, y: this._crosshair.y, paneId: this._crosshair.paneId };
        this._crosshair = { ...cr, realX, kLineData, realDataIndex, dataIndex };
        if (prevCrosshair.x !== cr.x || prevCrosshair.y !== cr.y || prevCrosshair.paneId !== cr.paneId) {
            if (kLineData !== null) {
                this._chartStore.getChart().crosshairChange(this._crosshair);
            }
            if (!(notInvalidate !== null && notInvalidate !== void 0 ? notInvalidate : false)) {
                this._chartStore.getChart().updatePane(1 /* UpdateLevel.OVERLAY */);
            }
        }
        return this;
    }
    /**
     * 重新计算十字光标
     * @param notInvalidate
     */
    recalculate(notInvalidate) {
        this.set(this._crosshair, notInvalidate);
    }
    /**
     * 获取crosshair信息
     * @returns
     */
    get() {
        return this._crosshair;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OVERLAY_DRAW_STEP_START = 1;
const OVERLAY_DRAW_STEP_FINISHED = -1;
class OverlayImp {
    constructor(overlay) {
        this.currentStep = OVERLAY_DRAW_STEP_START;
        this.points = [];
        this._prevPressedPoint = null;
        this._prevPressedPoints = [];
        const { mode, extendData, styles, name, totalStep, lock, needDefaultPointFigure, needDefaultXAxisFigure, needDefaultYAxisFigure, createPointFigures, createXAxisFigures, createYAxisFigures, performEventPressedMove, performEventMoveForDrawing, onDrawStart, onDrawing, onDrawEnd, onClick, onRightClick, onPressedMoveStart, onPressedMoving, onPressedMoveEnd, onMouseEnter, onMouseLeave, onRemoved, onSelected, onDeselected } = overlay;
        this.name = name;
        this.totalStep = (totalStep === undefined || totalStep < 2) ? 1 : totalStep;
        this.lock = lock !== null && lock !== void 0 ? lock : false;
        this.needDefaultPointFigure = needDefaultPointFigure !== null && needDefaultPointFigure !== void 0 ? needDefaultPointFigure : false;
        this.needDefaultXAxisFigure = needDefaultXAxisFigure !== null && needDefaultXAxisFigure !== void 0 ? needDefaultXAxisFigure : false;
        this.needDefaultYAxisFigure = needDefaultYAxisFigure !== null && needDefaultYAxisFigure !== void 0 ? needDefaultYAxisFigure : false;
        this.mode = mode !== null && mode !== void 0 ? mode : "normal" /* OverlayMode.NORMAL */;
        this.extendData = extendData;
        this.styles = styles !== null && styles !== void 0 ? styles : null;
        this.createPointFigures = createPointFigures !== null && createPointFigures !== void 0 ? createPointFigures : null;
        this.createXAxisFigures = createXAxisFigures !== null && createXAxisFigures !== void 0 ? createXAxisFigures : null;
        this.createYAxisFigures = createYAxisFigures !== null && createYAxisFigures !== void 0 ? createYAxisFigures : null;
        this.performEventPressedMove = performEventPressedMove !== null && performEventPressedMove !== void 0 ? performEventPressedMove : null;
        this.performEventMoveForDrawing = performEventMoveForDrawing !== null && performEventMoveForDrawing !== void 0 ? performEventMoveForDrawing : null;
        this.onDrawStart = onDrawStart !== null && onDrawStart !== void 0 ? onDrawStart : null;
        this.onDrawing = onDrawing !== null && onDrawing !== void 0 ? onDrawing : null;
        this.onDrawEnd = onDrawEnd !== null && onDrawEnd !== void 0 ? onDrawEnd : null;
        this.onClick = onClick !== null && onClick !== void 0 ? onClick : null;
        this.onRightClick = onRightClick !== null && onRightClick !== void 0 ? onRightClick : null;
        this.onPressedMoveStart = onPressedMoveStart !== null && onPressedMoveStart !== void 0 ? onPressedMoveStart : null;
        this.onPressedMoving = onPressedMoving !== null && onPressedMoving !== void 0 ? onPressedMoving : null;
        this.onPressedMoveEnd = onPressedMoveEnd !== null && onPressedMoveEnd !== void 0 ? onPressedMoveEnd : null;
        this.onMouseEnter = onMouseEnter !== null && onMouseEnter !== void 0 ? onMouseEnter : null;
        this.onMouseLeave = onMouseLeave !== null && onMouseLeave !== void 0 ? onMouseLeave : null;
        this.onRemoved = onRemoved !== null && onRemoved !== void 0 ? onRemoved : null;
        this.onSelected = onSelected !== null && onSelected !== void 0 ? onSelected : null;
        this.onDeselected = onDeselected !== null && onDeselected !== void 0 ? onDeselected : null;
    }
    setId(id) {
        if (this.id === undefined) {
            this.id = id;
            return true;
        }
        return false;
    }
    setGroupId(groupId) {
        if (this.groupId === undefined) {
            this.groupId = groupId;
            return true;
        }
        return false;
    }
    setExtendData(extendData) {
        if (extendData !== this.extendData) {
            this.extendData = extendData;
            return true;
        }
        return false;
    }
    setStyles(styles) {
        if (styles !== this.styles) {
            this.styles = styles;
            return true;
        }
        return false;
    }
    setPoints(points) {
        if (points.length > 0) {
            let repeatTotalStep;
            this.points = [...points];
            if (points.length >= this.totalStep - 1) {
                this.currentStep = OVERLAY_DRAW_STEP_FINISHED;
                repeatTotalStep = this.totalStep - 1;
            }
            else {
                this.currentStep = points.length + 1;
                repeatTotalStep = points.length;
            }
            // Prevent wrong drawing due to wrong points
            if (this.performEventMoveForDrawing !== null) {
                for (let i = 0; i < repeatTotalStep; i++) {
                    this.performEventMoveForDrawing({
                        currentStep: i + 2,
                        mode: this.mode,
                        points: this.points,
                        performPointIndex: i,
                        performPoint: this.points[i]
                    });
                }
            }
            if (this.currentStep === OVERLAY_DRAW_STEP_FINISHED && this.performEventPressedMove !== null) {
                this.performEventPressedMove({
                    currentStep: this.currentStep,
                    mode: this.mode,
                    points: this.points,
                    performPointIndex: this.points.length - 1,
                    performPoint: this.points[this.points.length - 1]
                });
            }
            return true;
        }
        return false;
    }
    setLock(lock) {
        if (this.lock !== lock) {
            this.lock = lock;
            return true;
        }
        return false;
    }
    setMode(mode) {
        if (mode !== this.mode) {
            this.mode = mode;
            return true;
        }
        return false;
    }
    setOnDrawStartCallback(callback) {
        if (this.onDrawStart !== callback) {
            this.onDrawStart = callback;
            return true;
        }
        return false;
    }
    setOnDrawingCallback(callback) {
        if (this.onDrawing !== callback) {
            this.onDrawing = callback;
            return true;
        }
        return false;
    }
    setOnDrawEndCallback(callback) {
        if (this.onDrawEnd !== callback) {
            this.onDrawEnd = callback;
            return true;
        }
        return false;
    }
    setOnClickCallback(callback) {
        if (this.onClick !== callback) {
            this.onClick = callback;
            return true;
        }
        return false;
    }
    setOnRightClickCallback(callback) {
        if (this.onRightClick !== callback) {
            this.onRightClick = callback;
            return true;
        }
        return false;
    }
    setOnPressedMoveStartCallback(callback) {
        if (this.onPressedMoveStart !== callback) {
            this.onPressedMoveStart = callback;
            return true;
        }
        return false;
    }
    setOnPressedMovingCallback(callback) {
        if (this.onPressedMoving !== callback) {
            this.onPressedMoving = callback;
            return true;
        }
        return false;
    }
    setOnPressedMoveEndCallback(callback) {
        if (this.onPressedMoveEnd !== callback) {
            this.onPressedMoveEnd = callback;
            return true;
        }
        return false;
    }
    setOnMouseEnterCallback(callback) {
        if (this.onMouseEnter !== callback) {
            this.onMouseEnter = callback;
            return true;
        }
        return false;
    }
    setOnMouseLeaveCallback(callback) {
        if (this.onMouseLeave !== callback) {
            this.onMouseLeave = callback;
            return true;
        }
        return false;
    }
    setOnRemovedCallback(callback) {
        if (this.onRemoved !== callback) {
            this.onRemoved = callback;
            return true;
        }
        return false;
    }
    setOnSelectedCallback(callback) {
        if (this.onSelected !== callback) {
            this.onSelected = callback;
            return true;
        }
        return false;
    }
    setOnDeselectedCallback(callback) {
        if (this.onDeselected !== callback) {
            this.onDeselected = callback;
            return true;
        }
        return false;
    }
    nextStep() {
        if (this.currentStep === this.totalStep - 1) {
            this.currentStep = OVERLAY_DRAW_STEP_FINISHED;
        }
        else {
            this.currentStep++;
        }
    }
    isDrawing() {
        return this.currentStep !== OVERLAY_DRAW_STEP_FINISHED;
    }
    isStart() {
        return this.currentStep === OVERLAY_DRAW_STEP_START;
    }
    eventMoveForDrawing(point) {
        var _a;
        const pointIndex = this.currentStep - 1;
        const newPoint = {};
        if (point.timestamp !== undefined) {
            newPoint.timestamp = point.timestamp;
        }
        if (point.dataIndex !== undefined) {
            newPoint.dataIndex = point.dataIndex;
        }
        if (point.value !== undefined) {
            newPoint.value = point.value;
        }
        this.points[pointIndex] = newPoint;
        (_a = this.performEventMoveForDrawing) === null || _a === void 0 ? void 0 : _a.call(this, {
            currentStep: this.currentStep,
            mode: this.mode,
            points: this.points,
            performPointIndex: pointIndex,
            performPoint: newPoint
        });
    }
    eventPressedPointMove(point, pointIndex) {
        var _a;
        if (point.dataIndex !== undefined) {
            this.points[pointIndex].dataIndex = point.dataIndex;
            this.points[pointIndex].timestamp = point.timestamp;
        }
        if (point.value !== undefined) {
            this.points[pointIndex].value = point.value;
        }
        (_a = this.performEventPressedMove) === null || _a === void 0 ? void 0 : _a.call(this, {
            currentStep: this.currentStep,
            points: this.points,
            mode: this.mode,
            performPointIndex: pointIndex,
            performPoint: this.points[pointIndex]
        });
    }
    startPressedMove(point) {
        this._prevPressedPoint = { ...point };
        this._prevPressedPoints = clone(this.points);
    }
    eventPressedOtherMove(point, timeScaleStore) {
        if (this._prevPressedPoint !== null) {
            let difDataIndex;
            if (point.dataIndex !== undefined && this._prevPressedPoint.dataIndex !== undefined) {
                difDataIndex = point.dataIndex - this._prevPressedPoint.dataIndex;
            }
            let difValue;
            if (point.value !== undefined && this._prevPressedPoint.value !== undefined) {
                difValue = point.value - this._prevPressedPoint.value;
            }
            this.points = this._prevPressedPoints.map(p => {
                var _a;
                if (p.dataIndex === undefined && p.timestamp !== undefined) {
                    p.dataIndex = timeScaleStore.timestampToDataIndex(p.timestamp);
                }
                const newPoint = { ...p };
                if (difDataIndex !== undefined && p.dataIndex !== undefined) {
                    newPoint.dataIndex = p.dataIndex + difDataIndex;
                    newPoint.timestamp = (_a = timeScaleStore.dataIndexToTimestamp(newPoint.dataIndex)) !== null && _a !== void 0 ? _a : undefined;
                }
                if (difValue !== undefined && p.value !== undefined) {
                    newPoint.value = p.value + difValue;
                }
                return newPoint;
            });
        }
    }
    static extend(template) {
        class Custom extends OverlayImp {
            constructor() {
                super(template);
            }
        }
        return Custom;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fibonacciLine = {
    name: 'fibonacciLine',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding, overlay, precision }) => {
        const points = overlay.points;
        if (coordinates.length > 0) {
            const lines = [];
            const texts = [];
            const startX = 0;
            const endX = bounding.width;
            const value1 = points[1].value;
            if (coordinates.length > 1 && points[0].value !== undefined && value1 !== undefined) {
                const percents = [1, 0.786, 0.618, 0.5, 0.382, 0.236, 0];
                const yDif = coordinates[0].y - coordinates[1].y;
                const valueDif = points[0].value - value1;
                percents.forEach(percent => {
                    const y = coordinates[1].y + yDif * percent;
                    const value = (value1 + valueDif * percent).toFixed(precision.price);
                    lines.push({ coordinates: [{ x: startX, y }, { x: endX, y }] });
                    texts.push({
                        x: startX,
                        y,
                        text: `${value} (${(percent * 100).toFixed(1)}%)`,
                        baseline: 'bottom'
                    });
                });
            }
            return [
                {
                    type: 'line',
                    attrs: lines
                }, {
                    type: 'text',
                    isCheckEvent: false,
                    attrs: texts
                }
            ];
        }
        return [];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const horizontalRayLine = {
    name: 'horizontalRayLine',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        const coordinate = { x: 0, y: coordinates[0].y };
        if (coordinates[1] !== undefined && coordinates[0].x < coordinates[1].x) {
            coordinate.x = bounding.width;
        }
        return [
            {
                type: 'line',
                attrs: { coordinates: [coordinates[0], coordinate] }
            }
        ];
    },
    performEventPressedMove: ({ points, performPoint }) => {
        points[0].value = performPoint.value;
        points[1].value = performPoint.value;
    },
    performEventMoveForDrawing: ({ currentStep, points, performPoint }) => {
        if (currentStep === 2) {
            points[0].value = performPoint.value;
        }
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const horizontalSegment = {
    name: 'horizontalSegment',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates }) => {
        const lines = [];
        if (coordinates.length === 2) {
            lines.push({ coordinates });
        }
        return [
            {
                type: 'line',
                attrs: lines
            }
        ];
    },
    performEventPressedMove: ({ points, performPoint }) => {
        points[0].value = performPoint.value;
        points[1].value = performPoint.value;
    },
    performEventMoveForDrawing: ({ currentStep, points, performPoint }) => {
        if (currentStep === 2) {
            points[0].value = performPoint.value;
        }
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const horizontalStraightLine = {
    name: 'horizontalStraightLine',
    totalStep: 2,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        return [{
                type: 'line',
                attrs: {
                    coordinates: [
                        {
                            x: 0,
                            y: coordinates[0].y
                        }, {
                            x: bounding.width,
                            y: coordinates[0].y
                        }
                    ]
                }
            }];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getDistance$1(coordinate1, coordinate2) {
    return Math.sqrt(Math.pow(coordinate1.x + coordinate2.x, 2) + Math.pow(coordinate1.y + coordinate2.y, 2));
}
function getSmoothControlCoordinate(coordinates) {
    const d01 = getDistance$1(coordinates[0], coordinates[1]);
    const d12 = getDistance$1(coordinates[1], coordinates[2]);
    const d02 = d01 + d12;
    const vector = [coordinates[2].x - coordinates[0].x, coordinates[2].y - coordinates[0].y];
    return [
        {
            x: coordinates[1].x - vector[0] * 0.5 * d01 / d02,
            y: coordinates[1].y - vector[1] * 0.5 * d01 / d02
        }, {
            x: coordinates[1].x + vector[0] * 0.5 * d01 / d02,
            y: coordinates[1].y + vector[1] * 0.5 * d01 / d02
        }
    ];
}
function checkCoordinateOnLine(coordinate, line) {
    let on = false;
    const coordinates = line.coordinates;
    if (coordinates.length > 1) {
        for (let i = 1; i < coordinates.length; i++) {
            const prevCoordinate = coordinates[i - 1];
            const currentCoordinate = coordinates[i];
            if (prevCoordinate.x === currentCoordinate.x) {
                on = Math.abs(coordinate.x - prevCoordinate.x) < 2;
            }
            else {
                const kb = getLinearSlopeIntercept(prevCoordinate, currentCoordinate);
                const y = getLinearYFromSlopeIntercept(kb, coordinate);
                const yDif = Math.abs(y - coordinate.y);
                on = yDif * yDif / (kb[0] * kb[0] + 1) < 2 * 2;
            }
            if (on) {
                return on;
            }
        }
    }
    return on;
}
function getLinearYFromSlopeIntercept(kb, coordinate) {
    if (kb != null) {
        return coordinate.x * kb[0] + kb[1];
    }
    return coordinate.y;
}
/**
 * 获取点在两点决定的一次函数上的y值
 * @param coordinate1
 * @param coordinate2
 * @param targetCoordinate
 */
function getLinearYFromCoordinates(coordinate1, coordinate2, targetCoordinate) {
    const kb = getLinearSlopeIntercept(coordinate1, coordinate2);
    return getLinearYFromSlopeIntercept(kb, targetCoordinate);
}
function getLinearSlopeIntercept(coordinate1, coordinate2) {
    const difX = coordinate1.x - coordinate2.x;
    if (difX !== 0) {
        const k = (coordinate1.y - coordinate2.y) / difX;
        const b = coordinate1.y - k * coordinate1.x;
        return [k, b];
    }
    return null;
}
function drawLine(ctx, attrs, styles) {
    const { coordinates } = attrs;
    const length = coordinates.length;
    if (length > 1) {
        const { style = "solid" /* LineType.SOLID */, smooth, size = 1, color = 'currentColor', dashedValue = [2, 2] } = styles;
        ctx.lineWidth = size;
        ctx.strokeStyle = color;
        if (style === "dashed" /* LineType.DASHED */) {
            ctx.setLineDash(dashedValue);
        }
        else {
            ctx.setLineDash([]);
        }
        ctx.beginPath();
        ctx.moveTo(coordinates[0].x, coordinates[0].y);
        if (smooth !== null && smooth !== void 0 ? smooth : false) {
            let controlCoordinates = [];
            for (let i = 1; i < length - 1; i++) {
                controlCoordinates = controlCoordinates.concat(getSmoothControlCoordinate([coordinates[i - 1], coordinates[i], coordinates[i + 1]]));
            }
            ctx.quadraticCurveTo(controlCoordinates[0].x, controlCoordinates[0].y, coordinates[1].x, coordinates[1].y);
            let i = 2;
            for (; i < length - 1; i++) {
                ctx.bezierCurveTo(controlCoordinates[(i - 2) * 2 + 1].x, controlCoordinates[(i - 2) * 2 + 1].y, controlCoordinates[(i - 1) * 2].x, controlCoordinates[(i - 1) * 2].y, coordinates[i].x, coordinates[i].y);
            }
            ctx.quadraticCurveTo(controlCoordinates[(i - 2) * 2 + 1].x, controlCoordinates[(i - 2) * 2 + 1].y, coordinates[i].x, coordinates[i].y);
        }
        else {
            for (let i = 1; i < coordinates.length; i++) {
                ctx.lineTo(coordinates[i].x, coordinates[i].y);
            }
        }
        ctx.stroke();
        ctx.closePath();
    }
}
const line = {
    name: 'line',
    checkEventOn: checkCoordinateOnLine,
    draw: (ctx, attrs, styles) => {
        drawLine(ctx, attrs, styles);
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * 获取平行线
 * @param coordinates
 * @param bounding
 * @param extendParallelLineCount
 * @returns {Array}
 */
function getParallelLines(coordinates, bounding, extendParallelLineCount) {
    const count = extendParallelLineCount !== null && extendParallelLineCount !== void 0 ? extendParallelLineCount : 0;
    const lines = [];
    if (coordinates.length > 1) {
        if (coordinates[0].x === coordinates[1].x) {
            const startY = 0;
            const endY = bounding.height;
            lines.push({ coordinates: [{ x: coordinates[0].x, y: startY }, { x: coordinates[0].x, y: endY }] });
            if (coordinates.length > 2) {
                lines.push({ coordinates: [{ x: coordinates[2].x, y: startY }, { x: coordinates[2].x, y: endY }] });
                const distance = coordinates[0].x - coordinates[2].x;
                for (let i = 0; i < count; i++) {
                    const d = distance * (i + 1);
                    lines.push({ coordinates: [{ x: coordinates[0].x + d, y: startY }, { x: coordinates[0].x + d, y: endY }] });
                }
            }
        }
        else {
            const startX = 0;
            const endX = bounding.width;
            const kb = getLinearSlopeIntercept(coordinates[0], coordinates[1]);
            const k = kb[0];
            const b = kb[1];
            lines.push({ coordinates: [{ x: startX, y: startX * k + b }, { x: endX, y: endX * k + b }] });
            if (coordinates.length > 2) {
                const b1 = coordinates[2].y - k * coordinates[2].x;
                lines.push({ coordinates: [{ x: startX, y: startX * k + b1 }, { x: endX, y: endX * k + b1 }] });
                const distance = b - b1;
                for (let i = 0; i < count; i++) {
                    const b2 = b + distance * (i + 1);
                    lines.push({ coordinates: [{ x: startX, y: startX * k + b2 }, { x: endX, y: endX * k + b2 }] });
                }
            }
        }
    }
    return lines;
}
const parallelStraightLine = {
    name: 'parallelStraightLine',
    totalStep: 4,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        return [
            {
                type: 'line',
                attrs: getParallelLines(coordinates, bounding)
            }
        ];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const priceChannelLine = {
    name: 'priceChannelLine',
    totalStep: 4,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        return [
            {
                type: 'line',
                attrs: getParallelLines(coordinates, bounding, 1)
            }
        ];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const priceLine = {
    name: 'priceLine',
    totalStep: 2,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding, precision, overlay }) => {
        const { value = 0 } = (overlay.points)[0];
        return [
            {
                type: 'line',
                attrs: { coordinates: [coordinates[0], { x: bounding.width, y: coordinates[0].y }] }
            },
            {
                type: 'text',
                isCheck: false,
                attrs: { x: coordinates[0].x, y: coordinates[0].y, text: value.toFixed(precision.price), baseline: 'bottom' }
            }
        ];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getRayLine(coordinates, bounding) {
    if (coordinates.length > 1) {
        let coordinate;
        if (coordinates[0].x === coordinates[1].x && coordinates[0].y !== coordinates[1].y) {
            if (coordinates[0].y < coordinates[1].y) {
                coordinate = {
                    x: coordinates[0].x,
                    y: bounding.height
                };
            }
            else {
                coordinate = {
                    x: coordinates[0].x,
                    y: 0
                };
            }
        }
        else if (coordinates[0].x > coordinates[1].x) {
            coordinate = {
                x: 0,
                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: 0, y: coordinates[0].y })
            };
        }
        else {
            coordinate = {
                x: bounding.width,
                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: bounding.width, y: coordinates[0].y })
            };
        }
        return { coordinates: [coordinates[0], coordinate] };
    }
    return [];
}
const rayLine = {
    name: 'rayLine',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        return [
            {
                type: 'line',
                attrs: getRayLine(coordinates, bounding)
            }
        ];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const segment = {
    name: 'segment',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates }) => {
        if (coordinates.length === 2) {
            return [
                {
                    type: 'line',
                    attrs: { coordinates }
                }
            ];
        }
        return [];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const straightLine = {
    name: 'straightLine',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        if (coordinates.length === 2) {
            if (coordinates[0].x === coordinates[1].x) {
                return [
                    {
                        type: 'line',
                        attrs: {
                            coordinates: [
                                {
                                    x: coordinates[0].x,
                                    y: 0
                                }, {
                                    x: coordinates[0].x,
                                    y: bounding.height
                                }
                            ]
                        }
                    }
                ];
            }
            return [
                {
                    type: 'line',
                    attrs: {
                        coordinates: [
                            {
                                x: 0,
                                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: 0, y: coordinates[0].y })
                            }, {
                                x: bounding.width,
                                y: getLinearYFromCoordinates(coordinates[0], coordinates[1], { x: bounding.width, y: coordinates[0].y })
                            }
                        ]
                    }
                }
            ];
        }
        return [];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const verticalRayLine = {
    name: 'verticalRayLine',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        if (coordinates.length === 2) {
            const coordinate = { x: coordinates[0].x, y: 0 };
            if (coordinates[0].y < coordinates[1].y) {
                coordinate.y = bounding.height;
            }
            return [
                {
                    type: 'line',
                    attrs: { coordinates: [coordinates[0], coordinate] }
                }
            ];
        }
        return [];
    },
    performEventPressedMove: ({ points, performPoint }) => {
        points[0].timestamp = performPoint.timestamp;
        points[0].dataIndex = performPoint.dataIndex;
        points[1].timestamp = performPoint.timestamp;
        points[1].dataIndex = performPoint.dataIndex;
    },
    performEventMoveForDrawing: ({ currentStep, points, performPoint }) => {
        if (currentStep === 2) {
            points[0].timestamp = performPoint.timestamp;
            points[0].dataIndex = performPoint.dataIndex;
        }
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const verticalSegment = {
    name: 'verticalSegment',
    totalStep: 3,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates }) => {
        if (coordinates.length === 2) {
            return [
                {
                    type: 'line',
                    attrs: { coordinates }
                }
            ];
        }
        return [];
    },
    performEventPressedMove: ({ points, performPoint }) => {
        points[0].timestamp = performPoint.timestamp;
        points[0].dataIndex = performPoint.dataIndex;
        points[1].timestamp = performPoint.timestamp;
        points[1].dataIndex = performPoint.dataIndex;
    },
    performEventMoveForDrawing: ({ currentStep, points, performPoint }) => {
        if (currentStep === 2) {
            points[0].timestamp = performPoint.timestamp;
            points[0].dataIndex = performPoint.dataIndex;
        }
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const verticalStraightLine = {
    name: 'verticalStraightLine',
    totalStep: 2,
    needDefaultPointFigure: true,
    needDefaultXAxisFigure: true,
    needDefaultYAxisFigure: true,
    createPointFigures: ({ coordinates, bounding }) => {
        return [
            {
                type: 'line',
                attrs: {
                    coordinates: [
                        {
                            x: coordinates[0].x,
                            y: 0
                        }, {
                            x: coordinates[0].x,
                            y: bounding.height
                        }
                    ]
                }
            }
        ];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const simpleAnnotation = {
    name: 'simpleAnnotation',
    createPointFigures: ({ overlay, coordinates }) => {
        var _a;
        let text;
        if (isValid(overlay.extendData)) {
            if (!isFunction(overlay.extendData)) {
                text = (_a = overlay.extendData) !== null && _a !== void 0 ? _a : '';
            }
            else {
                text = overlay.extendData(overlay);
            }
        }
        const startX = coordinates[0].x;
        const startY = coordinates[0].y - 6;
        const lineEndY = startY - 50;
        const arrowEndY = lineEndY - 5;
        return [
            {
                type: 'line',
                attrs: { coordinates: [{ x: startX, y: startY }, { x: startX, y: lineEndY }] },
                ignoreEvent: true
            },
            {
                type: 'polygon',
                attrs: { coordinates: [{ x: startX, y: lineEndY }, { x: startX - 4, y: arrowEndY }, { x: startX + 4, y: arrowEndY }] },
                ignoreEvent: true
            },
            {
                type: 'rectText',
                attrs: { x: startX, y: arrowEndY, text: text !== null && text !== void 0 ? text : '', align: 'center', baseline: 'bottom' },
                ignoreEvent: true
            }
        ];
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const simpleTag = {
    name: 'simpleTag',
    createPointFigures: ({ bounding, coordinates }) => {
        return {
            type: 'line',
            attrs: {
                coordinates: [
                    { x: 0, y: coordinates[0].y },
                    { x: bounding.width, y: coordinates[0].y }
                ]
            },
            ignoreEvent: true
        };
    },
    createYAxisFigures: ({ overlay, coordinates, bounding, yAxis, precision }) => {
        var _a, _b;
        const isFromZero = (_a = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isFromZero()) !== null && _a !== void 0 ? _a : false;
        let textAlign;
        let x;
        if (isFromZero) {
            textAlign = 'left';
            x = 0;
        }
        else {
            textAlign = 'right';
            x = bounding.width;
        }
        let text;
        if (isValid(overlay.extendData)) {
            if (!isFunction(overlay.extendData)) {
                text = (_b = overlay.extendData) !== null && _b !== void 0 ? _b : '';
            }
            else {
                text = overlay.extendData(overlay);
            }
        }
        if (!isValid(text) && overlay.points[0].value !== undefined) {
            text = formatPrecision(overlay.points[0].value, precision.price);
        }
        return { type: 'rectText', attrs: { x, y: coordinates[0].y, text: text !== null && text !== void 0 ? text : '', align: textAlign, baseline: 'middle' } };
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const overlays = {};
const extensions$1 = [
    fibonacciLine, horizontalRayLine, horizontalSegment, horizontalStraightLine,
    parallelStraightLine, priceChannelLine, priceLine, rayLine, segment,
    straightLine, verticalRayLine, verticalSegment, verticalStraightLine,
    simpleAnnotation, simpleTag
];
extensions$1.forEach((template) => {
    overlays[template.name] = OverlayImp.extend(template);
});
function registerOverlay(template) {
    overlays[template.name] = OverlayImp.extend(template);
}
function getOverlayClass(name) {
    var _a;
    return (_a = overlays[name]) !== null && _a !== void 0 ? _a : null;
}
function getSupportedOverlays() {
    return Object.keys(overlays);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getDefaultBounding(bounding) {
    const defaultBounding = {
        width: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        bottom: 0
    };
    if (bounding !== undefined) {
        merge(defaultBounding, bounding);
    }
    return defaultBounding;
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Eventful {
    constructor() {
        this._children = [];
        this._callbacks = new Map();
    }
    registerEvent(name, callback) {
        this._callbacks.set(name, callback);
        return this;
    }
    onEvent(name, event, other) {
        const callback = this._callbacks.get(name);
        if (callback !== undefined && this.checkEventOn(event)) {
            return callback(event, other);
        }
        return false;
    }
    checkEventOn(event) {
        for (const eventful of this._children) {
            if (eventful.checkEventOn(event)) {
                return true;
            }
        }
        return false;
    }
    dispatchEvent(name, event, other) {
        const start = this._children.length - 1;
        if (start > -1) {
            for (let i = start; i > -1; i--) {
                if (this._children[i].dispatchEvent(name, event, other)) {
                    return true;
                }
            }
        }
        return this.onEvent(name, event, other);
    }
    addChild(eventful) {
        this._children.push(eventful);
        return this;
    }
    clear() {
        this._children = [];
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WidgetNameConstants = {
    MAIN: 'main',
    XAXIS: 'xAxis',
    YAXIS: 'yAxis',
    SEPARATOR: 'separator'
};
class Widget extends Eventful {
    constructor(rootContainer, pane) {
        super();
        this._bounding = getDefaultBounding();
        this._pane = pane;
        this._init(rootContainer);
    }
    _init(rootContainer) {
        this._container = createDom('div', this.getContainerStyle());
        if (this.insertBefore()) {
            const lastElement = rootContainer.lastChild;
            if (lastElement !== null) {
                rootContainer.insertBefore(this._container, lastElement);
            }
            else {
                rootContainer.appendChild(this._container);
            }
        }
        else {
            rootContainer.appendChild(this._container);
        }
        this.initDom(this._container);
    }
    setBounding(bounding) {
        merge(this._bounding, bounding);
        return this;
    }
    getContainer() { return this._container; }
    getBounding() {
        return this._bounding;
    }
    getPane() {
        return this._pane;
    }
    update(level) {
        this.updateImp(level, this._container, this._bounding);
    }
    insertBefore() { return false; }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function throttle(func, wait) {
    let previous = 0;
    return function () {
        const now = Date.now();
        if (now - previous > (wait !== null && wait !== void 0 ? wait : 20)) {
            func.apply(this, arguments);
            previous = now;
        }
    };
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const REAL_SEPARATOR_HEIGHT = 7;
class SeparatorWidget extends Widget {
    constructor(rootContainer, pane) {
        super(rootContainer, pane);
        this._dragFlag = false;
        this._dragStartY = 0;
        this._topPaneHeight = 0;
        this._currentPaneHeight = 0;
        this._pressedMouseMoveEvent = throttle(this._pressedTouchMouseMoveEvent, 20);
        this.registerEvent('touchStartEvent', this._mouseDownEvent.bind(this))
            .registerEvent('touchMoveEvent', this._pressedMouseMoveEvent.bind(this))
            .registerEvent('touchEndEvent', this._mouseUpEvent.bind(this))
            .registerEvent('mouseDownEvent', this._mouseDownEvent.bind(this))
            .registerEvent('mouseUpEvent', this._mouseUpEvent.bind(this))
            .registerEvent('pressedMouseMoveEvent', this._pressedMouseMoveEvent.bind(this))
            .registerEvent('mouseEnterEvent', this._mouseEnterEvent.bind(this))
            .registerEvent('mouseLeaveEvent', this._mouseLeaveEvent.bind(this));
    }
    getName() {
        return WidgetNameConstants.SEPARATOR;
    }
    checkEventOn() {
        return true;
    }
    _mouseDownEvent(event) {
        var _a, _b;
        this._dragFlag = true;
        this._dragStartY = event.pageY;
        const pane = this.getPane();
        this._topPaneHeight = (_b = (_a = pane.getTopPane()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
        this._currentPaneHeight = pane.getBounding().height;
        return true;
    }
    _mouseUpEvent() {
        this._dragFlag = false;
        return this._mouseLeaveEvent();
    }
    _pressedTouchMouseMoveEvent(event) {
        const dragDistance = event.pageY - this._dragStartY;
        const currentPane = this.getPane();
        const topPane = currentPane.getTopPane();
        const isUpDrag = dragDistance < 0;
        if (topPane !== null && currentPane.getOptions().dragEnabled) {
            let reducedPane;
            let increasedPane;
            let startDragReducedPaneHeight;
            let startDragIncreasedPaneHeight;
            if (isUpDrag) {
                reducedPane = topPane;
                increasedPane = currentPane;
                startDragReducedPaneHeight = this._topPaneHeight;
                startDragIncreasedPaneHeight = this._currentPaneHeight;
            }
            else {
                reducedPane = currentPane;
                increasedPane = topPane;
                startDragReducedPaneHeight = this._currentPaneHeight;
                startDragIncreasedPaneHeight = this._topPaneHeight;
            }
            const reducedPaneMinHeight = reducedPane.getOptions().minHeight;
            if (startDragReducedPaneHeight > reducedPaneMinHeight) {
                const reducedPaneHeight = Math.max(startDragReducedPaneHeight - Math.abs(dragDistance), reducedPaneMinHeight);
                const diffHeight = startDragReducedPaneHeight - reducedPaneHeight;
                reducedPane.setBounding({ height: reducedPaneHeight });
                increasedPane.setBounding({ height: startDragIncreasedPaneHeight + diffHeight });
                const chart = currentPane.getChart();
                chart.getChartStore().getActionStore().execute("onPaneDrag" /* ActionType.onPaneDrag */, { paneId: currentPane.getId });
                chart.adjustPaneViewport(true, true, true, true, true);
            }
        }
        return true;
    }
    _mouseEnterEvent() {
        const pane = this.getPane();
        if (pane.getOptions().dragEnabled) {
            const chart = pane.getChart();
            const styles = chart.getStyles().separator;
            this._moveDom.style.background = styles.activeBackgroundColor;
            const chartStore = chart.getChartStore();
            chartStore.setDragPaneFlag(true);
            chartStore.getCrosshairStore().set();
            return true;
        }
        return false;
    }
    _mouseLeaveEvent() {
        if (!this._dragFlag) {
            this._moveDom.style.background = '';
            this.getPane().getChart().getChartStore().setDragPaneFlag(false);
            return true;
        }
        return false;
    }
    getContainerStyle() {
        return {
            margin: '0',
            padding: '0',
            position: 'relative',
            boxSizing: 'border-box'
        };
    }
    insertBefore() { return true; }
    initDom(container) {
        this._moveDom = createDom('div', {
            width: '100%',
            height: `${REAL_SEPARATOR_HEIGHT}px`,
            margin: '0',
            padding: '0',
            position: 'absolute',
            top: '-3px',
            zIndex: '20',
            boxSizing: 'border-box',
            cursor: 'ns-resize'
        });
        container.appendChild(this._moveDom);
    }
    updateImp(level, container, bounding) {
        if (level === 4 /* UpdateLevel.ALL */ || level === 2 /* UpdateLevel.SEPARATOR */) {
            const styles = this.getPane().getChart().getStyles().separator;
            this._moveDom.style.top = `${-Math.floor((REAL_SEPARATOR_HEIGHT - styles.size) / 2)}px`;
            this._moveDom.style.height = `${REAL_SEPARATOR_HEIGHT}px`;
            const fill = styles.fill;
            container.style.backgroundColor = styles.color;
            container.style.height = `${styles.size}px`;
            container.style.marginLeft = `${fill ? 0 : bounding.left}px`;
            container.style.width = fill ? '100%' : `${bounding.width}px`;
        }
    }
    getImage() {
        const styles = this.getPane().getChart().getStyles().separator;
        const width = this.getContainer().offsetWidth;
        const height = styles.size;
        const canvas = createDom('canvas', {
            width: `${width}px`,
            height: `${height}px`,
            boxSizing: 'border-box'
        });
        const ctx = canvas.getContext('2d');
        const pixelRatio = getPixelRatio(canvas);
        canvas.width = width * pixelRatio;
        canvas.height = height * pixelRatio;
        ctx.scale(pixelRatio, pixelRatio);
        ctx.fillStyle = styles.color;
        ctx.fillRect(this.getBounding().left, 0, width, height);
        return canvas;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PANE_MIN_HEIGHT = 30;
const PANE_DEFAULT_HEIGHT = 100;
const PaneIdConstants = {
    CANDLE: 'candle_pane',
    INDICATOR: 'indcator_pane_',
    XAXIS: 'xaxis_pane'
};
class Pane {
    constructor(rootContainer, chart, id, topPane, bottomPane) {
        this._yAxisWidget = null;
        this._separatorWidget = null;
        this._axis = this.createAxisComponent();
        this._bounding = getDefaultBounding();
        this._options = { minHeight: PANE_MIN_HEIGHT, dragEnabled: true, gap: { top: 0.2, bottom: 0.1 } };
        this._chart = chart;
        this._id = id;
        this._topPane = topPane !== null && topPane !== void 0 ? topPane : null;
        this._bottomPane = bottomPane !== null && bottomPane !== void 0 ? bottomPane : null;
        this._init(rootContainer);
    }
    _init(rootContainer) {
        this._container = rootContainer;
        this._seriesContiainer = createDom('div', {
            width: '100%',
            margin: '0',
            padding: '0',
            position: 'relative',
            overflow: 'hidden',
            boxSizing: 'border-box'
        });
        this._separatorWidget = this.createSeparatorWidget(rootContainer);
        const lastElement = rootContainer.lastChild;
        if (lastElement !== null) {
            rootContainer.insertBefore(this._seriesContiainer, lastElement);
        }
        else {
            rootContainer.appendChild(this._seriesContiainer);
        }
        this._mainWidget = this.createMainWidget(this._seriesContiainer);
        this._yAxisWidget = this.creatYAxisWidget(this._seriesContiainer);
    }
    getContainer() {
        return this._seriesContiainer;
    }
    getId() {
        return this._id;
    }
    setOptions(options) {
        merge(this._options, options);
        return this;
    }
    getOptions() { return this._options; }
    getChart() {
        return this._chart;
    }
    getAxisComponent() {
        return this._axis;
    }
    setBounding(rootBounding, mainBounding, yAxisBounding) {
        var _a, _b, _c;
        merge(this._bounding, rootBounding);
        let separatorSize = 0;
        if (this._separatorWidget !== null) {
            separatorSize = this._chart.getStyles().separator.size;
            const separatorBounding = { ...rootBounding, height: REAL_SEPARATOR_HEIGHT };
            if (rootBounding.top !== undefined) {
                separatorBounding.top = rootBounding.top - Math.floor((REAL_SEPARATOR_HEIGHT - separatorSize) / 2);
            }
            this._separatorWidget.setBounding(separatorBounding);
        }
        const contentBounding = {};
        if (rootBounding.height !== undefined) {
            contentBounding.height = rootBounding.height - separatorSize;
        }
        if (rootBounding.top !== undefined) {
            contentBounding.top = rootBounding.top + separatorSize;
        }
        this._mainWidget.setBounding(contentBounding);
        (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.setBounding(contentBounding);
        if (mainBounding !== undefined) {
            this._mainWidget.setBounding(mainBounding);
            (_b = this._separatorWidget) === null || _b === void 0 ? void 0 : _b.setBounding(mainBounding);
        }
        if (yAxisBounding !== undefined) {
            (_c = this._yAxisWidget) === null || _c === void 0 ? void 0 : _c.setBounding(yAxisBounding);
        }
        return this;
    }
    getTopPane() {
        return this._topPane;
    }
    setTopPane(pane) {
        this._topPane = pane;
        return this;
    }
    getBottomPane() {
        return this._bottomPane;
    }
    setBottomPane(pane) {
        this._bottomPane = pane;
        return this;
    }
    getBounding() {
        return this._bounding;
    }
    getMainWidget() { return this._mainWidget; }
    getYAxisWidget() { return this._yAxisWidget; }
    getSeparatorWidget() { return this._separatorWidget; }
    update(level) {
        var _a, _b;
        if (this._bounding.width !== this._seriesContiainer.offsetWidth) {
            this._seriesContiainer.style.width = `${this._bounding.width}px`;
        }
        const seriesHeight = this._mainWidget.getBounding().height;
        if (seriesHeight !== this._seriesContiainer.offsetHeight) {
            this._seriesContiainer.style.height = `${seriesHeight}px`;
        }
        const l = level !== null && level !== void 0 ? level : 3 /* UpdateLevel.DRAWER */;
        this._mainWidget.update(l);
        (_a = this._yAxisWidget) === null || _a === void 0 ? void 0 : _a.update(l);
        (_b = this._separatorWidget) === null || _b === void 0 ? void 0 : _b.update(l);
    }
    getImage(includeOverlay) {
        const { width, height } = this._bounding;
        const canvas = createDom('canvas', {
            width: `${width}px`,
            height: `${height}px`,
            boxSizing: 'border-box'
        });
        const ctx = canvas.getContext('2d');
        const pixelRatio = getPixelRatio(canvas);
        canvas.width = width * pixelRatio;
        canvas.height = height * pixelRatio;
        ctx.scale(pixelRatio, pixelRatio);
        let top = 0;
        if (this._separatorWidget != null) {
            const separatorHeight = this.getChart().getStyles().separator.size;
            top = separatorHeight;
            ctx.drawImage(this._separatorWidget.getImage(), 0, 0, width, separatorHeight);
        }
        const mainBounding = this._mainWidget.getBounding();
        ctx.drawImage(this._mainWidget.getImage(includeOverlay), mainBounding.left, top, mainBounding.width, mainBounding.height);
        if (this._yAxisWidget !== null) {
            const yAxisBounding = this._yAxisWidget.getBounding();
            ctx.drawImage(this._yAxisWidget.getImage(includeOverlay), yAxisBounding.left, top, yAxisBounding.width, yAxisBounding.height);
        }
        return canvas;
    }
    destroy() {
        this._container.removeChild(this._seriesContiainer);
        if (this._separatorWidget !== null) {
            this._container.removeChild(this._separatorWidget.getContainer());
        }
    }
    createSeparatorWidget(container) { return null; }
    creatYAxisWidget(container) { return null; }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const OVERLAY_ID_PREFIX = 'overlay_';
class OverlayStore {
    constructor(chartStore) {
        this._instances = new Map();
        /**
         * Overlay information in painting
         */
        this._progressInstanceInfo = null;
        /**
         * Overlay information by the mouse pressed
         */
        this._pressedInstanceInfo = {
            paneId: '',
            instance: null,
            figureType: "none" /* EventOverlayInfoFigureType.NONE */,
            figureIndex: -1,
            attrsIndex: -1
        };
        /**
         * Overlay information by hover
         */
        this._hoverInstanceInfo = {
            paneId: '',
            instance: null,
            figureType: "none" /* EventOverlayInfoFigureType.NONE */,
            figureIndex: -1,
            attrsIndex: -1
        };
        /**
         * Overlay information by the mouse click
         */
        this._clickInstanceInfo = {
            paneId: '',
            instance: null,
            figureType: "none" /* EventOverlayInfoFigureType.NONE */,
            figureIndex: -1,
            attrsIndex: -1
        };
        this._chartStore = chartStore;
    }
    _overrideInstance(instance, overlay) {
        const { id, groupId, points, styles, lock, mode, extendData, onDrawStart, onDrawing, onDrawEnd, onClick, onRightClick, onPressedMoveStart, onPressedMoving, onPressedMoveEnd, onMouseEnter, onMouseLeave, onRemoved, onSelected, onDeselected } = overlay;
        let updateFlag = false;
        if (id !== undefined) {
            instance.setId(id);
        }
        if (groupId !== undefined) {
            instance.setGroupId(groupId);
        }
        if (points !== undefined && instance.setPoints(points)) {
            updateFlag = true;
        }
        if (styles !== undefined && instance.setStyles(styles)) {
            updateFlag = true;
        }
        if (lock !== undefined) {
            instance.setLock(lock);
        }
        if (mode !== undefined) {
            instance.setMode(mode);
        }
        if (extendData !== undefined && instance.setExtendData(extendData)) {
            updateFlag = true;
        }
        if (onDrawStart !== undefined) {
            instance.setOnDrawStartCallback(onDrawStart);
        }
        if (onDrawing !== undefined) {
            instance.setOnDrawingCallback(onDrawing);
        }
        if (onDrawEnd !== undefined) {
            instance.setOnDrawEndCallback(onDrawEnd);
        }
        if (onClick !== undefined) {
            instance.setOnClickCallback(onClick);
        }
        if (onRightClick !== undefined) {
            instance.setOnRightClickCallback(onRightClick);
        }
        if (onPressedMoveStart !== undefined) {
            instance.setOnPressedMoveStartCallback(onPressedMoveStart);
        }
        if (onPressedMoving !== undefined) {
            instance.setOnPressedMovingCallback(onPressedMoving);
        }
        if (onPressedMoveEnd !== undefined) {
            instance.setOnPressedMoveEndCallback(onPressedMoveEnd);
        }
        if (onMouseEnter !== undefined) {
            instance.setOnMouseEnterCallback(onMouseEnter);
        }
        if (onMouseLeave !== undefined) {
            instance.setOnMouseLeaveCallback(onMouseLeave);
        }
        if (onRemoved !== undefined) {
            instance.setOnRemovedCallback(onRemoved);
        }
        if (onSelected !== undefined) {
            instance.setOnSelectedCallback(onSelected);
        }
        if (onDeselected !== undefined) {
            instance.setOnDeselectedCallback(onDeselected);
        }
        return updateFlag;
    }
    getInstanceById(id) {
        for (const entry of this._instances) {
            const paneShapes = entry[1];
            const shape = paneShapes.find(s => s.id === id);
            if (shape !== undefined) {
                return shape;
            }
        }
        if (this._progressInstanceInfo !== null) {
            if (this._progressInstanceInfo.instance.id === id) {
                return this._progressInstanceInfo.instance;
            }
        }
        return null;
    }
    addInstance(overlay, paneId, appointPaneFlag) {
        var _a, _b, _c, _d;
        const id = (_a = overlay.id) !== null && _a !== void 0 ? _a : createId(OVERLAY_ID_PREFIX);
        if (this.getInstanceById(id) === null) {
            const OverlayClazz = getOverlayClass(overlay.name);
            const instance = new OverlayClazz();
            const groupId = (_b = overlay.groupId) !== null && _b !== void 0 ? _b : id;
            overlay.id = id;
            overlay.groupId = groupId;
            this._overrideInstance(instance, overlay);
            if (instance.isDrawing()) {
                this._progressInstanceInfo = { paneId, instance, appointPaneFlag };
            }
            else {
                if (!this._instances.has(paneId)) {
                    this._instances.set(paneId, []);
                }
                (_c = this._instances.get(paneId)) === null || _c === void 0 ? void 0 : _c.push(instance);
            }
            (_d = instance.onDrawStart) === null || _d === void 0 ? void 0 : _d.call(instance, ({ overlay: instance }));
            this._chartStore.getChart().updatePane(1 /* UpdateLevel.OVERLAY */, paneId);
            return id;
        }
        return null;
    }
    getProgressInstanceInfo() {
        return this._progressInstanceInfo;
    }
    progressInstanceComplete() {
        var _a;
        if (this._progressInstanceInfo !== null) {
            const { instance, paneId } = this._progressInstanceInfo;
            if (!instance.isDrawing()) {
                if (!this._instances.has(paneId)) {
                    this._instances.set(paneId, []);
                }
                (_a = this._instances.get(paneId)) === null || _a === void 0 ? void 0 : _a.push(instance);
                this._progressInstanceInfo = null;
            }
        }
    }
    updateProgressInstanceInfo(paneId, appointPaneFlag) {
        if (this._progressInstanceInfo !== null) {
            if (appointPaneFlag !== undefined && appointPaneFlag) {
                this._progressInstanceInfo.appointPaneFlag = appointPaneFlag;
            }
            this._progressInstanceInfo.paneId = paneId;
        }
    }
    getInstances(paneId) {
        var _a;
        if (paneId === undefined) {
            let instances = [];
            this._instances.forEach(paneInstances => {
                instances = instances.concat(paneInstances);
            });
            return instances;
        }
        return (_a = this._instances.get(paneId)) !== null && _a !== void 0 ? _a : [];
    }
    override(overlay) {
        const { id, groupId, name } = overlay;
        let updateFlag = false;
        if (id !== undefined) {
            const instance = this.getInstanceById(id);
            if (instance !== null && this._overrideInstance(instance, overlay)) {
                updateFlag = true;
            }
        }
        else {
            this._instances.forEach(paneInstances => {
                paneInstances.forEach(instance => {
                    if (((name !== undefined && instance.name === name) ||
                        (groupId !== undefined && instance.groupId === groupId) ||
                        (name === undefined && groupId === undefined)) &&
                        this._overrideInstance(instance, overlay)) {
                        updateFlag = true;
                    }
                });
            });
            if (this._progressInstanceInfo !== null) {
                const progressInstance = this._progressInstanceInfo.instance;
                if (((name !== undefined && progressInstance.name === name) ||
                    (groupId !== undefined && progressInstance.groupId === groupId) ||
                    (name === undefined && groupId === undefined)) &&
                    this._overrideInstance(progressInstance, overlay)) {
                    updateFlag = true;
                }
            }
        }
        if (updateFlag) {
            this._chartStore.getChart().updatePane(1 /* UpdateLevel.OVERLAY */);
        }
    }
    removeInstance(overlayRemove) {
        var _a;
        const match = (remove, overlay) => {
            if (remove.id !== undefined) {
                if (overlay.id !== remove.id) {
                    return false;
                }
            }
            else {
                if (remove.groupId !== undefined) {
                    if (overlay.groupId !== remove.groupId) {
                        return false;
                    }
                }
                else {
                    if (remove.name !== undefined) {
                        if (overlay.name !== remove.name) {
                            return false;
                        }
                    }
                }
            }
            return true;
        };
        const updatePaneIds = [];
        if (this._progressInstanceInfo !== null) {
            const instance = this._progressInstanceInfo.instance;
            if (overlayRemove === undefined ||
                (overlayRemove !== undefined && match(overlayRemove, instance))) {
                updatePaneIds.push(this._progressInstanceInfo.paneId);
                (_a = instance.onRemoved) === null || _a === void 0 ? void 0 : _a.call(instance, { overlay: instance });
                this._progressInstanceInfo = null;
            }
        }
        if (overlayRemove !== undefined) {
            const instances = new Map();
            for (const entry of this._instances) {
                const paneInstances = entry[1];
                const newPaneInstances = paneInstances.filter(instance => {
                    var _a;
                    if (match(overlayRemove, instance)) {
                        if (!updatePaneIds.includes(entry[0])) {
                            updatePaneIds.push(entry[0]);
                        }
                        (_a = instance.onRemoved) === null || _a === void 0 ? void 0 : _a.call(instance, { overlay: instance });
                        return false;
                    }
                    return true;
                });
                if (newPaneInstances.length > 0) {
                    instances.set(entry[0], newPaneInstances);
                }
            }
            this._instances = instances;
        }
        else {
            this._instances.forEach((paneInstances, paneId) => {
                updatePaneIds.push(paneId);
                paneInstances.forEach(instance => {
                    var _a;
                    (_a = instance.onRemoved) === null || _a === void 0 ? void 0 : _a.call(instance, { overlay: instance });
                });
            });
            this._instances.clear();
        }
        if (updatePaneIds.length > 0) {
            const chart = this._chartStore.getChart();
            updatePaneIds.forEach(paneId => {
                chart.updatePane(1 /* UpdateLevel.OVERLAY */, paneId);
            });
            chart.updatePane(1 /* UpdateLevel.OVERLAY */, PaneIdConstants.XAXIS);
        }
    }
    setPressedInstanceInfo(info) {
        this._pressedInstanceInfo = info;
    }
    getPressedInstanceInfo() {
        return this._pressedInstanceInfo;
    }
    setHoverInstanceInfo(info, event) {
        var _a, _b, _c, _d, _e;
        const { instance, figureType, figureIndex } = this._hoverInstanceInfo;
        if ((instance === null || instance === void 0 ? void 0 : instance.id) !== ((_a = info.instance) === null || _a === void 0 ? void 0 : _a.id) ||
            figureType !== info.figureType ||
            figureIndex !== info.figureIndex) {
            this._hoverInstanceInfo = info;
            if ((instance === null || instance === void 0 ? void 0 : instance.id) !== ((_b = info.instance) === null || _b === void 0 ? void 0 : _b.id)) {
                (_c = instance === null || instance === void 0 ? void 0 : instance.onMouseLeave) === null || _c === void 0 ? void 0 : _c.call(instance, { overlay: instance, ...event });
                (_e = (_d = info.instance) === null || _d === void 0 ? void 0 : _d.onMouseEnter) === null || _e === void 0 ? void 0 : _e.call(_d, { overlay: info.instance, ...event });
            }
        }
    }
    getHoverInstanceInfo() {
        return this._hoverInstanceInfo;
    }
    setClickInstanceInfo(info, event) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const { paneId, instance, figureType, figureIndex } = this._clickInstanceInfo;
        if (!((_b = (_a = info.instance) === null || _a === void 0 ? void 0 : _a.isDrawing()) !== null && _b !== void 0 ? _b : false)) {
            (_d = (_c = info.instance) === null || _c === void 0 ? void 0 : _c.onClick) === null || _d === void 0 ? void 0 : _d.call(_c, { overlay: info.instance, ...event });
        }
        if ((instance === null || instance === void 0 ? void 0 : instance.id) !== ((_e = info.instance) === null || _e === void 0 ? void 0 : _e.id) || figureType !== info.figureType || figureIndex !== info.figureIndex) {
            this._clickInstanceInfo = info;
            if ((instance === null || instance === void 0 ? void 0 : instance.id) !== ((_f = info.instance) === null || _f === void 0 ? void 0 : _f.id)) {
                (_g = instance === null || instance === void 0 ? void 0 : instance.onDeselected) === null || _g === void 0 ? void 0 : _g.call(instance, { overlay: instance, ...event });
                (_j = (_h = info.instance) === null || _h === void 0 ? void 0 : _h.onSelected) === null || _j === void 0 ? void 0 : _j.call(_h, { overlay: info.instance, ...event });
                const chart = this._chartStore.getChart();
                chart.updatePane(1 /* UpdateLevel.OVERLAY */, info.paneId);
                if (paneId !== info.paneId) {
                    chart.updatePane(1 /* UpdateLevel.OVERLAY */, paneId);
                }
                chart.updatePane(1 /* UpdateLevel.OVERLAY */, PaneIdConstants.XAXIS);
            }
        }
    }
    getClickInstanceInfo() {
        return this._clickInstanceInfo;
    }
    isEmpty() {
        return this._instances.size === 0 && this._progressInstanceInfo === null;
    }
    isDrawing() {
        var _a, _b;
        return this._progressInstanceInfo !== null && ((_b = (_a = this._progressInstanceInfo) === null || _a === void 0 ? void 0 : _a.instance.isDrawing()) !== null && _b !== void 0 ? _b : false);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Delegate {
    constructor() {
        this._callbacks = [];
    }
    subscribe(callback) {
        var _a;
        const index = (_a = this._callbacks.indexOf(callback)) !== null && _a !== void 0 ? _a : -1;
        if (index < 0) {
            this._callbacks.push(callback);
        }
    }
    unsubscribe(callback) {
        var _a;
        if (callback !== undefined) {
            const index = (_a = this._callbacks.indexOf(callback)) !== null && _a !== void 0 ? _a : -1;
            if (index > -1) {
                this._callbacks.splice(index, 1);
            }
        }
        else {
            this._callbacks = [];
        }
    }
    execute(data) {
        this._callbacks.forEach(callback => {
            callback(data);
        });
    }
    isEmpty() {
        return this._callbacks.length === 0;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ActionStore {
    constructor() {
        /**
         * Chart action map
         */
        this._actions = new Map();
    }
    execute(type, data) {
        var _a;
        (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.execute(data);
    }
    subscribe(type, callback) {
        var _a;
        if (!this._actions.has(type)) {
            this._actions.set(type, new Delegate());
        }
        (_a = this._actions.get(type)) === null || _a === void 0 ? void 0 : _a.subscribe(callback);
    }
    /**
     * 取消事件订阅
     * @param type
     * @param callback
     * @return {boolean}
     */
    unsubscribe(type, callback) {
        const action = this._actions.get(type);
        if (action !== undefined) {
            action.unsubscribe(callback);
            if (action.isEmpty()) {
                this._actions.delete(type);
            }
        }
    }
    has(type) {
        const action = this._actions.get(type);
        return action !== undefined && !action.isEmpty();
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const light = {
    grid: {
        horizontal: {
            color: '#EDEDED'
        },
        vertical: {
            color: '#EDEDED'
        }
    },
    candle: {
        priceMark: {
            high: {
                color: '#76808F'
            },
            low: {
                color: '#76808F'
            }
        },
        tooltip: {
            rect: {
                color: '#FEFEFE',
                borderColor: '#F2F3F5'
            },
            text: {
                color: '#76808F'
            }
        }
    },
    indicator: {
        tooltip: {
            text: {
                color: '#76808F'
            }
        }
    },
    xAxis: {
        axisLine: {
            color: '#DDDDDD'
        },
        tickText: {
            color: '#76808F'
        },
        tickLine: {
            color: '#DDDDDD'
        }
    },
    yAxis: {
        axisLine: {
            color: '#DDDDDD'
        },
        tickText: {
            color: '#76808F'
        },
        tickLine: {
            color: '#DDDDDD'
        }
    },
    separator: {
        color: '#DDDDDD'
    },
    crosshair: {
        horizontal: {
            line: {
                color: '#76808F'
            },
            text: {
                borderColor: '#686D76',
                backgroundColor: '#686D76'
            }
        },
        vertical: {
            line: {
                color: '#76808F'
            },
            text: {
                borderColor: '#686D76',
                backgroundColor: '#686D76'
            }
        }
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const dark = {
    grid: {
        horizontal: {
            color: '#292929'
        },
        vertical: {
            color: '#292929'
        }
    },
    candle: {
        priceMark: {
            high: {
                color: '#929AA5'
            },
            low: {
                color: '#929AA5'
            }
        },
        tooltip: {
            rect: {
                color: 'rgba(10, 10, 10, .6)',
                borderColor: 'rgba(10, 10, 10, .6)'
            },
            text: {
                color: '#929AA5'
            }
        }
    },
    indicator: {
        tooltip: {
            text: {
                color: '#929AA5'
            }
        }
    },
    xAxis: {
        axisLine: {
            color: '#333333'
        },
        tickText: {
            color: '#929AA5'
        },
        tickLine: {
            color: '#333333'
        }
    },
    yAxis: {
        axisLine: {
            color: '#333333'
        },
        tickText: {
            color: '#929AA5'
        },
        tickLine: {
            color: '#333333'
        }
    },
    separator: {
        color: '#333333'
    },
    crosshair: {
        horizontal: {
            line: {
                color: '#929AA5'
            },
            text: {
                borderColor: '#373a40',
                backgroundColor: '#373a40'
            }
        },
        vertical: {
            line: {
                color: '#929AA5'
            },
            text: {
                borderColor: '#373a40',
                backgroundColor: '#373a40'
            }
        }
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const styles = {
    light,
    dark
};
function registerStyles(name, ss) {
    styles[name] = ss;
}
function getStyles(name) {
    var _a;
    return (_a = styles[name]) !== null && _a !== void 0 ? _a : null;
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChartStore {
    constructor(chart, options) {
        /**
         * Style config
         */
        this._styles = getDefaultStyles();
        /**
         * Custom api
         */
        this._customApi = getDefaultCustomApi();
        /**
         * language
         */
        this._locale = defaultLocale;
        /**
         * Price and volume precision
         */
        this._precision = { price: 2, volume: 0 };
        /**
         * Data source
         */
        this._dataList = [];
        /**
         * Drag pane flag
         */
        this._dragPaneFlag = false;
        /**
         * Time scale store
         */
        this._timeScaleStore = new TimeScaleStore(this);
        /**
         * Indicator store
         */
        this._indicatorStore = new IndicatorStore(this);
        /**
         * Overlay store
         */
        this._overlayStore = new OverlayStore(this);
        /**
         * Crosshair store
         */
        this._crosshairStore = new CrosshairStore(this);
        /**
         * Chart action store
         */
        this._actionStore = new ActionStore();
        /**
         * Visible data array
         */
        this._visibleDataList = [];
        this._chart = chart;
        this.setOptions(options);
    }
    /**
     * @description Adjust visible data
     * @return {*}
     */
    adjustVisibleDataList() {
        this._visibleDataList = [];
        const { from, to } = this._timeScaleStore.getVisibleRange();
        for (let i = from; i < to; i++) {
            const kLineData = this._dataList[i];
            const x = this._timeScaleStore.dataIndexToCoordinate(i);
            this._visibleDataList.push({
                dataIndex: i,
                x,
                data: kLineData
            });
        }
    }
    setOptions(options) {
        if (options !== undefined) {
            const { locale, timezone, styles, customApi } = options;
            if (locale !== undefined) {
                this._locale = locale;
            }
            if (timezone !== undefined) {
                this._timeScaleStore.setTimezone(timezone);
            }
            if (styles !== undefined) {
                if (isString(styles)) {
                    merge(this._styles, getStyles(styles));
                }
                else {
                    merge(this._styles, styles);
                }
            }
            if (customApi !== undefined) {
                merge(this._customApi, customApi);
            }
        }
        return this;
    }
    getStyles() {
        return this._styles;
    }
    getLocale() {
        return this._locale;
    }
    getCustomApi() {
        return this._customApi;
    }
    getPrecision() {
        return this._precision;
    }
    setPrecision(precision) {
        this._precision = precision;
        this._indicatorStore.setSeriesPrecision(precision);
        return this;
    }
    getDataList() {
        return this._dataList;
    }
    getVisibleDataList() {
        return this._visibleDataList;
    }
    addData(data, pos, more) {
        if (isArray(data)) {
            this._timeScaleStore.setLoading(false);
            this._timeScaleStore.setMore(more !== null && more !== void 0 ? more : true);
            const isFirstAdd = this._dataList.length === 0;
            this._dataList = data.concat(this._dataList);
            if (isFirstAdd) {
                this._timeScaleStore.resetOffsetRightDistance();
            }
            this._timeScaleStore.adjustVisibleRange();
        }
        else {
            const dataSize = this._dataList.length;
            if (pos >= dataSize) {
                this._dataList.push(data);
                let offsetRightBarCount = this._timeScaleStore.getOffsetRightBarCount();
                if (offsetRightBarCount < 0) {
                    this._timeScaleStore.setOffsetRightBarCount(--offsetRightBarCount);
                }
                this._timeScaleStore.adjustVisibleRange();
            }
            else {
                this._dataList[pos] = data;
                this.adjustVisibleDataList();
            }
        }
        this._crosshairStore.recalculate(true);
    }
    clearDataList() {
        this._dataList = [];
        this._visibleDataList = [];
        this._timeScaleStore.clear();
    }
    getTimeScaleStore() {
        return this._timeScaleStore;
    }
    getIndicatorStore() {
        return this._indicatorStore;
    }
    getOverlayStore() {
        return this._overlayStore;
    }
    getCrosshairStore() {
        return this._crosshairStore;
    }
    getActionStore() {
        return this._actionStore;
    }
    getChart() {
        return this._chart;
    }
    getDragPaneFlag() {
        return this._dragPaneFlag;
    }
    setDragPaneFlag(flag) {
        this._dragPaneFlag = flag;
        return this;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function requestAnimationFrame$1(fn) {
    if (window.requestAnimationFrame == null) {
        return window.setTimeout(fn, 20);
    }
    return window.requestAnimationFrame(fn);
}
function cancelAnimationFrame(id) {
    if (window.cancelAnimationFrame == null) {
        window.clearTimeout(id);
    }
    window.cancelAnimationFrame(id);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_REQUEST_ID = -1;
class DrawWidget extends Widget {
    constructor() {
        super(...arguments);
        this._mainRequestAnimationId = DEFAULT_REQUEST_ID;
        this._overlayRequestAnimationId = DEFAULT_REQUEST_ID;
    }
    getContainerStyle() {
        return {
            margin: '0',
            padding: '0',
            position: 'absolute',
            top: '0',
            overflow: 'hidden',
            boxSizing: 'border-box'
        };
    }
    initDom(container) {
        this._mainCanvas = createDom('canvas', {
            position: 'absolute',
            top: '0',
            left: '0',
            zIndex: '2',
            boxSizing: 'border-box'
        });
        this._mainCtx = this._mainCanvas.getContext('2d');
        this._overlayCanvas = createDom('canvas', {
            position: 'absolute',
            top: '0',
            left: '0',
            zIndex: '2',
            boxSizing: 'border-box'
        });
        this._overlayCtx = this._overlayCanvas.getContext('2d');
        container.appendChild(this._mainCanvas);
        container.appendChild(this._overlayCanvas);
    }
    _optimalUpdateMain() {
        if (this._mainRequestAnimationId !== DEFAULT_REQUEST_ID) {
            cancelAnimationFrame(this._mainRequestAnimationId);
            this._mainRequestAnimationId = DEFAULT_REQUEST_ID;
        }
        this._mainRequestAnimationId = requestAnimationFrame$1(() => {
            this.updateMain(this._mainCtx);
        });
    }
    _optimalUpdateOverlay() {
        if (this._overlayRequestAnimationId !== DEFAULT_REQUEST_ID) {
            cancelAnimationFrame(this._overlayRequestAnimationId);
            this._overlayRequestAnimationId = DEFAULT_REQUEST_ID;
        }
        this._overlayRequestAnimationId = requestAnimationFrame$1(() => {
            this.updateOverlay(this._overlayCtx);
        });
    }
    updateImp(level, container, bounding) {
        const { width, height, left } = bounding;
        container.style.left = `${left}px`;
        const sizeFlag = width !== container.offsetWidth || height !== container.offsetHeight;
        let l = level;
        if (sizeFlag) {
            this._mainCtx.clearRect(0, 0, this._mainCanvas.offsetWidth, this._mainCanvas.offsetHeight);
            this._overlayCtx.clearRect(0, 0, this._overlayCanvas.offsetWidth, this._overlayCanvas.offsetHeight);
            const domWidth = `${width}px`;
            const domHeight = `${height}px`;
            container.style.width = domWidth;
            container.style.height = domHeight;
            const pixelRatio = getPixelRatio(this._mainCanvas);
            const scaleWidth = Math.floor(width * pixelRatio);
            const scaleHeight = Math.floor(height * pixelRatio);
            this._mainCanvas.style.width = domWidth;
            this._mainCanvas.style.height = domHeight;
            this._mainCanvas.width = scaleWidth;
            this._mainCanvas.height = scaleHeight;
            this._mainCtx.scale(pixelRatio, pixelRatio);
            this._overlayCanvas.style.width = domWidth;
            this._overlayCanvas.style.height = domHeight;
            this._overlayCanvas.width = scaleWidth;
            this._overlayCanvas.height = scaleHeight;
            this._overlayCtx.scale(pixelRatio, pixelRatio);
            l = 3 /* UpdateLevel.DRAWER */;
        }
        else {
            if (l === 4 /* UpdateLevel.ALL */ || l === 3 /* UpdateLevel.DRAWER */ || l === 0 /* UpdateLevel.MAIN */) {
                this._mainCtx.clearRect(0, 0, this._mainCanvas.offsetWidth, this._mainCanvas.offsetHeight);
            }
            if (l === 4 /* UpdateLevel.ALL */ || l === 3 /* UpdateLevel.DRAWER */ || l === 1 /* UpdateLevel.OVERLAY */) {
                this._overlayCtx.clearRect(0, 0, this._overlayCanvas.offsetWidth, this._overlayCanvas.offsetHeight);
            }
        }
        switch (l) {
            case 0 /* UpdateLevel.MAIN */: {
                this._optimalUpdateMain();
                break;
            }
            case 1 /* UpdateLevel.OVERLAY */: {
                this._optimalUpdateOverlay();
                break;
            }
            case 3 /* UpdateLevel.DRAWER */:
            case 4 /* UpdateLevel.ALL */: {
                this._optimalUpdateMain();
                this._optimalUpdateOverlay();
                break;
            }
        }
    }
    getImage(includeOverlay) {
        const { width, height } = this.getBounding();
        const canvas = createDom('canvas', {
            width: `${width}px`,
            height: `${height}px`,
            boxSizing: 'border-box'
        });
        const ctx = canvas.getContext('2d');
        const pixelRatio = getPixelRatio(canvas);
        canvas.width = width * pixelRatio;
        canvas.height = height * pixelRatio;
        ctx.scale(pixelRatio, pixelRatio);
        ctx.drawImage(this._mainCanvas, 0, 0, width, height);
        if (includeOverlay) {
            ctx.drawImage(this._overlayCanvas, 0, 0, width, height);
        }
        return canvas;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEVIATION = 2;
class FigureImp extends Eventful {
    constructor(figure) {
        super();
        this.attrs = figure.attrs;
        this.styles = figure.styles;
    }
    checkEventOn(event) {
        return this.checkEventOnImp(event, this.attrs, this.styles);
    }
    draw(ctx) {
        this.drawImp(ctx, this.attrs, this.styles);
    }
    static extend(figure) {
        class Custom extends FigureImp {
            checkEventOnImp(coordinate, attrs, styles) {
                return figure.checkEventOn(coordinate, attrs, styles);
            }
            drawImp(ctx, attrs, styles) {
                figure.draw(ctx, attrs, styles);
            }
        }
        return Custom;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function checkCoordinateOnCircle(coordinate, circle) {
    const difX = coordinate.x - circle.x;
    const difY = coordinate.y - circle.y;
    const r = circle.r;
    return !(difX * difX + difY * difY > r * r);
}
function drawCircle(ctx, attrs, styles) {
    const { x, y, r } = attrs;
    const { style = "fill" /* PolygonType.FILL */, color = 'currentColor', borderSize = 1, borderColor = 'currentColor', borderStyle = "solid" /* LineType.SOLID */, borderDashedValue = [2, 2] } = styles;
    if (style === "fill" /* PolygonType.FILL */ || styles.style === "stroke_fill" /* PolygonType.STROKE_FILL */) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
    }
    if (style === "stroke" /* PolygonType.STROKE */ || styles.style === "stroke_fill" /* PolygonType.STROKE_FILL */) {
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = borderSize;
        if (borderStyle === "dashed" /* LineType.DASHED */) {
            ctx.setLineDash(borderDashedValue);
        }
        else {
            ctx.setLineDash([]);
        }
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.closePath();
        ctx.stroke();
    }
}
const circle = {
    name: 'circle',
    checkEventOn: checkCoordinateOnCircle,
    draw: (ctx, attrs, styles) => {
        drawCircle(ctx, attrs, styles);
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function checkCoordinateOnPolygon(coordinate, polygon) {
    let on = false;
    const coordinates = polygon.coordinates;
    for (let i = 0, j = coordinates.length - 1; i < coordinates.length; j = i++) {
        if ((coordinates[i].y > coordinate.y) !== (coordinates[j].y > coordinate.y) &&
            (coordinate.x < (coordinates[j].x - coordinates[i].x) * (coordinate.y - coordinates[i].y) / (coordinates[j].y - coordinates[i].y) + coordinates[i].x)) {
            on = !on;
        }
    }
    return on;
}
function drawPolygon(ctx, attrs, styles) {
    const { coordinates } = attrs;
    const { style = "fill" /* PolygonType.FILL */, color = 'currentColor', borderSize = 1, borderColor = 'currentColor', borderStyle = "solid" /* LineType.SOLID */, borderDashedValue = [2, 2] } = styles;
    if (style === "fill" /* PolygonType.FILL */ || styles.style === "stroke_fill" /* PolygonType.STROKE_FILL */) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(coordinates[0].x, coordinates[0].y);
        for (let i = 1; i < coordinates.length; i++) {
            ctx.lineTo(coordinates[i].x, coordinates[i].y);
        }
        ctx.closePath();
        ctx.fill();
    }
    if (style === "stroke" /* PolygonType.STROKE */ || styles.style === "stroke_fill" /* PolygonType.STROKE_FILL */) {
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = borderSize;
        if (borderStyle === "dashed" /* LineType.DASHED */) {
            ctx.setLineDash(borderDashedValue);
        }
        else {
            ctx.setLineDash([]);
        }
        ctx.beginPath();
        ctx.moveTo(coordinates[0].x, coordinates[0].y);
        for (let i = 1; i < coordinates.length; i++) {
            ctx.lineTo(coordinates[i].x, coordinates[i].y);
        }
        ctx.closePath();
        ctx.stroke();
    }
}
const polygon = {
    name: 'polygon',
    checkEventOn: checkCoordinateOnPolygon,
    draw: (ctx, attrs, styles) => {
        drawPolygon(ctx, attrs, styles);
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function checkCoordinateOnRect(coordinate, rect) {
    return (coordinate.x >= rect.x &&
        coordinate.x <= rect.x + rect.width &&
        coordinate.y >= rect.y &&
        coordinate.y <= rect.y + rect.height);
}
function drawRect(ctx, attrs, styles) {
    const { x, y, width: w, height: h } = attrs;
    const { style = "fill" /* PolygonType.FILL */, color = 'currentColor', borderSize = 1, borderColor = 'currentColor', borderStyle = "solid" /* LineType.SOLID */, borderRadius: r = 0, borderDashedValue = [2, 2] } = styles;
    if (style === "fill" /* PolygonType.FILL */ || styles.style === "stroke_fill" /* PolygonType.STROKE_FILL */) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.fill();
    }
    if (style === "stroke" /* PolygonType.STROKE */ || styles.style === "stroke_fill" /* PolygonType.STROKE_FILL */) {
        ctx.strokeStyle = borderColor;
        ctx.lineWidth = borderSize;
        if (borderStyle === "dashed" /* LineType.DASHED */) {
            ctx.setLineDash(borderDashedValue);
        }
        else {
            ctx.setLineDash([]);
        }
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.arcTo(x + w, y, x + w, y + h, r);
        ctx.arcTo(x + w, y + h, x, y + h, r);
        ctx.arcTo(x, y + h, x, y, r);
        ctx.arcTo(x, y, x + w, y, r);
        ctx.closePath();
        ctx.stroke();
    }
}
const rect = {
    name: 'rect',
    checkEventOn: checkCoordinateOnRect,
    draw: (ctx, attrs, styles) => {
        drawRect(ctx, attrs, styles);
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getTextRect(attrs, styles, textWidth) {
    const { size = 12, paddingLeft = 0, paddingTop = 0, paddingRight = 0, paddingBottom = 0 } = styles;
    const { x, y, text, align = 'left', baseline = 'top' } = attrs;
    const length = text.length;
    textWidth = textWidth !== null && textWidth !== void 0 ? textWidth : size * length;
    const textHeight = size;
    let startX;
    switch (align) {
        case 'left':
        case 'start': {
            startX = x;
            break;
        }
        case 'right':
        case 'end': {
            startX = x - paddingRight - textWidth - paddingLeft;
            break;
        }
        default: {
            startX = x - textWidth / 2 - paddingLeft;
            break;
        }
    }
    let startY;
    switch (baseline) {
        case 'top':
        case 'hanging': {
            startY = y;
            break;
        }
        case 'bottom':
        case 'ideographic':
        case 'alphabetic': {
            startY = y - textHeight - paddingTop - paddingBottom;
            break;
        }
        default: {
            startY = y - textHeight / 2 - paddingTop;
            break;
        }
    }
    return { x: startX, y: startY, width: paddingLeft + textWidth + paddingRight, height: paddingTop + textHeight + paddingBottom };
}
function checkCoordinateOnText(coordinate, attrs, styles) {
    const { x, y, width, height } = getTextRect(attrs, styles);
    return (coordinate.x >= x &&
        coordinate.x <= x + width &&
        coordinate.y >= y &&
        coordinate.y <= y + height);
}
function drawText(ctx, attrs, styles) {
    const { x, y, text, align = 'left', baseline = 'top' } = attrs;
    const { color = 'currentColor', size = 12, family, weight } = styles;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;
    ctx.font = createFont(size, weight, family);
    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
}
const text = {
    name: 'text',
    checkEventOn: (coordinate, attrs, styles) => {
        return checkCoordinateOnText(coordinate, attrs, styles);
    },
    draw: (ctx, attrs, styles) => {
        drawText(ctx, attrs, styles);
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function drawRectText(ctx, attrs, styles) {
    const { text } = attrs;
    const { size = 12, family, weight, paddingLeft = 0, paddingTop = 0 } = styles;
    ctx.font = createFont(size, weight, family);
    const textWidth = ctx.measureText(text).width;
    const rect = getTextRect(attrs, styles, textWidth);
    drawRect(ctx, rect, { ...styles, color: styles.backgroundColor });
    drawText(ctx, { x: rect.x + paddingLeft, y: rect.y + paddingTop, text, align: 'left', baseline: 'top' }, styles);
}
const rectText = {
    name: 'rectText',
    checkEventOn: (coordinate, attrs, styles) => {
        return checkCoordinateOnText(coordinate, attrs, styles);
    },
    draw: (ctx, attrs, styles) => {
        drawRectText(ctx, attrs, styles);
    }
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const figures = {};
const extensions = [circle, line, polygon, rect, text, rectText];
extensions.forEach((figure) => {
    figures[figure.name] = FigureImp.extend(figure);
});
function getSupportedFigures() {
    return Object.keys(figures);
}
function registerFigure(figure) {
    figures[figure.name] = FigureImp.extend(figure);
}
function getInnerFigureClass(name) {
    var _a;
    return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;
}
function getFigureClass(name) {
    var _a;
    return (_a = figures[name]) !== null && _a !== void 0 ? _a : null;
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class View extends Eventful {
    constructor(widget) {
        super();
        this._widget = widget;
    }
    getWidget() { return this._widget; }
    createFigure(name, attrs, styles, eventHandler) {
        const FigureClazz = getInnerFigureClass(name);
        if (FigureClazz !== null) {
            const figure = new FigureClazz({ name, attrs, styles });
            if (eventHandler !== undefined) {
                for (const key in eventHandler) {
                    // eslint-disable-next-line no-prototype-builtins
                    if (eventHandler.hasOwnProperty(key)) {
                        figure.registerEvent(key, eventHandler[key]);
                    }
                }
                this.addChild(figure);
            }
            return figure;
        }
        return null;
    }
    draw(ctx) {
        this.clear();
        this.drawImp(ctx);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GridView extends View {
    drawImp(ctx) {
        var _a;
        const widget = this.getWidget();
        const pane = this.getWidget().getPane();
        const chart = pane.getChart();
        const bounding = widget.getBounding();
        const gridStyles = chart.getStyles().grid;
        const show = gridStyles.show;
        if (show) {
            ctx.save();
            ctx.globalCompositeOperation = 'destination-over';
            const horizontalStyles = gridStyles.horizontal;
            const horizontalShow = horizontalStyles.show;
            if (horizontalShow) {
                const xAxis = (_a = chart.getPaneById(PaneIdConstants.XAXIS)) === null || _a === void 0 ? void 0 : _a.getAxisComponent();
                xAxis.getTicks().forEach(tick => {
                    var _a;
                    (_a = this.createFigure('line', {
                        coordinates: [
                            { x: tick.coord, y: 0 },
                            { x: tick.coord, y: bounding.height }
                        ]
                    }, horizontalStyles)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                });
            }
            const verticalStyles = gridStyles.vertical;
            const verticalShow = verticalStyles.show;
            if (verticalShow) {
                const yAxis = pane.getAxisComponent();
                yAxis.getTicks().forEach(tick => {
                    var _a;
                    (_a = this.createFigure('line', {
                        coordinates: [
                            { x: 0, y: tick.coord },
                            { x: bounding.width, y: tick.coord }
                        ]
                    }, verticalStyles)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                });
            }
            ctx.restore();
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChildrenView extends View {
    eachChildren(childCallback) {
        const pane = this.getWidget().getPane();
        const chartStore = pane.getChart().getChartStore();
        const visibleDataList = chartStore.getVisibleDataList();
        const barSpace = chartStore.getTimeScaleStore().getBarSpace();
        visibleDataList.forEach((data, index) => {
            childCallback(data, barSpace, index);
        });
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandleBarView extends ChildrenView {
    drawImp(ctx) {
        const pane = this.getWidget().getPane();
        const chartStore = pane.getChart().getChartStore();
        const candleBarOptions = this.getCandleBarOptions(chartStore);
        if (candleBarOptions !== null) {
            const yAxis = pane.getAxisComponent();
            this.eachChildren((data, barSpace) => {
                this._drawCandleBar(ctx, yAxis, data, barSpace, candleBarOptions);
            });
        }
    }
    getCandleBarOptions(chartStore) {
        const candleStyles = chartStore.getStyles().candle;
        return {
            type: candleStyles.type,
            styles: candleStyles.bar
        };
    }
    _drawCandleBar(ctx, axis, data, barSpace, candleBarOptions) {
        const { data: kLineData, x } = data;
        const { open, high, low, close } = kLineData;
        const { halfGapBar, gapBar } = barSpace;
        const { type, styles } = candleBarOptions;
        let color;
        if (close > open) {
            color = styles.upColor;
        }
        else if (close < open) {
            color = styles.downColor;
        }
        else {
            color = styles.noChangeColor;
        }
        const openY = axis.convertToPixel(open);
        const closeY = axis.convertToPixel(close);
        const priceY = [
            openY, closeY,
            axis.convertToPixel(high),
            axis.convertToPixel(low)
        ];
        priceY.sort((a, b) => a - b);
        const barHeight = Math.max(1, priceY[2] - priceY[1]);
        let rects = [];
        if (type !== "ohlc" /* CandleType.OHLC */) {
            rects.push({
                name: 'rect',
                attrs: {
                    x: x - 0.5,
                    y: priceY[0],
                    width: 1,
                    height: priceY[1] - priceY[0]
                },
                styles: { color }
            });
            if (type === "candle_stroke" /* CandleType.CANDLE_STROKE */ ||
                (type === "candle_up_stroke" /* CandleType.CANDLE_UP_STROKE */ && open < close) ||
                (type === "candle_down_stroke" /* CandleType.CANDLE_DOWN_STROKE */ && open > close)) {
                rects.push({
                    name: 'rect',
                    attrs: {
                        x: x - halfGapBar + 0.5,
                        y: priceY[1],
                        width: gapBar - 1,
                        height: barHeight
                    },
                    styles: {
                        style: "stroke" /* PolygonType.STROKE */,
                        borderColor: color
                    }
                });
            }
            else {
                rects.push({
                    name: 'rect',
                    attrs: {
                        x: x - halfGapBar,
                        y: priceY[1],
                        width: gapBar,
                        height: barHeight
                    },
                    styles: { color }
                });
            }
            rects.push({
                name: 'rect',
                attrs: {
                    x: x - 0.5,
                    y: priceY[2],
                    width: 1,
                    height: priceY[3] - priceY[2]
                },
                styles: { color }
            });
        }
        else {
            rects = [
                {
                    name: 'rect',
                    attrs: {
                        x: x - 0.5,
                        y: priceY[0],
                        width: 1,
                        height: priceY[3] - priceY[0]
                    },
                    styles: { color }
                }, {
                    name: 'rect',
                    attrs: {
                        x: x - halfGapBar,
                        y: openY,
                        width: halfGapBar,
                        height: 1
                    },
                    styles: { color }
                }, {
                    name: 'rect',
                    attrs: {
                        x,
                        y: closeY,
                        width: halfGapBar,
                        height: 1
                    },
                    styles: { color }
                }
            ];
        }
        rects.forEach(({ attrs, styles }) => {
            var _a;
            (_a = this.createFigure('rect', attrs, styles)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
        });
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndicatorView extends CandleBarView {
    getCandleBarOptions(chartStore) {
        const pane = this.getWidget().getPane();
        const yAxis = pane.getAxisComponent();
        if (!yAxis.isInCandle()) {
            const indicators = chartStore.getIndicatorStore().getInstances(pane.getId());
            for (const entries of indicators) {
                const indicator = entries[1];
                if (indicator.shouldOhlc) {
                    const indicatorStyles = indicator.styles;
                    const defaultStyles = chartStore.getStyles().indicator;
                    return {
                        type: "ohlc" /* CandleType.OHLC */,
                        styles: {
                            upColor: formatValue(indicatorStyles, 'ohlc.upColor', defaultStyles.ohlc.upColor),
                            downColor: formatValue(indicatorStyles, 'ohlc.downColor', defaultStyles.ohlc.downColor),
                            noChangeColor: formatValue(indicatorStyles, 'ohlc.noChangeColor', defaultStyles.ohlc.noChangeColor)
                        }
                    };
                }
            }
        }
        return null;
    }
    drawImp(ctx) {
        var _a;
        super.drawImp(ctx);
        const widget = this.getWidget();
        const pane = widget.getPane();
        const chart = pane.getChart();
        const bounding = widget.getBounding();
        const xAxis = (_a = chart.getPaneById(PaneIdConstants.XAXIS)) === null || _a === void 0 ? void 0 : _a.getAxisComponent();
        const yAxis = pane.getAxisComponent();
        const chartStore = chart.getChartStore();
        const dataList = chartStore.getDataList();
        const timeScaleStore = chartStore.getTimeScaleStore();
        const visibleRange = timeScaleStore.getVisibleRange();
        const indicators = chartStore.getIndicatorStore().getInstances(pane.getId());
        const defaultStyles = chartStore.getStyles().indicator;
        indicators.forEach(indicator => {
            var _a;
            let isCover = false;
            if (indicator.draw !== null) {
                ctx.save();
                isCover = (_a = indicator.draw({
                    ctx,
                    kLineDataList: dataList,
                    indicator,
                    visibleRange,
                    bounding,
                    barSpace: timeScaleStore.getBarSpace(),
                    defaultStyles,
                    xAxis,
                    yAxis
                })) !== null && _a !== void 0 ? _a : false;
                ctx.restore();
            }
            if (!isCover) {
                const result = indicator.result;
                const lineFigureStyles = [];
                const lineCoordinates = [];
                const lines = [];
                this.eachChildren((data, barSpace) => {
                    var _a;
                    const { halfGapBar, gapBar } = barSpace;
                    const { dataIndex, x } = data;
                    const indicatorData = (_a = result[dataIndex]) !== null && _a !== void 0 ? _a : {};
                    eachFigures(dataList, indicator, dataIndex, defaultStyles, (figure, figureStyles, defaultFigureStyles, count) => {
                        var _a, _b, _c;
                        const value = indicatorData[figure.key];
                        const valueY = yAxis.convertToPixel(value);
                        switch (figure.type) {
                            case 'circle': {
                                if (isValid(value)) {
                                    (_a = this.createFigure('circle', {
                                        x,
                                        y: valueY,
                                        r: halfGapBar
                                    }, {
                                        style: figureStyles.style,
                                        color: figureStyles.color,
                                        borderColor: figureStyles.color
                                    })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                                }
                                break;
                            }
                            case 'bar': {
                                if (isValid(value)) {
                                    const baseValue = (_b = figure.baseValue) !== null && _b !== void 0 ? _b : yAxis.getExtremum().min;
                                    const baseValueY = yAxis.convertToPixel(baseValue);
                                    const height = Math.abs(baseValueY - valueY);
                                    let y;
                                    if (valueY > baseValueY) {
                                        y = baseValueY;
                                    }
                                    else {
                                        y = height < 1 ? baseValueY - 1 : valueY;
                                    }
                                    (_c = this.createFigure('rect', {
                                        x: x - halfGapBar,
                                        y,
                                        width: gapBar,
                                        height
                                    }, {
                                        style: figureStyles.style,
                                        color: figureStyles.color,
                                        borderColor: figureStyles.color
                                    })) === null || _c === void 0 ? void 0 : _c.draw(ctx);
                                }
                                break;
                            }
                            case 'line': {
                                let innerFigureStyle = null;
                                if (isValid(value)) {
                                    innerFigureStyle = figureStyles;
                                    const coordinate = { x, y: valueY };
                                    const prevFigureStyles = lineFigureStyles[count];
                                    if (!isValid(lineCoordinates[count])) {
                                        lineCoordinates[count] = [];
                                    }
                                    lineCoordinates[count].push(coordinate);
                                    if (isValid(prevFigureStyles)) {
                                        if ((prevFigureStyles === null || prevFigureStyles === void 0 ? void 0 : prevFigureStyles.color) !== figureStyles.color) {
                                            lines.push({
                                                name: 'line',
                                                attrs: { coordinates: lineCoordinates[count] },
                                                styles: {
                                                    style: figureStyles.style,
                                                    color: figureStyles.color,
                                                    size: defaultFigureStyles.size,
                                                    smooth: defaultFigureStyles.smooth,
                                                    dashedValue: defaultFigureStyles.dashedValue
                                                }
                                            });
                                            lineCoordinates[count] = [coordinate];
                                        }
                                        else {
                                            if ((prevFigureStyles === null || prevFigureStyles === void 0 ? void 0 : prevFigureStyles.style) !== figureStyles.style) {
                                                lines.push({
                                                    name: 'line',
                                                    attrs: { coordinates: lineCoordinates[count] },
                                                    styles: {
                                                        style: figureStyles.style,
                                                        color: figureStyles.color,
                                                        size: defaultFigureStyles.size,
                                                        smooth: defaultFigureStyles.smooth,
                                                        dashedValue: defaultFigureStyles.dashedValue
                                                    }
                                                });
                                                lineCoordinates[count] = [coordinate];
                                            }
                                        }
                                    }
                                    if (dataIndex === visibleRange.to - 1) {
                                        lines.push({
                                            name: 'line',
                                            attrs: { coordinates: lineCoordinates[count] },
                                            styles: {
                                                style: figureStyles.style,
                                                color: figureStyles === null || figureStyles === void 0 ? void 0 : figureStyles.color,
                                                size: defaultFigureStyles.size,
                                                smooth: defaultFigureStyles.smooth,
                                                dashedValue: defaultFigureStyles.dashedValue
                                            }
                                        });
                                    }
                                }
                                lineFigureStyles[count] = innerFigureStyle;
                                break;
                            }
                        }
                    });
                });
                lines.forEach(({ attrs, styles }) => {
                    var _a;
                    (_a = this.createFigure('line', attrs, styles)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                });
            }
        });
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CrosshairLineView extends View {
    drawImp(ctx) {
        const widget = this.getWidget();
        const pane = widget.getPane();
        const bounding = widget.getBounding();
        const chartStore = widget.getPane().getChart().getChartStore();
        const crosshair = chartStore.getCrosshairStore().get();
        const styles = chartStore.getStyles().crosshair;
        if (crosshair.paneId !== undefined && styles.show) {
            if (crosshair.paneId === pane.getId()) {
                const y = crosshair.y;
                this._drawLine(ctx, [
                    { x: 0, y },
                    { x: bounding.width, y }
                ], styles.horizontal);
            }
            const x = crosshair.realX;
            this._drawLine(ctx, [
                { x, y: 0 },
                { x, y: bounding.height }
            ], styles.horizontal);
        }
    }
    _drawLine(ctx, coordinates, styles) {
        var _a;
        if (styles.show) {
            const lineStyles = styles.line;
            if (lineStyles.show) {
                (_a = this.createFigure('line', { coordinates }, lineStyles)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
            }
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndicatorTooltipView extends View {
    drawImp(ctx) {
        const widget = this.getWidget();
        const pane = widget.getPane();
        const chartStore = pane.getChart().getChartStore();
        const crosshair = chartStore.getCrosshairStore().get();
        if (crosshair.kLineData !== undefined) {
            const bounding = widget.getBounding();
            const customApi = chartStore.getCustomApi();
            const indicators = chartStore.getIndicatorStore().getInstances(pane.getId());
            const defaultStyles = chartStore.getStyles().indicator;
            this.drawIndicatorTooltip(ctx, chartStore.getDataList(), crosshair, indicators, customApi, bounding, defaultStyles);
        }
    }
    drawIndicatorTooltip(ctx, dataList, crosshair, indicators, customApi, bounding, styles, top) {
        const tooltipStyles = styles.tooltip;
        let height = 0;
        if (this.isDrawTooltip(crosshair, tooltipStyles)) {
            const tooltipTextStyles = tooltipStyles.text;
            const textMarginLeft = tooltipTextStyles.marginLeft;
            const textMarginRight = tooltipTextStyles.marginRight;
            const textSize = tooltipTextStyles.size;
            const textWeight = tooltipTextStyles.weight;
            const textFamily = tooltipTextStyles.family;
            let labelY = top !== null && top !== void 0 ? top : 0;
            ctx.font = createFont(textSize, textWeight, textFamily);
            indicators.forEach(indicator => {
                var _a;
                const { name, calcParamsText, values } = this.getIndicatorTooltipData(dataList, crosshair, indicator, customApi, styles);
                const nameValid = name !== undefined && name.length > 0;
                const valuesValid = values !== undefined && values.length > 0;
                let labelX = 0;
                if (nameValid || valuesValid) {
                    labelY += tooltipTextStyles.marginTop;
                    height += (tooltipTextStyles.marginTop + textSize + tooltipTextStyles.marginBottom);
                    if (nameValid && tooltipStyles.showName) {
                        labelX += textMarginLeft;
                        let text = name;
                        if (calcParamsText !== undefined && calcParamsText.length > 0 && tooltipStyles.showParams) {
                            text = `${text}${calcParamsText}`;
                        }
                        (_a = this.createFigure('text', {
                            x: labelX,
                            y: labelY,
                            text
                        }, {
                            color: tooltipTextStyles.color,
                            size: textSize,
                            family: textFamily,
                            weight: textWeight
                        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                        labelX += (ctx.measureText(text).width + textMarginRight);
                    }
                    if (valuesValid) {
                        const h = this.drawStandardTooltip(ctx, bounding, values, labelX, labelY, tooltipTextStyles);
                        height += h;
                        labelY += h;
                    }
                    labelY += (textSize + tooltipTextStyles.marginBottom);
                }
            });
        }
        return height;
    }
    drawStandardTooltip(ctx, bounding, values, startX, startY, styles) {
        let labelX = startX;
        let labelY = startY;
        let height = 0;
        const { marginLeft, marginTop, marginRight, marginBottom, size, family, weight } = styles;
        ctx.font = createFont(size, weight, family);
        values.forEach((data, index) => {
            var _a, _b;
            const title = data.title;
            const value = data.value;
            const titleTextWidth = ctx.measureText(title.text).width;
            const valueTextWidth = ctx.measureText(value.text).width;
            const totalTextWidth = titleTextWidth + valueTextWidth;
            if (labelX + marginLeft + totalTextWidth + marginRight > bounding.width) {
                labelX = marginLeft;
                height += (size + marginTop + marginBottom);
                labelY += (size + marginTop + marginBottom);
            }
            else {
                labelX += marginLeft;
            }
            (_a = this.createFigure('text', {
                x: labelX,
                y: labelY,
                text: title.text
            }, { color: title.color, size, family, weight })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
            labelX += titleTextWidth;
            (_b = this.createFigure('text', {
                x: labelX,
                y: labelY,
                text: value.text
            }, { color: value.color, size, family, weight })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
            labelX += (valueTextWidth + marginRight);
        });
        return height;
    }
    isDrawTooltip(crosshair, styles) {
        const showRule = styles.showRule;
        return showRule === "always" /* TooltipShowRule.ALWAYS */ ||
            (showRule === "follow_cross" /* TooltipShowRule.FOLLOW_CROSS */ && (crosshair.paneId !== undefined));
    }
    getIndicatorTooltipData(dataList, crosshair, indicator, customApi, styles) {
        var _a, _b, _c;
        if (indicator.createTooltipDataSource !== null) {
            const widget = this.getWidget();
            const pane = widget.getPane();
            const chartStore = pane.getChart().getChartStore();
            const indicatorTooltipDatas = indicator.createTooltipDataSource({
                kLineDataList: dataList,
                indicator,
                visibleRange: chartStore.getTimeScaleStore().getVisibleRange(),
                bounding: widget.getBounding(),
                crosshair,
                defaultStyles: styles,
                xAxis: (_a = pane.getChart().getPaneById(PaneIdConstants.XAXIS)) === null || _a === void 0 ? void 0 : _a.getAxisComponent(),
                yAxis: pane.getAxisComponent()
            });
            if (indicatorTooltipDatas.values !== undefined) {
                const tooltipDatas = [];
                const color = styles.tooltip.text.color;
                indicatorTooltipDatas.values.forEach(data => {
                    let title = { text: '', color };
                    if (isObject(data.title)) {
                        title = data.title;
                    }
                    else {
                        title.text = data.title;
                    }
                    let value = { text: '', color };
                    if (isObject(data.value)) {
                        value = data.value;
                    }
                    else {
                        value.text = data.value;
                    }
                    tooltipDatas.push({ title, value });
                });
                indicatorTooltipDatas.values = tooltipDatas;
            }
            return indicatorTooltipDatas;
        }
        const dataIndex = crosshair.dataIndex;
        const result = (_b = indicator.result) !== null && _b !== void 0 ? _b : [];
        let calcParamsText = '';
        const calcParams = indicator.calcParams;
        if (calcParams.length > 0) {
            calcParamsText = `(${calcParams.join(',')})`;
        }
        const indicatorData = (_c = result[dataIndex]) !== null && _c !== void 0 ? _c : {};
        const values = [];
        eachFigures(dataList, indicator, dataIndex, styles, (figure, figureStyles) => {
            if (figure.title !== undefined) {
                const color = figureStyles.color;
                let value = indicatorData[figure.key];
                if (isValid(value)) {
                    value = formatPrecision(value, indicator.precision);
                    if (indicator.shouldFormatBigNumber) {
                        value = customApi.formatBigNumber(value);
                    }
                }
                values.push({ title: { text: figure.title, color }, value: { text: value !== null && value !== void 0 ? value : styles.tooltip.defaultValue, color } });
            }
        });
        return { name: indicator.shortName, calcParamsText, values };
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OverlayView extends View {
    constructor(widget) {
        super(widget);
        this._initEvent();
    }
    _initEvent() {
        const pane = this.getWidget().getPane();
        const paneId = pane.getId();
        const overlayStore = pane.getChart().getChartStore().getOverlayStore();
        this.registerEvent('mouseMoveEvent', (event) => {
            var _a;
            const progressInstanceInfo = overlayStore.getProgressInstanceInfo();
            if (progressInstanceInfo !== null) {
                const overlay = progressInstanceInfo.instance;
                let progressInstancePaneId = progressInstanceInfo.paneId;
                if (overlay.isStart()) {
                    overlayStore.updateProgressInstanceInfo(paneId);
                    progressInstancePaneId = paneId;
                }
                if (overlay.isDrawing() && progressInstancePaneId === paneId) {
                    overlay.eventMoveForDrawing(this._coordinateToPoint(progressInstanceInfo.instance, event));
                    (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, ...event });
                }
                return this._figureMouseMoveEvent(progressInstanceInfo.instance, "point" /* EventOverlayInfoFigureType.POINT */, progressInstanceInfo.instance.points.length - 1, 0)(event);
            }
            overlayStore.setHoverInstanceInfo({
                paneId, instance: null, figureType: "none" /* EventOverlayInfoFigureType.NONE */, figureIndex: -1, attrsIndex: -1
            }, event);
            return false;
        }).registerEvent('mouseDownEvent', (event) => {
            var _a, _b;
            const progressInstanceInfo = overlayStore.getProgressInstanceInfo();
            if (progressInstanceInfo !== null) {
                const overlay = progressInstanceInfo.instance;
                let progressInstancePaneId = progressInstanceInfo.paneId;
                if (overlay.isStart()) {
                    overlayStore.updateProgressInstanceInfo(paneId, true);
                    progressInstancePaneId = paneId;
                }
                if (overlay.isDrawing() && progressInstancePaneId === paneId) {
                    overlay.eventMoveForDrawing(this._coordinateToPoint(overlay, event));
                    (_a = overlay.onDrawing) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, ...event });
                    overlay.nextStep();
                    if (!overlay.isDrawing()) {
                        overlayStore.progressInstanceComplete();
                        (_b = overlay.onDrawEnd) === null || _b === void 0 ? void 0 : _b.call(overlay, { overlay, ...event });
                    }
                }
                return this._figureMouseDownEvent(overlay, "point" /* EventOverlayInfoFigureType.POINT */, overlay.points.length - 1, 0)(event);
            }
            overlayStore.setClickInstanceInfo({
                paneId, instance: null, figureType: "none" /* EventOverlayInfoFigureType.NONE */, figureIndex: -1, attrsIndex: -1
            }, event);
            return false;
        }).registerEvent('mouseRightClickEvent', (event) => {
            const progressInstanceInfo = overlayStore.getProgressInstanceInfo();
            if (progressInstanceInfo !== null) {
                const overlay = progressInstanceInfo.instance;
                if (overlay.isDrawing()) {
                    return this._figureMouseRightClickEvent(overlay, "point" /* EventOverlayInfoFigureType.POINT */, overlay.points.length - 1, 0)(event);
                }
            }
            return false;
        }).registerEvent('mouseUpEvent', (event) => {
            var _a;
            const { instance } = overlayStore.getPressedInstanceInfo();
            if (instance !== null) {
                (_a = instance.onPressedMoveEnd) === null || _a === void 0 ? void 0 : _a.call(instance, { overlay: instance, ...event });
            }
            overlayStore.setPressedInstanceInfo({
                paneId, instance: null, figureType: "none" /* EventOverlayInfoFigureType.NONE */, figureIndex: -1, attrsIndex: -1
            });
            return false;
        }).registerEvent('pressedMouseMoveEvent', (event) => {
            var _a, _b;
            const { instance, figureType, figureIndex } = overlayStore.getPressedInstanceInfo();
            if (instance !== null) {
                if (!instance.lock) {
                    if (!((_b = (_a = instance.onPressedMoving) === null || _a === void 0 ? void 0 : _a.call(instance, { overlay: instance, ...event })) !== null && _b !== void 0 ? _b : false)) {
                        const point = this._coordinateToPoint(instance, event);
                        if (figureType === "point" /* EventOverlayInfoFigureType.POINT */) {
                            instance.eventPressedPointMove(point, figureIndex);
                        }
                        else {
                            instance.eventPressedOtherMove(point, this.getWidget().getPane().getChart().getChartStore().getTimeScaleStore());
                        }
                    }
                }
                return true;
            }
            return false;
        });
    }
    _createFigureEvents(overlay, figureType, figureIndex, attrsIndex) {
        if (!overlay.isDrawing()) {
            return {
                mouseMoveEvent: this._figureMouseMoveEvent(overlay, figureType, figureIndex, attrsIndex),
                mouseDownEvent: this._figureMouseDownEvent(overlay, figureType, figureIndex, attrsIndex),
                mouseRightClickEvent: this._figureMouseRightClickEvent(overlay, figureType, figureIndex, attrsIndex)
            };
        }
    }
    _figureMouseMoveEvent(overlay, figureType, figureIndex, attrsIndex) {
        return (event) => {
            const pane = this.getWidget().getPane();
            const overlayStore = pane.getChart().getChartStore().getOverlayStore();
            overlayStore.setHoverInstanceInfo({ paneId: pane.getId(), instance: overlay, figureType, figureIndex, attrsIndex }, event);
            return true;
        };
    }
    _figureMouseDownEvent(overlay, figureType, figureIndex, attrsIndex) {
        return (event) => {
            var _a;
            const pane = this.getWidget().getPane();
            const paneId = pane.getId();
            const overlayStore = pane.getChart().getChartStore().getOverlayStore();
            overlay.startPressedMove(this._coordinateToPoint(overlay, event));
            (_a = overlay.onPressedMoveStart) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, ...event });
            overlayStore.setPressedInstanceInfo({ paneId, instance: overlay, figureType, figureIndex, attrsIndex });
            overlayStore.setClickInstanceInfo({ paneId, instance: overlay, figureType, figureIndex, attrsIndex }, event);
            return true;
        };
    }
    _figureMouseRightClickEvent(overlay, figureType, figureIndex, attrsIndex) {
        return (event) => {
            var _a, _b;
            if (!((_b = (_a = overlay.onRightClick) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, ...event })) !== null && _b !== void 0 ? _b : false)) {
                const pane = this.getWidget().getPane();
                const overlayStore = pane.getChart().getChartStore().getOverlayStore();
                overlayStore.removeInstance(overlay);
            }
            return true;
        };
    }
    _coordinateToPoint(overlay, coordinate) {
        var _a, _b;
        const point = {};
        const pane = this.getWidget().getPane();
        const chart = pane.getChart();
        const paneId = pane.getId();
        const timeScaleStore = chart.getChartStore().getTimeScaleStore();
        if (this.coordinateToPointTimestampDataIndexFlag()) {
            const xAxis = (_a = chart.getPaneById(PaneIdConstants.XAXIS)) === null || _a === void 0 ? void 0 : _a.getAxisComponent();
            const dataIndex = xAxis.convertFromPixel(coordinate.x);
            const timestamp = (_b = timeScaleStore.dataIndexToTimestamp(dataIndex)) !== null && _b !== void 0 ? _b : undefined;
            point.dataIndex = dataIndex;
            point.timestamp = timestamp;
        }
        if (this.coordinateToPointValueFlag()) {
            const yAxis = pane.getAxisComponent();
            let value = yAxis.convertFromPixel(coordinate.y);
            if (overlay.mode !== "normal" /* OverlayMode.NORMAL */ && paneId === PaneIdConstants.CANDLE && point.dataIndex !== undefined) {
                const kLineData = timeScaleStore.getDataByDataIndex(point.dataIndex);
                if (kLineData !== null) {
                    if (value > kLineData.high) {
                        if (overlay.mode === "weak_magnet" /* OverlayMode.WEAK_MAGNET */) {
                            const highY = yAxis.convertToPixel(kLineData.high);
                            const buffValue = yAxis.convertFromPixel(highY - 8);
                            if (value < buffValue) {
                                value = kLineData.high;
                            }
                        }
                        else {
                            value = kLineData.high;
                        }
                    }
                    else if (value < kLineData.low) {
                        if (overlay.mode === "weak_magnet" /* OverlayMode.WEAK_MAGNET */) {
                            const lowY = yAxis.convertToPixel(kLineData.low);
                            const buffValue = yAxis.convertFromPixel(lowY - 8);
                            if (value > buffValue) {
                                value = kLineData.low;
                            }
                        }
                        else {
                            value = kLineData.low;
                        }
                    }
                    else {
                        const max = Math.max(kLineData.open, kLineData.close);
                        const min = Math.min(kLineData.open, kLineData.close);
                        if (value > max) {
                            if (value - max < kLineData.high - value) {
                                value = max;
                            }
                            else {
                                value = kLineData.high;
                            }
                        }
                        else if (value < min) {
                            if (value - kLineData.low < min - value) {
                                value = kLineData.low;
                            }
                            else {
                                value = min;
                            }
                        }
                        else if (max - value < value - min) {
                            value = max;
                        }
                        else {
                            value = min;
                        }
                    }
                }
            }
            point.value = value;
        }
        return point;
    }
    coordinateToPointValueFlag() {
        return true;
    }
    coordinateToPointTimestampDataIndexFlag() {
        return true;
    }
    dispatchEvent(name, event, other) {
        if (this.getWidget().getPane().getChart().getChartStore().getOverlayStore().isDrawing()) {
            return this.onEvent(name, event, other);
        }
        return super.dispatchEvent(name, event, other);
    }
    checkEventOn(event) {
        return true;
    }
    drawImp(ctx) {
        var _a;
        const widget = this.getWidget();
        const pane = widget.getPane();
        const paneId = pane.getId();
        const chart = pane.getChart();
        const yAxis = pane.getAxisComponent();
        const xAxis = (_a = chart.getPaneById(PaneIdConstants.XAXIS)) === null || _a === void 0 ? void 0 : _a.getAxisComponent();
        const bounding = widget.getBounding();
        const chartStore = chart.getChartStore();
        const customApi = chartStore.getCustomApi();
        const timeScaleStore = chartStore.getTimeScaleStore();
        const dateTimeFormat = timeScaleStore.getDateTimeFormat();
        const barSpace = timeScaleStore.getBarSpace();
        const precision = chartStore.getPrecision();
        const defaultStyles = chartStore.getStyles().overlay;
        const overlayStore = chartStore.getOverlayStore();
        const hoverInstanceInfo = overlayStore.getHoverInstanceInfo();
        const clickInstanceInfo = overlayStore.getClickInstanceInfo();
        const overlays = this.getCompleteOverlays(overlayStore, paneId);
        overlays.forEach(overlay => {
            this._drawOverlay(ctx, overlay, bounding, barSpace, precision, dateTimeFormat, customApi, defaultStyles, xAxis, yAxis, hoverInstanceInfo, clickInstanceInfo, timeScaleStore);
        });
        const progressInstanceInfo = overlayStore.getProgressInstanceInfo();
        if (progressInstanceInfo !== null) {
            const overlay = this.getProgressOverlay(progressInstanceInfo, paneId);
            if (overlay !== null) {
                this._drawOverlay(ctx, overlay, bounding, barSpace, precision, dateTimeFormat, customApi, defaultStyles, xAxis, yAxis, hoverInstanceInfo, clickInstanceInfo, timeScaleStore);
            }
        }
    }
    _drawOverlay(ctx, overlay, bounding, barSpace, precision, dateTimeFormat, customApi, defaultStyles, xAxis, yAxis, hoverInstanceInfo, clickInstanceInfo, timeScaleStore) {
        const { points } = overlay;
        const coordinates = points.map(point => {
            var _a, _b;
            let dataIndex = point.dataIndex;
            if (point.timestamp !== undefined) {
                dataIndex = timeScaleStore.timestampToDataIndex(point.timestamp);
            }
            const coordinate = { x: 0, y: 0 };
            if (dataIndex !== undefined) {
                coordinate.x = (_a = xAxis === null || xAxis === void 0 ? void 0 : xAxis.convertToPixel(dataIndex)) !== null && _a !== void 0 ? _a : 0;
            }
            if (point.value !== undefined) {
                coordinate.y = (_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.convertToPixel(point.value)) !== null && _b !== void 0 ? _b : 0;
            }
            return coordinate;
        });
        if (coordinates.length > 0) {
            const figures = new Array().concat(this.getFigures(overlay, coordinates, bounding, barSpace, precision, dateTimeFormat, defaultStyles, xAxis, yAxis));
            this.drawFigures(ctx, overlay, figures, defaultStyles);
        }
        this.drawDefaultFigures(ctx, overlay, coordinates, bounding, precision, dateTimeFormat, customApi, defaultStyles, xAxis, yAxis, hoverInstanceInfo, clickInstanceInfo);
    }
    drawFigures(ctx, overlay, figures, defaultStyles) {
        figures.forEach((figure, figureIndex) => {
            const { type, styles, attrs, ignoreEvent } = figure;
            const attrsArray = [].concat(attrs);
            attrsArray.forEach((ats, attrsIndex) => {
                var _a, _b;
                const evnets = !(ignoreEvent !== null && ignoreEvent !== void 0 ? ignoreEvent : false) ? this._createFigureEvents(overlay, "other" /* EventOverlayInfoFigureType.OTHER */, figureIndex, attrsIndex) : undefined;
                const ss = { ...defaultStyles[type], ...(_a = overlay.styles) === null || _a === void 0 ? void 0 : _a[type], ...styles };
                (_b = this.createFigure(type, ats, ss, evnets)) === null || _b === void 0 ? void 0 : _b.draw(ctx);
            });
        });
    }
    getCompleteOverlays(overlayStore, paneId) {
        return overlayStore.getInstances(paneId);
    }
    getProgressOverlay(info, paneId) {
        if (info.paneId === paneId) {
            return info.instance;
        }
        return null;
    }
    getFigures(overlay, coordinates, bounding, barSpace, precision, dateTimeFormat, defaultStyles, xAxis, yAxis) {
        var _a, _b;
        return (_b = (_a = overlay.createPointFigures) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, coordinates, bounding, barSpace, precision, dateTimeFormat, defaultStyles, xAxis, yAxis })) !== null && _b !== void 0 ? _b : [];
    }
    drawDefaultFigures(ctx, overlay, coordinates, bounding, precision, dateTimeFormat, customApi, defaultStyles, xAxis, yAxis, hoverInstanceInfo, clickInstanceInfo) {
        var _a, _b;
        if (overlay.needDefaultPointFigure) {
            if ((((_a = hoverInstanceInfo.instance) === null || _a === void 0 ? void 0 : _a.id) === overlay.id && hoverInstanceInfo.figureType !== "none" /* EventOverlayInfoFigureType.NONE */) ||
                (((_b = clickInstanceInfo.instance) === null || _b === void 0 ? void 0 : _b.id) === overlay.id && clickInstanceInfo.figureType !== "none" /* EventOverlayInfoFigureType.NONE */)) {
                const styles = overlay.styles;
                const pointStyles = { ...defaultStyles.point, ...styles === null || styles === void 0 ? void 0 : styles.point };
                coordinates.forEach(({ x, y }, index) => {
                    var _a, _b, _c;
                    let radius = pointStyles.radius;
                    let color = pointStyles.color;
                    let borderColor = pointStyles.borderColor;
                    let borderSize = pointStyles.borderSize;
                    if (((_a = hoverInstanceInfo.instance) === null || _a === void 0 ? void 0 : _a.id) === overlay.id &&
                        hoverInstanceInfo.figureType === "point" /* EventOverlayInfoFigureType.POINT */ &&
                        hoverInstanceInfo.figureIndex === index) {
                        radius = pointStyles.activeRadius;
                        color = pointStyles.activeColor;
                        borderColor = pointStyles.activeBorderColor;
                        borderSize = pointStyles.activeBorderSize;
                    }
                    (_b = this.createFigure('circle', { x, y, r: radius + borderSize }, { color: borderColor }, this._createFigureEvents(overlay, "point" /* EventOverlayInfoFigureType.POINT */, index, 0))) === null || _b === void 0 ? void 0 : _b.draw(ctx);
                    (_c = this.createFigure('circle', { x, y, r: radius }, { color })) === null || _c === void 0 ? void 0 : _c.draw(ctx);
                });
            }
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndicatorWidget extends DrawWidget {
    constructor(rootContainer, pane) {
        super(rootContainer, pane);
        this._gridView = new GridView(this);
        this._indicatorView = new IndicatorView(this);
        this._crosshairLineView = new CrosshairLineView(this);
        this._tooltipView = this.createTooltipView();
        this._overlayView = new OverlayView(this);
        this.addChild(this._overlayView);
        this.getContainer().style.cursor = 'crosshair';
    }
    getName() {
        return WidgetNameConstants.MAIN;
    }
    updateMain(ctx) {
        this.updateMainContent(ctx);
        this._indicatorView.draw(ctx);
        this._gridView.draw(ctx);
    }
    createTooltipView() {
        return new IndicatorTooltipView(this);
    }
    updateMainContent(ctx) { }
    updateOverlay(ctx) {
        this._overlayView.draw(ctx);
        this._crosshairLineView.draw(ctx);
        this._tooltipView.draw(ctx);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandleAreaView extends ChildrenView {
    drawImp(ctx) {
        var _a, _b;
        const widget = this.getWidget();
        const pane = widget.getPane();
        const chart = pane.getChart();
        const chartStore = pane.getChart().getChartStore();
        const bounding = widget.getBounding();
        const yAxis = pane.getAxisComponent();
        const barSpace = chartStore.getTimeScaleStore().getBarSpace();
        const candleAreaStyles = chart.getStyles().candle.area;
        const lineCoordinates = [];
        const areaCoordinates = [];
        let minY = Number.MAX_SAFE_INTEGER;
        this.eachChildren((data, barSpace, i) => {
            const { data: kLineData, x } = data;
            const { halfGapBar } = barSpace;
            const value = kLineData[candleAreaStyles.value];
            if (isNumber(value)) {
                const y = yAxis.convertToPixel(value);
                if (i === 0) {
                    const startX = x - halfGapBar;
                    areaCoordinates.push({ x: startX, y: bounding.height });
                    areaCoordinates.push({ x: startX, y });
                    lineCoordinates.push({ x: startX, y });
                }
                lineCoordinates.push({ x, y });
                areaCoordinates.push({ x, y });
                minY = Math.min(minY, y);
            }
        });
        const areaCoordinateCount = areaCoordinates.length;
        if (areaCoordinateCount > 0) {
            const lastCoordinate = areaCoordinates[areaCoordinateCount - 1];
            const endX = lastCoordinate.x + barSpace.halfGapBar;
            lineCoordinates.push({ x: endX, y: lastCoordinate.y });
            areaCoordinates.push({ x: endX, y: lastCoordinate.y });
            areaCoordinates.push({ x: endX, y: bounding.height });
        }
        if (lineCoordinates.length > 0) {
            (_a = this.createFigure('line', { coordinates: lineCoordinates }, {
                color: candleAreaStyles.lineColor,
                size: candleAreaStyles.lineSize
            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
        }
        if (areaCoordinates.length > 0) {
            // Draw real-time background
            const backgroundColor = candleAreaStyles.backgroundColor;
            let color;
            if (isArray(backgroundColor)) {
                const gradient = ctx.createLinearGradient(0, bounding.height, 0, minY);
                try {
                    backgroundColor.forEach(({ offset, color }) => {
                        gradient.addColorStop(offset, color);
                    });
                }
                catch (e) {
                }
                color = gradient;
            }
            else {
                color = backgroundColor;
            }
            (_b = this.createFigure('polygon', { coordinates: areaCoordinates }, { color })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandleHighLowPriceView extends ChildrenView {
    drawImp(ctx) {
        const widget = this.getWidget();
        const pane = widget.getPane();
        const chartStore = pane.getChart().getChartStore();
        const priceMarkStyles = chartStore.getStyles().candle.priceMark;
        const highPriceMarkStyles = priceMarkStyles.high;
        const lowPriceMarkStyles = priceMarkStyles.low;
        if (priceMarkStyles.show && (highPriceMarkStyles.show || lowPriceMarkStyles.show)) {
            const precision = chartStore.getPrecision();
            const yAxis = pane.getAxisComponent();
            let high = Number.MIN_SAFE_INTEGER;
            let highX = 0;
            let low = Number.MAX_SAFE_INTEGER;
            let lowX = 0;
            this.eachChildren((data, barSpace, i) => {
                const { data: kLineData, x } = data;
                if (high < kLineData.high) {
                    high = kLineData.high;
                    highX = x;
                }
                if (low > kLineData.low) {
                    low = kLineData.low;
                    lowX = x;
                }
            });
            const highY = yAxis.convertToPixel(high);
            const lowY = yAxis.convertToPixel(low);
            if (highPriceMarkStyles.show && high !== Number.MIN_SAFE_INTEGER) {
                this._drawMark(ctx, formatPrecision(high, precision.price), { x: highX, y: highY }, highY < lowY ? [-2, -5] : [2, 5], highPriceMarkStyles);
            }
            if (lowPriceMarkStyles.show && low !== Number.MAX_SAFE_INTEGER) {
                this._drawMark(ctx, formatPrecision(low, precision.price), { x: lowX, y: lowY }, highY < lowY ? [2, 5] : [-2, -5], lowPriceMarkStyles);
            }
        }
    }
    _drawMark(ctx, text, coordinate, offsets, styles) {
        var _a, _b, _c;
        const startX = coordinate.x;
        const startY = coordinate.y + offsets[0];
        (_a = this.createFigure('line', {
            coordinates: [
                { x: startX - 2, y: startY + offsets[0] },
                { x: startX, y: startY },
                { x: startX + 2, y: startY + offsets[0] }
            ]
        }, { color: styles.color })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
        let lineEndX;
        let textStartX;
        let textAlign;
        const { width } = this.getWidget().getBounding();
        if (startX > width / 2) {
            lineEndX = startX - 5;
            textStartX = lineEndX - styles.textOffset;
            textAlign = 'right';
        }
        else {
            lineEndX = startX + 5;
            textAlign = 'left';
            textStartX = lineEndX + styles.textOffset;
        }
        const y = startY + offsets[1];
        (_b = this.createFigure('line', {
            coordinates: [
                { x: startX, y: startY },
                { x: startX, y },
                { x: lineEndX, y }
            ]
        }, { color: styles.color })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
        (_c = this.createFigure('text', {
            x: textStartX,
            y,
            text,
            align: textAlign,
            baseline: 'middle'
        }, {
            color: styles.color,
            size: styles.textSize,
            family: styles.textFamily,
            weight: styles.textWeight
        })) === null || _c === void 0 ? void 0 : _c.draw(ctx);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandleLastPriceView extends View {
    drawImp(ctx) {
        var _a;
        const widget = this.getWidget();
        const pane = widget.getPane();
        const bounding = widget.getBounding();
        const chartStore = pane.getChart().getChartStore();
        const priceMarkStyles = chartStore.getStyles().candle.priceMark;
        const lastPriceMarkStyles = priceMarkStyles.last;
        const lastPriceMarkLineStyles = lastPriceMarkStyles.line;
        if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkLineStyles.show) {
            const yAxis = pane.getAxisComponent();
            const dataList = chartStore.getDataList();
            const data = dataList[dataList.length - 1];
            if (data != null) {
                const { close, open } = data;
                const priceY = yAxis.convertToNicePixel(close);
                let color;
                if (close > open) {
                    color = lastPriceMarkStyles.upColor;
                }
                else if (close < open) {
                    color = lastPriceMarkStyles.downColor;
                }
                else {
                    color = lastPriceMarkStyles.noChangeColor;
                }
                (_a = this.createFigure('line', {
                    coordinates: [
                        { x: 0, y: priceY },
                        { x: bounding.width, y: priceY }
                    ]
                }, {
                    style: lastPriceMarkLineStyles.style,
                    color,
                    size: lastPriceMarkLineStyles.size,
                    dashedValue: lastPriceMarkLineStyles.dashedValue
                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
            }
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const zhCN = {
    time: '时间：',
    open: '开：',
    high: '高：',
    low: '低：',
    close: '收：',
    volume: '成交量：'
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const enUS = {
    time: 'Time: ',
    open: 'Open: ',
    high: 'High: ',
    low: 'Low: ',
    close: 'Close: ',
    volume: 'Volume: '
};

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const locales = {
    'zh-CN': zhCN,
    'en-US': enUS
};
function registerLocale(locale, ls) {
    locales[locale] = { ...locales[locale], ...ls };
}
function getSupportedLocales() {
    return Object.keys(locales);
}
function i18n(key, locale) {
    var _a, _b;
    return (_b = (_a = locales[locale]) === null || _a === void 0 ? void 0 : _a[key]) !== null && _b !== void 0 ? _b : key;
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandleTooltipView extends IndicatorTooltipView {
    drawImp(ctx) {
        var _a;
        const widget = this.getWidget();
        const pane = widget.getPane();
        const chartStore = pane.getChart().getChartStore();
        const crosshair = chartStore.getCrosshairStore().get();
        if (crosshair.kLineData !== undefined) {
            const bounding = widget.getBounding();
            const yAxisBounding = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding();
            const dataList = chartStore.getDataList();
            const precision = chartStore.getPrecision();
            const locale = chartStore.getLocale();
            const customApi = chartStore.getCustomApi();
            const indicators = chartStore.getIndicatorStore().getInstances(pane.getId());
            const dateTimeFormat = chartStore.getTimeScaleStore().getDateTimeFormat();
            const styles = chartStore.getStyles();
            const candleStyles = styles.candle;
            const indicatorStyles = styles.indicator;
            if (candleStyles.tooltip.showType === "rect" /* TooltipShowType.RECT */ &&
                indicatorStyles.tooltip.showType === "rect" /* TooltipShowType.RECT */) {
                const isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);
                const isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);
                this._drawRectTooltip(ctx, dataList, indicators, bounding, yAxisBounding, crosshair, precision, dateTimeFormat, locale, customApi, isDrawCandleTooltip, isDrawIndicatorTooltip, styles, 0);
            }
            else if (candleStyles.tooltip.showType === "standard" /* TooltipShowType.STANDARD */ &&
                indicatorStyles.tooltip.showType === "standard" /* TooltipShowType.STANDARD */) {
                const top = this._drawCandleStandardTooltip(ctx, bounding, crosshair, precision, dateTimeFormat, locale, customApi, candleStyles);
                this.drawIndicatorTooltip(ctx, dataList, crosshair, indicators, customApi, bounding, indicatorStyles, top);
            }
            else if (candleStyles.tooltip.showType === "rect" /* TooltipShowType.RECT */ &&
                indicatorStyles.tooltip.showType === "standard" /* TooltipShowType.STANDARD */) {
                const top = this.drawIndicatorTooltip(ctx, dataList, crosshair, indicators, customApi, bounding, indicatorStyles, 0);
                const isDrawCandleTooltip = this.isDrawTooltip(crosshair, candleStyles.tooltip);
                this._drawRectTooltip(ctx, dataList, indicators, bounding, yAxisBounding, crosshair, precision, dateTimeFormat, locale, customApi, isDrawCandleTooltip, false, styles, top);
            }
            else {
                const top = this._drawCandleStandardTooltip(ctx, bounding, crosshair, precision, dateTimeFormat, locale, customApi, candleStyles);
                const isDrawIndicatorTooltip = this.isDrawTooltip(crosshair, indicatorStyles.tooltip);
                this._drawRectTooltip(ctx, dataList, indicators, bounding, yAxisBounding, crosshair, precision, dateTimeFormat, locale, customApi, false, isDrawIndicatorTooltip, styles, top);
            }
        }
    }
    _drawCandleStandardTooltip(ctx, bounding, crosshair, precision, dateTimeFormat, locale, customApi, styles) {
        const tooltipStyles = styles.tooltip;
        const tooltipTextStyles = tooltipStyles.text;
        let height = 0;
        if (this.isDrawTooltip(crosshair, tooltipStyles)) {
            const values = this._getCandleTooltipData(crosshair.kLineData, precision, dateTimeFormat, locale, customApi, styles);
            if (values.length > 0) {
                height += (tooltipTextStyles.marginTop + tooltipTextStyles.size + tooltipTextStyles.marginBottom);
                height += this.drawStandardTooltip(ctx, bounding, values, 0, tooltipTextStyles.marginTop, tooltipTextStyles);
            }
        }
        return height;
    }
    _drawRectTooltip(ctx, dataList, indicators, bounding, yAxisBounding, crosshair, precision, dateTimeFormat, locale, customApi, isDrawCandleTooltip, isDrawIndicatorTooltip, styles, top) {
        var _a, _b;
        const candleStyles = styles.candle;
        const indicatorStyles = styles.indicator;
        const candleTooltipStyles = candleStyles.tooltip;
        const indicatorTooltipStyles = indicatorStyles.tooltip;
        if (isDrawCandleTooltip || isDrawIndicatorTooltip) {
            const candleTooltipDatas = this._getCandleTooltipData(crosshair.kLineData, precision, dateTimeFormat, locale, customApi, candleStyles);
            const { marginLeft: baseTextMarginLeft, marginRight: baseTextMarginRight, marginTop: baseTextMarginTop, marginBottom: baseTextMarginBottom, size: baseTextSize, weight: baseTextWeight, family: baseTextFamily } = candleTooltipStyles.text;
            const { paddingLeft: rectPaddingLeft, paddingRight: rectPaddingRight, paddingTop: rectPaddingTop, paddingBottom: rectPaddingBottom, offsetLeft: rectLeft, offsetRight: rectRight, offsetTop: rectOffsetTop, borderSize: rectBorderSize, borderRadius: rectBorderRadius, borderColor: rectBorderColor, color: rectBackgroundColor } = candleTooltipStyles.rect;
            let maxTextWidth = 0;
            let rectWidth = 0;
            let rectHeight = 0;
            if (isDrawCandleTooltip) {
                ctx.font = createFont(baseTextSize, baseTextWeight, baseTextFamily);
                candleTooltipDatas.forEach(data => {
                    const title = data.title;
                    const value = data.value;
                    const text = `${title.text}${value.text}`;
                    const labelWidth = ctx.measureText(text).width + baseTextMarginLeft + baseTextMarginRight;
                    maxTextWidth = Math.max(maxTextWidth, labelWidth);
                });
                rectHeight += ((baseTextMarginBottom + baseTextMarginTop + baseTextSize) * candleTooltipDatas.length);
            }
            const { marginLeft: indicatorTextMarginLeft, marginRight: indicatorTextMarginRight, marginTop: indicatorTextMarginTop, marginBottom: indicatorTextMarginBottom, size: indicatorTextSize, weight: indicatorTextWeight, family: indicatorTextFamily } = indicatorTooltipStyles.text;
            const indicatorTooltipDatas = [];
            if (isDrawIndicatorTooltip) {
                ctx.font = createFont(indicatorTextSize, indicatorTextWeight, indicatorTextFamily);
                indicators.forEach(indicator => {
                    var _a;
                    const tooltipDatas = (_a = this.getIndicatorTooltipData(dataList, crosshair, indicator, customApi, indicatorStyles).values) !== null && _a !== void 0 ? _a : [];
                    indicatorTooltipDatas.push(tooltipDatas);
                    tooltipDatas.forEach(data => {
                        const title = data.title;
                        const value = data.value;
                        const text = `${title.text}${value.text}`;
                        const textWidth = ctx.measureText(text).width + indicatorTextMarginLeft + indicatorTextMarginRight;
                        maxTextWidth = Math.max(maxTextWidth, textWidth);
                        rectHeight += (indicatorTextMarginTop + indicatorTextMarginBottom + indicatorTextSize);
                    });
                });
            }
            rectWidth += maxTextWidth;
            if (rectWidth !== 0 && rectHeight !== 0) {
                rectWidth += (rectBorderSize * 2 + rectPaddingLeft + rectPaddingRight);
                rectHeight += (rectBorderSize * 2 + rectPaddingTop + rectPaddingBottom);
                const centerX = bounding.width / 2;
                let rectX;
                if (((_a = crosshair.realX) !== null && _a !== void 0 ? _a : 0) < centerX) {
                    rectX = bounding.width - rectRight - rectWidth;
                    if (styles.yAxis.inside && styles.yAxis.position === "right" /* YAxisPosition.RIGHT */) {
                        rectX -= yAxisBounding.width;
                    }
                }
                else {
                    rectX = rectLeft;
                    if (styles.yAxis.inside && styles.yAxis.position === "left" /* YAxisPosition.LEFT */) {
                        rectX += yAxisBounding.width;
                    }
                }
                const rectY = top + rectOffsetTop;
                (_b = this.createFigure('rect', {
                    x: rectX,
                    y: rectY,
                    width: rectWidth,
                    height: rectHeight
                }, {
                    style: "stroke_fill" /* PolygonType.STROKE_FILL */,
                    color: rectBackgroundColor,
                    borderColor: rectBorderColor,
                    borderSize: rectBorderSize,
                    borderRadius: rectBorderRadius
                })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
                const candleTextX = rectX + rectBorderSize + rectPaddingLeft + baseTextMarginLeft;
                let textY = rectY + rectBorderSize + rectPaddingTop;
                if (isDrawCandleTooltip) {
                    // 开始渲染基础数据文字
                    candleTooltipDatas.forEach(data => {
                        var _a, _b;
                        textY += baseTextMarginTop;
                        const title = data.title;
                        (_a = this.createFigure('text', {
                            x: candleTextX,
                            y: textY,
                            text: title.text
                        }, {
                            color: title.color,
                            size: baseTextSize,
                            family: baseTextFamily,
                            weight: baseTextWeight
                        })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                        const value = data.value;
                        (_b = this.createFigure('text', {
                            x: rectX + rectWidth - rectBorderSize - baseTextMarginRight - rectPaddingRight,
                            y: textY,
                            text: value.text,
                            align: 'right'
                        }, {
                            color: value.color,
                            size: baseTextSize,
                            family: baseTextFamily,
                            weight: baseTextWeight
                        })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
                        textY += (baseTextSize + baseTextMarginBottom);
                    });
                }
                if (isDrawIndicatorTooltip) {
                    // 开始渲染指标数据文字
                    const indicatorTextX = rectX + rectBorderSize + rectPaddingLeft + indicatorTextMarginLeft;
                    indicatorTooltipDatas.forEach(datas => {
                        datas.forEach(data => {
                            var _a, _b;
                            textY += indicatorTextMarginTop;
                            const title = data.title;
                            const value = data.value;
                            (_a = this.createFigure('text', {
                                x: indicatorTextX,
                                y: textY,
                                text: title.text
                            }, {
                                color: title.color,
                                size: indicatorTextSize,
                                family: indicatorTextFamily,
                                weight: indicatorTextWeight
                            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                            (_b = this.createFigure('text', {
                                x: rectX + rectWidth - rectBorderSize - indicatorTextMarginRight - rectPaddingRight,
                                y: textY,
                                text: value.text,
                                align: 'right'
                            }, {
                                color: value.color,
                                size: indicatorTextSize,
                                family: indicatorTextFamily,
                                weight: indicatorTextWeight
                            })) === null || _b === void 0 ? void 0 : _b.draw(ctx);
                            textY += (indicatorTextSize + indicatorTextMarginBottom);
                        });
                    });
                }
            }
        }
    }
    _getCandleTooltipData(data, precision, dateTimeFormat, locale, customApi, styles) {
        var _a, _b, _c;
        const tooltipStyles = styles.tooltip;
        const textColor = tooltipStyles.text.color;
        let tooltipData = [];
        if (isFunction(tooltipStyles.custom)) {
            const labelValues = (_b = (_a = tooltipStyles.custom) === null || _a === void 0 ? void 0 : _a.call(tooltipStyles, data, styles)) !== null && _b !== void 0 ? _b : [];
            labelValues.forEach(({ title, value }) => {
                let t = { text: '', color: '' };
                if (isObject(title)) {
                    t = title;
                }
                else {
                    t.text = title;
                    t.color = textColor;
                }
                t.text = i18n(t.text, locale);
                let v = { text: '', color: '' };
                if (isObject(value)) {
                    v = value;
                }
                else {
                    v.text = value;
                    v.color = textColor;
                }
                tooltipData.push({ title: t, value: v });
            });
        }
        else {
            const { price: pricePrecision, volume: volumePrecision } = precision;
            tooltipData = [
                {
                    title: { text: i18n('time', locale), color: textColor },
                    value: { text: customApi.formatDate(dateTimeFormat, data.timestamp, 'YYYY-MM-DD HH:mm', 0 /* FormatDateType.TOOLTIP */), color: textColor }
                }, {
                    title: { text: i18n('open', locale), color: textColor },
                    value: { text: formatPrecision(data.open, pricePrecision), color: textColor }
                }, {
                    title: { text: i18n('high', locale), color: textColor },
                    value: { text: formatPrecision(data.high, pricePrecision), color: textColor }
                }, {
                    title: { text: i18n('low', locale), color: textColor },
                    value: { text: formatPrecision(data.low, pricePrecision), color: textColor }
                }, {
                    title: { text: i18n('close', locale), color: textColor },
                    value: { text: formatPrecision(data.close, pricePrecision), color: textColor }
                }, {
                    title: { text: i18n('volume', locale), color: textColor },
                    value: {
                        text: customApi.formatBigNumber(formatPrecision((_c = data.volume) !== null && _c !== void 0 ? _c : tooltipStyles.defaultValue, volumePrecision)),
                        color: textColor
                    }
                }
            ];
        }
        return tooltipData;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandleWidget extends IndicatorWidget {
    constructor() {
        super(...arguments);
        this._candleBarView = new CandleBarView(this);
        this._candleAreaView = new CandleAreaView(this);
        this._candleHighLowPriceView = new CandleHighLowPriceView(this);
        this._candleLastPriceLineView = new CandleLastPriceView(this);
    }
    updateMainContent(ctx) {
        const candleStyles = this.getPane().getChart().getStyles().candle;
        if (candleStyles.type !== "area" /* CandleType.AREA */) {
            this._candleBarView.draw(ctx);
            this._candleHighLowPriceView.draw(ctx);
            this._candleLastPriceLineView.draw(ctx);
        }
        else {
            this._candleAreaView.draw(ctx);
        }
    }
    createTooltipView() {
        return new CandleTooltipView(this);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AxisView extends View {
    drawImp(ctx) {
        var _a;
        const widget = this.getWidget();
        const pane = widget.getPane();
        const bounding = widget.getBounding();
        const axis = pane.getAxisComponent();
        const styles = this.getAxisStyles(pane.getChart().getStyles());
        if (styles.show) {
            if (styles.axisLine.show) {
                (_a = this.createFigure('line', this.createAxisLine(bounding, styles), styles.axisLine)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
            }
            const ticks = axis.getTicks();
            if (styles.tickLine.show) {
                const lines = this.createTickLines(ticks, bounding, styles);
                lines.forEach(line => {
                    var _a;
                    (_a = this.createFigure('line', line, styles.tickLine)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                });
            }
            if (styles.tickText.show) {
                const texts = this.createTickTexts(ticks, bounding, styles);
                texts.forEach(text => {
                    var _a;
                    (_a = this.createFigure('text', text, styles.tickText)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                });
            }
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YxisView extends AxisView {
    getAxisStyles(styles) {
        return styles.yAxis;
    }
    createAxisLine(bounding, styles) {
        const yAxis = this.getWidget().getPane().getAxisComponent();
        const size = styles.axisLine.size;
        let x;
        if (yAxis.isFromZero()) {
            x = size / 2;
        }
        else {
            x = bounding.width - size;
        }
        return {
            coordinates: [
                { x, y: 0 },
                { x, y: bounding.height }
            ]
        };
    }
    createTickLines(ticks, bounding, styles) {
        const yAxis = this.getWidget().getPane().getAxisComponent();
        const axisLineStyles = styles.axisLine;
        const tickLineStyles = styles.tickLine;
        let startX = 0;
        let endX = 0;
        if (yAxis.isFromZero()) {
            startX = 0;
            if (axisLineStyles.show) {
                startX += axisLineStyles.size;
            }
            endX = startX + tickLineStyles.length;
        }
        else {
            startX = bounding.width;
            if (axisLineStyles.show) {
                startX -= axisLineStyles.size;
            }
            endX = startX - tickLineStyles.length;
        }
        return ticks.map(tick => ({
            coordinates: [
                { x: startX, y: tick.coord },
                { x: endX, y: tick.coord }
            ]
        }));
    }
    createTickTexts(ticks, bounding, styles) {
        const yAxis = this.getWidget().getPane().getAxisComponent();
        const axisLineStyles = styles.axisLine;
        const tickLineStyles = styles.tickLine;
        const tickTextStyles = styles.tickText;
        let x = 0;
        if (yAxis.isFromZero()) {
            x = tickTextStyles.marginStart;
            if (axisLineStyles.show) {
                x += axisLineStyles.size;
            }
            if (tickLineStyles.show) {
                x += tickLineStyles.length;
            }
        }
        else {
            x = bounding.width - tickTextStyles.marginEnd;
            if (axisLineStyles.show) {
                x -= axisLineStyles.size;
            }
            if (tickLineStyles.show) {
                x -= tickLineStyles.length;
            }
        }
        const textAlign = this.getWidget().getPane().getAxisComponent().isFromZero() ? 'left' : 'right';
        return ticks.map(tick => ({
            x,
            y: tick.coord,
            text: tick.text,
            align: textAlign,
            baseline: 'middle'
        }));
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandleLastPriceLabelView extends View {
    drawImp(ctx) {
        var _a;
        const widget = this.getWidget();
        const pane = widget.getPane();
        const bounding = widget.getBounding();
        const chartStore = pane.getChart().getChartStore();
        const priceMarkStyles = chartStore.getStyles().candle.priceMark;
        const lastPriceMarkStyles = priceMarkStyles.last;
        const lastPriceMarkTextStyles = lastPriceMarkStyles.text;
        if (priceMarkStyles.show && lastPriceMarkStyles.show && lastPriceMarkTextStyles.show) {
            const precision = chartStore.getPrecision();
            const yAxis = pane.getAxisComponent();
            const dataList = chartStore.getDataList();
            const visibleDataList = chartStore.getVisibleDataList();
            const data = dataList[dataList.length - 1];
            if (data !== undefined) {
                const { close, open } = data;
                const priceY = yAxis.convertToNicePixel(close);
                let backgroundColor;
                if (close > open) {
                    backgroundColor = lastPriceMarkStyles.upColor;
                }
                else if (close < open) {
                    backgroundColor = lastPriceMarkStyles.downColor;
                }
                else {
                    backgroundColor = lastPriceMarkStyles.noChangeColor;
                }
                let text;
                if (yAxis.getType() === "percentage" /* YAxisType.PERCENTAGE */) {
                    const fromData = visibleDataList[0].data;
                    const fromClose = fromData.close;
                    text = `${((close - fromClose) / fromClose * 100).toFixed(2)}%`;
                }
                else {
                    text = formatPrecision(close, precision.price);
                }
                let x;
                let textAlgin;
                if (yAxis.isFromZero()) {
                    x = 0;
                    textAlgin = 'left';
                }
                else {
                    x = bounding.width;
                    textAlgin = 'right';
                }
                (_a = this.createFigure('rectText', {
                    x,
                    y: priceY,
                    text,
                    align: textAlgin,
                    baseline: 'middle'
                }, {
                    ...lastPriceMarkTextStyles,
                    backgroundColor
                })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
            }
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndicatorLastValueView extends View {
    drawImp(ctx) {
        const widget = this.getWidget();
        const pane = widget.getPane();
        const bounding = widget.getBounding();
        const chartStore = pane.getChart().getChartStore();
        const customApi = chartStore.getCustomApi();
        const defaultStyles = chartStore.getStyles().indicator;
        const lastValueMarkStyles = defaultStyles.lastValueMark;
        const lastValueMarkTextStyles = lastValueMarkStyles.text;
        if (lastValueMarkStyles.show) {
            const yAxis = pane.getAxisComponent();
            const dataList = chartStore.getDataList();
            const dataIndex = dataList.length - 1;
            const indicators = chartStore.getIndicatorStore().getInstances(pane.getId());
            indicators.forEach(indicator => {
                const result = indicator.result;
                const indicatorData = result[dataIndex];
                if (indicatorData !== undefined) {
                    const precision = indicator.precision;
                    eachFigures(dataList, indicator, dataIndex, defaultStyles, (figure, figureStyles) => {
                        var _a;
                        const value = indicatorData[figure.key];
                        if (isValid(value)) {
                            const y = yAxis.convertToNicePixel(value);
                            let text = formatPrecision(value, precision);
                            if (indicator.shouldFormatBigNumber) {
                                text = customApi.formatBigNumber(text);
                            }
                            let x;
                            let textAlign;
                            if (yAxis.isFromZero()) {
                                x = 0;
                                textAlign = 'left';
                            }
                            else {
                                x = bounding.width;
                                textAlign = 'right';
                            }
                            (_a = this.createFigure('rectText', {
                                x,
                                y,
                                text,
                                align: textAlign,
                                baseline: 'middle'
                            }, {
                                ...lastValueMarkTextStyles,
                                backgroundColor: figureStyles.color
                            })) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                        }
                    });
                }
            });
        }
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OverlayYAxisView extends OverlayView {
    coordinateToPointTimestampDataIndexFlag() {
        return false;
    }
    drawDefaultFigures(ctx, overlay, coordinates, bounding, precision, dateTimeFormat, customApi, defaultStyles, xAxis, yAxis, hoverInstanceInfo, clickInstanceInfo) {
        this.drawFigures(ctx, overlay, this.getDefaultFigures(overlay, coordinates, bounding, precision, dateTimeFormat, customApi, xAxis, yAxis, clickInstanceInfo), defaultStyles);
    }
    getDefaultFigures(overlay, coordinates, bounding, precision, dateTimeFormat, customApi, xAxis, yAxis, clickInstanceInfo) {
        var _a, _b;
        const figures = [];
        if (overlay.needDefaultYAxisFigure &&
            overlay.id === ((_a = clickInstanceInfo.instance) === null || _a === void 0 ? void 0 : _a.id) &&
            clickInstanceInfo.paneId === this.getWidget().getPane().getId()) {
            let topY = Number.MAX_SAFE_INTEGER;
            let bottomY = Number.MIN_SAFE_INTEGER;
            const isFromZero = (_b = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isFromZero()) !== null && _b !== void 0 ? _b : false;
            let textAlign;
            let x;
            if (isFromZero) {
                textAlign = 'left';
                x = 0;
            }
            else {
                textAlign = 'right';
                x = bounding.width;
            }
            coordinates.forEach((coordinate, index) => {
                const point = overlay.points[index];
                if (point.value !== undefined) {
                    topY = Math.min(topY, coordinate.y);
                    bottomY = Math.max(bottomY, coordinate.y);
                    const text = formatPrecision(point.value, precision.price);
                    figures.push({ type: 'rectText', attrs: { x, y: coordinate.y, text, align: textAlign, baseline: 'middle' }, ignoreEvent: true });
                }
            });
            if (coordinates.length > 1) {
                figures.unshift({ type: 'rect', attrs: { x: 0, y: topY, width: bounding.width, height: bottomY - topY }, ignoreEvent: true });
            }
        }
        return figures;
    }
    getFigures(overlay, coordinates, bounding, barSpace, precision, dateTimeFormat, defaultStyles, xAxis, yAxis) {
        var _a, _b;
        return (_b = (_a = overlay.createYAxisFigures) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, coordinates, bounding, barSpace, precision, dateTimeFormat, defaultStyles, xAxis, yAxis })) !== null && _b !== void 0 ? _b : [];
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CrosshairHorizontalLabelView extends View {
    drawImp(ctx) {
        var _a;
        const widget = this.getWidget();
        const pane = widget.getPane();
        const bounding = widget.getBounding();
        const chartStore = widget.getPane().getChart().getChartStore();
        const crosshair = chartStore.getCrosshairStore().get();
        const styles = chartStore.getStyles().crosshair;
        if (crosshair.paneId !== undefined && crosshair.kLineData !== undefined && this.checkPaneId(crosshair, pane.getId())) {
            if (styles.show) {
                const directionStyles = this.getDirectionStyles(styles);
                const textStyles = directionStyles.text;
                if (directionStyles.show && textStyles.show) {
                    const axis = pane.getAxisComponent();
                    const text = this.getText(crosshair, chartStore, axis);
                    ctx.font = createFont(textStyles.size, textStyles.weight, textStyles.family);
                    (_a = this.createFigure('rectText', this.getTextAttrs(text, ctx.measureText(text).width, crosshair, bounding, axis, textStyles), textStyles)) === null || _a === void 0 ? void 0 : _a.draw(ctx);
                }
            }
        }
    }
    checkPaneId(crosshair, paneId) {
        return crosshair.paneId === paneId;
    }
    getDirectionStyles(styels) {
        return styels.horizontal;
    }
    getText(crosshair, chartStore, axis) {
        var _a, _b;
        const yAxis = axis;
        const value = axis.convertFromPixel(crosshair.y);
        let text;
        if (yAxis.getType() === "percentage" /* YAxisType.PERCENTAGE */) {
            const visibleDataList = chartStore.getVisibleDataList();
            const fromData = (_b = (_a = visibleDataList[0]) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : {};
            text = `${((value - fromData.close) / fromData.close * 100).toFixed(2)}%`;
        }
        else {
            const indicators = chartStore.getIndicatorStore().getInstances(crosshair.paneId);
            let precision = 0;
            let shouldFormatBigNumber = false;
            if (yAxis.isInCandle()) {
                precision = chartStore.getPrecision().price;
            }
            else {
                indicators.forEach(indicator => {
                    precision = Math.max(indicator.precision, precision);
                    if (!shouldFormatBigNumber) {
                        shouldFormatBigNumber = indicator.shouldFormatBigNumber;
                    }
                });
            }
            text = formatPrecision(value, precision);
            if (shouldFormatBigNumber) {
                text = chartStore.getCustomApi().formatBigNumber(text);
            }
        }
        return text;
    }
    getTextAttrs(text, textWidth, crosshair, bounding, axis, styles) {
        const yAxis = axis;
        let x;
        let textAlign;
        if (yAxis.isFromZero()) {
            x = 0;
            textAlign = 'left';
        }
        else {
            x = bounding.width;
            textAlign = 'right';
        }
        return { x, y: crosshair.y, text, align: textAlign, baseline: 'middle' };
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YAxisWidget extends DrawWidget {
    constructor(rootContainer, pane) {
        super(rootContainer, pane);
        this._yAxisView = new YxisView(this);
        this._candleLastPriceLabelView = new CandleLastPriceLabelView(this);
        this._indicatorLastValueView = new IndicatorLastValueView(this);
        this._overlayYAxisView = new OverlayYAxisView(this);
        this._crosshairHorizontalLabelView = new CrosshairHorizontalLabelView(this);
        this.getContainer().style.cursor = 'ns-resize';
        this.addChild(this._overlayYAxisView);
    }
    getName() {
        return WidgetNameConstants.YAXIS;
    }
    updateMain(ctx) {
        this._yAxisView.draw(ctx);
        if (this.getPane().getAxisComponent().isInCandle()) {
            this._candleLastPriceLabelView.draw(ctx);
        }
        this._indicatorLastValueView.draw(ctx);
    }
    updateOverlay(ctx) {
        this._overlayYAxisView.draw(ctx);
        this._crosshairHorizontalLabelView.draw(ctx);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AxisImp {
    constructor(parent) {
        this._extremum = { min: 0, max: 0, range: 0, realMin: 0, realMax: 0, realRange: 0 };
        this._prevExtremum = { min: 0, max: 0, range: 0, realMin: 0, realMax: 0, realRange: 0 };
        this._ticks = [];
        this._autoCalcTickFlag = true;
        this._parent = parent;
    }
    getParent() { return this._parent; }
    buildTicks(force) {
        if (this._autoCalcTickFlag) {
            this._extremum = this.calcExtremum();
        }
        if (this._prevExtremum.min !== this._extremum.min || this._prevExtremum.max !== this._extremum.max || force) {
            this._prevExtremum = this._extremum;
            this._ticks = this.optimalTicks(this._calcTicks());
            return true;
        }
        return false;
    }
    getTicks() {
        return this._ticks;
    }
    setExtremum(extremum) {
        this._autoCalcTickFlag = false;
        this._extremum = extremum;
    }
    getExtremum() { return this._extremum; }
    setAutoCalcTickFlag(flag) {
        this._autoCalcTickFlag = flag;
    }
    getAutoCalcTickFlag() { return this._autoCalcTickFlag; }
    _calcTicks() {
        const { realMin, realMax, realRange } = this._extremum;
        const ticks = [];
        if (realRange >= 0) {
            const [interval, precision] = this._calcTickInterval(realRange);
            const first = round(Math.ceil(realMin / interval) * interval, precision);
            const last = round(Math.floor(realMax / interval) * interval, precision);
            let n = 0;
            let f = first;
            if (interval !== 0) {
                while (f <= last) {
                    const v = f.toFixed(precision);
                    ticks[n] = { text: v, coord: 0, value: v };
                    ++n;
                    f += interval;
                }
            }
        }
        return ticks;
    }
    _calcTickInterval(range) {
        const interval = nice(range / 8.0);
        const precision = getPrecision(interval);
        return [interval, precision];
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class YAxisImp extends AxisImp {
    calcExtremum() {
        var _a, _b, _c, _d, _e;
        const parent = this.getParent();
        const chart = parent.getChart();
        const chartStore = chart.getChartStore();
        let min = Number.MAX_SAFE_INTEGER;
        let max = Number.MIN_SAFE_INTEGER;
        const figuresResultList = [];
        let shouldOhlc = false;
        let specifyMin = Number.MAX_SAFE_INTEGER;
        let specifyMax = Number.MIN_SAFE_INTEGER;
        let indicatorPrecision = Number.MAX_SAFE_INTEGER;
        const indicators = chartStore.getIndicatorStore().getInstances(parent.getId());
        indicators.forEach(indicator => {
            var _a, _b, _c;
            if (!shouldOhlc) {
                shouldOhlc = (_a = indicator.shouldOhlc) !== null && _a !== void 0 ? _a : false;
            }
            indicatorPrecision = Math.min(indicatorPrecision, indicator.precision);
            if (indicator.minValue !== null) {
                specifyMin = Math.min(specifyMin, indicator.minValue);
            }
            if (indicator.maxValue !== null) {
                specifyMax = Math.max(specifyMax, indicator.maxValue);
            }
            figuresResultList.push({
                figures: (_b = indicator.figures) !== null && _b !== void 0 ? _b : [],
                result: (_c = indicator.result) !== null && _c !== void 0 ? _c : []
            });
        });
        let precision = 4;
        const inCandle = this.isInCandle();
        if (inCandle) {
            const { price: pricePrecision } = chartStore.getPrecision();
            if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {
                precision = Math.min(indicatorPrecision, pricePrecision);
            }
            else {
                precision = pricePrecision;
            }
        }
        else {
            if (indicatorPrecision !== Number.MAX_SAFE_INTEGER) {
                precision = indicatorPrecision;
            }
        }
        const visibleDataList = chartStore.getVisibleDataList();
        const candleStyles = chart.getStyles().candle;
        const isArea = candleStyles.type === "area" /* CandleType.AREA */;
        const areaValueKey = candleStyles.area.value;
        const shouldCompareHighLow = (inCandle && !isArea) || (!inCandle && shouldOhlc);
        visibleDataList.forEach(({ dataIndex, data }) => {
            if (shouldCompareHighLow) {
                min = Math.min(min, data.low);
                max = Math.max(max, data.high);
            }
            if (inCandle && isArea) {
                min = Math.min(min, data[areaValueKey]);
                max = Math.max(max, data[areaValueKey]);
            }
            figuresResultList.forEach(({ figures, result }) => {
                var _a;
                const indicatorData = (_a = result[dataIndex]) !== null && _a !== void 0 ? _a : {};
                figures.forEach(figure => {
                    const value = indicatorData[figure.key];
                    if (isValid(value)) {
                        min = Math.min(min, value);
                        max = Math.max(max, value);
                    }
                });
            });
        });
        if (min !== Number.MAX_SAFE_INTEGER && max !== Number.MIN_SAFE_INTEGER) {
            min = Math.min(specifyMin, min);
            max = Math.max(specifyMax, max);
        }
        else {
            min = 0;
            max = 10;
        }
        const type = this.getType();
        let dif;
        switch (type) {
            case "percentage" /* YAxisType.PERCENTAGE */: {
                const fromData = (_a = visibleDataList[0]) === null || _a === void 0 ? void 0 : _a.data;
                if ((fromData === null || fromData === void 0 ? void 0 : fromData.close) !== undefined) {
                    min = (min - fromData.close) / fromData.close * 100;
                    max = (max - fromData.close) / fromData.close * 100;
                }
                dif = Math.pow(10, -2);
                break;
            }
            case "log" /* YAxisType.LOG */: {
                min = log10(min);
                max = log10(max);
                dif = 0.05 * index10(-precision);
                break;
            }
            default: {
                dif = index10(-precision);
            }
        }
        if (min === max ||
            Math.abs(min - max) < dif) {
            const minCheck = specifyMin === min;
            const maxCheck = specifyMax === max;
            min = minCheck ? min : (maxCheck ? min - 8 * dif : min - 4 * dif);
            max = maxCheck ? max : (minCheck ? max + 8 * dif : max + 4 * dif);
        }
        const height = (_c = (_b = this.getParent().getYAxisWidget()) === null || _b === void 0 ? void 0 : _b.getBounding().height) !== null && _c !== void 0 ? _c : 0;
        const { gap: paneGap } = parent.getOptions();
        let topRate = (_d = paneGap === null || paneGap === void 0 ? void 0 : paneGap.top) !== null && _d !== void 0 ? _d : 0.2;
        if (topRate >= 1) {
            topRate = topRate / height;
        }
        let bottomRate = (_e = paneGap === null || paneGap === void 0 ? void 0 : paneGap.bottom) !== null && _e !== void 0 ? _e : 0.1;
        if (bottomRate >= 1) {
            bottomRate = bottomRate / height;
        }
        let range = Math.abs(max - min);
        // 保证每次图形绘制上下都留间隙
        min = min - range * bottomRate;
        max = max + range * topRate;
        range = Math.abs(max - min);
        let realMin;
        let realMax;
        let realRange;
        if (type === "log" /* YAxisType.LOG */) {
            realMin = index10(min);
            realMax = index10(max);
            realRange = Math.abs(realMax - realMin);
        }
        else {
            realMin = min;
            realMax = max;
            realRange = range;
        }
        return {
            min, max, range, realMin, realMax, realRange
        };
    }
    /**
     * 内部值转换成坐标
     * @param value
     * @return {number}
     * @private
     */
    _innerConvertToPixel(value) {
        var _a, _b;
        const height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
        const { min, range } = this.getExtremum();
        const rate = (value - min) / range;
        return this.isReverse() ? Math.round(rate * height) : Math.round((1.0 - rate) * height);
    }
    /**
     * 是否是蜡烛图轴
     * @return {boolean}
     */
    isInCandle() {
        return this.getParent().getName() === 'candle';
    }
    /**
     * y轴类型
     * @return {string}
     */
    getType() {
        if (this.isInCandle()) {
            return this.getParent().getChart().getStyles().yAxis.type;
        }
        return "normal" /* YAxisType.NORMAL */;
    }
    getPosition() {
        return this.getParent().getChart().getStyles().yAxis.position;
    }
    /**
     * 是否反转
     * @return {boolean}
     */
    isReverse() {
        if (this.isInCandle()) {
            return this.getParent().getChart().getStyles().yAxis.reverse;
        }
        return false;
    }
    /**
     * 是否从y轴0开始
     * @return {boolean}
     */
    isFromZero() {
        const yAxisStyles = this.getParent().getChart().getStyles().yAxis;
        const inside = yAxisStyles.inside;
        return ((yAxisStyles.position === "left" /* YAxisPosition.LEFT */ && inside) ||
            (yAxisStyles.position === "right" /* YAxisPosition.RIGHT */ && !inside));
    }
    optimalTicks(ticks) {
        var _a, _b;
        const pane = this.getParent();
        const height = (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
        const chartStore = pane.getChart().getChartStore();
        const customApi = chartStore.getCustomApi();
        const optimalTicks = [];
        const type = this.getType();
        const indicators = chartStore.getIndicatorStore().getInstances(pane.getId());
        let precision = 0;
        let shouldFormatBigNumber = false;
        if (this.isInCandle()) {
            precision = chartStore.getPrecision().price;
        }
        else {
            indicators.forEach(tech => {
                precision = Math.max(precision, tech.precision);
                if (!shouldFormatBigNumber) {
                    shouldFormatBigNumber = tech.shouldFormatBigNumber;
                }
            });
        }
        const textHeight = chartStore.getStyles().xAxis.tickText.size;
        let validY;
        ticks.forEach(({ value }) => {
            let v;
            let y = this._innerConvertToPixel(+value);
            switch (type) {
                case "percentage" /* YAxisType.PERCENTAGE */: {
                    v = `${formatPrecision(value, 2)}%`;
                    break;
                }
                case "log" /* YAxisType.LOG */: {
                    y = this._innerConvertToPixel(log10(+value));
                    v = formatPrecision(value, precision);
                    break;
                }
                default: {
                    v = formatPrecision(value, precision);
                    if (shouldFormatBigNumber) {
                        v = customApi.formatBigNumber(value);
                    }
                    break;
                }
            }
            if (y > textHeight && y < height - textHeight && ((validY !== undefined && (Math.abs(validY - y) > textHeight * 2)) || validY === undefined)) {
                optimalTicks.push({ text: v, coord: y, value });
                validY = y;
            }
        });
        return optimalTicks;
    }
    getAutoSize() {
        const pane = this.getParent();
        const chart = pane.getChart();
        const styles = chart.getStyles();
        const yAxisStyles = styles.yAxis;
        const width = yAxisStyles.size;
        if (width !== 'auto') {
            return width;
        }
        const chartStore = chart.getChartStore();
        const customApi = chartStore.getCustomApi();
        let yAxisWidth = 0;
        if (yAxisStyles.show) {
            if (yAxisStyles.axisLine.show) {
                yAxisWidth += yAxisStyles.axisLine.size;
            }
            if (yAxisStyles.tickLine.show) {
                yAxisWidth += yAxisStyles.tickLine.length;
            }
            if (yAxisStyles.tickText.show) {
                let textWidth = 0;
                this.getTicks().forEach(tick => {
                    textWidth = Math.max(textWidth, calcTextWidth(tick.text, yAxisStyles.tickText.size, yAxisStyles.tickText.weight, yAxisStyles.tickText.family));
                });
                yAxisWidth += (yAxisStyles.tickText.marginStart + yAxisStyles.tickText.marginEnd + textWidth);
            }
        }
        const crosshairStyles = styles.crosshair;
        let crosshairVerticalTextWidth = 0;
        if (crosshairStyles.show &&
            crosshairStyles.horizontal.show &&
            crosshairStyles.horizontal.text.show) {
            const indicators = chartStore.getIndicatorStore().getInstances(pane.getId());
            let techPrecision = 0;
            let shouldFormatBigNumber = false;
            indicators.forEach(tech => {
                techPrecision = Math.max(tech.precision, techPrecision);
                if (!shouldFormatBigNumber) {
                    shouldFormatBigNumber = tech.shouldFormatBigNumber;
                }
            });
            let precision = 2;
            if (this.getType() !== "percentage" /* YAxisType.PERCENTAGE */) {
                if (this.isInCandle()) {
                    const { price: pricePrecision } = chartStore.getPrecision();
                    const lastValueMarkStyles = styles.indicator.lastValueMark;
                    if (lastValueMarkStyles.show && lastValueMarkStyles.text.show) {
                        precision = Math.max(techPrecision, pricePrecision);
                    }
                    else {
                        precision = pricePrecision;
                    }
                }
                else {
                    precision = techPrecision;
                }
            }
            let valueText = formatPrecision(this.getExtremum().max, precision);
            if (shouldFormatBigNumber) {
                valueText = customApi.formatBigNumber(valueText);
            }
            crosshairVerticalTextWidth += (crosshairStyles.horizontal.text.paddingLeft +
                crosshairStyles.horizontal.text.paddingRight +
                crosshairStyles.horizontal.text.borderSize * 2 +
                calcTextWidth(valueText, crosshairStyles.horizontal.text.size, crosshairStyles.horizontal.text.weight, crosshairStyles.horizontal.text.family));
        }
        return Math.max(yAxisWidth, crosshairVerticalTextWidth);
    }
    convertFromPixel(pixel) {
        var _a, _b, _c;
        const height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
        const { min, range } = this.getExtremum();
        const rate = this.isReverse() ? pixel / height : 1 - pixel / height;
        const value = rate * range + min;
        switch (this.getType()) {
            case "percentage" /* YAxisType.PERCENTAGE */: {
                const chartStore = this.getParent().getChart().getChartStore();
                const visibleDataList = chartStore.getVisibleDataList();
                const fromData = (_c = visibleDataList[0]) === null || _c === void 0 ? void 0 : _c.data;
                if ((fromData === null || fromData === void 0 ? void 0 : fromData.close) !== undefined) {
                    return fromData.close * value / 100 + fromData.close;
                }
                return 0;
            }
            case "log" /* YAxisType.LOG */: {
                return index10(value);
            }
            default: {
                return value;
            }
        }
    }
    convertToRealValue(value) {
        let v = value;
        if (this.getType() === "log" /* YAxisType.LOG */) {
            v = index10(value);
        }
        return v;
    }
    convertToPixel(value) {
        var _a;
        let v = value;
        switch (this.getType()) {
            case "percentage" /* YAxisType.PERCENTAGE */: {
                const chartStore = this.getParent().getChart().getChartStore();
                const visibleDataList = chartStore.getVisibleDataList();
                const fromData = (_a = visibleDataList[0]) === null || _a === void 0 ? void 0 : _a.data;
                if ((fromData === null || fromData === void 0 ? void 0 : fromData.close) !== undefined) {
                    v = (value - fromData.close) / fromData.close * 100;
                }
                break;
            }
            case "log" /* YAxisType.LOG */: {
                v = log10(value);
                break;
            }
            default: {
                v = value;
            }
        }
        return this._innerConvertToPixel(v);
    }
    convertToNicePixel(value) {
        var _a, _b;
        const height = (_b = (_a = this.getParent().getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding().height) !== null && _b !== void 0 ? _b : 0;
        const pixel = this.convertToPixel(value);
        return Math.round(Math.max(height * 0.05, Math.min(pixel, height * 0.98)));
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IndicatorPane extends Pane {
    getName() {
        return 'indicator';
    }
    createAxisComponent() {
        return new YAxisImp(this);
    }
    createMainWidget(container) {
        return new IndicatorWidget(container, this);
    }
    createSeparatorWidget(container) {
        return new SeparatorWidget(container, this);
    }
    creatYAxisWidget(container) {
        return new YAxisWidget(container, this);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CandlePane extends IndicatorPane {
    getName() {
        return 'candle';
    }
    createMainWidget(container) {
        return new CandleWidget(container, this);
    }
    createSeparatorWidget(container) {
        return null;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class XAxisView extends AxisView {
    getAxisStyles(styles) {
        return styles.xAxis;
    }
    createAxisLine(bounding, styles) {
        const correction = styles.axisLine.size / 2;
        return {
            coordinates: [
                { x: 0, y: correction },
                { x: bounding.width, y: correction }
            ]
        };
    }
    createTickLines(ticks, bounding, styles) {
        const tickLineStyles = styles.tickLine;
        const axisLineSize = styles.axisLine.size;
        return ticks.map(tick => ({
            coordinates: [
                { x: tick.coord, y: 0 },
                { x: tick.coord, y: axisLineSize + tickLineStyles.length }
            ]
        }));
    }
    createTickTexts(ticks, bounding, styles) {
        const tickTickStyles = styles.tickText;
        const axisLineSize = styles.axisLine.size;
        const tickLineLength = styles.tickLine.length;
        return ticks.map(tick => ({
            x: tick.coord,
            y: axisLineSize + tickLineLength + tickTickStyles.marginStart,
            text: tick.text,
            align: 'center',
            baseline: 'top'
        }));
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class OverlayXAxisView extends OverlayYAxisView {
    coordinateToPointTimestampDataIndexFlag() {
        return true;
    }
    coordinateToPointValueFlag() {
        return false;
    }
    getCompleteOverlays(overlayStore) {
        return overlayStore.getInstances();
    }
    getProgressOverlay(info) {
        return info.instance;
    }
    getDefaultFigures(overlay, coordinates, bounding, precision, dateTimeFormat, customApi, xAxis, yAxis, clickInstanceInfo) {
        var _a;
        const figures = [];
        if (overlay.needDefaultXAxisFigure && overlay.id === ((_a = clickInstanceInfo.instance) === null || _a === void 0 ? void 0 : _a.id)) {
            let leftX = Number.MAX_SAFE_INTEGER;
            let rightX = Number.MIN_SAFE_INTEGER;
            coordinates.forEach((coordinate, index) => {
                leftX = Math.min(leftX, coordinate.x);
                rightX = Math.max(rightX, coordinate.x);
                const point = overlay.points[index];
                if (point.timestamp !== undefined) {
                    const text = customApi.formatDate(dateTimeFormat, point.timestamp, 'YYYY-MM-DD HH:mm', 1 /* FormatDateType.CROSSHAIR */);
                    figures.push({ type: 'rectText', attrs: { x: coordinate.x, y: 0, text, align: 'center' }, ignoreEvent: true });
                }
            });
            if (coordinates.length > 1) {
                figures.unshift({ type: 'rect', attrs: { x: leftX, y: 0, width: rightX - leftX, height: bounding.height }, ignoreEvent: true });
            }
        }
        return figures;
    }
    getFigures(overlay, coordinates, bounding, barSpace, precision, dateTimeFormat, defaultStyles, xAxis, yAxis) {
        var _a, _b;
        return (_b = (_a = overlay.createXAxisFigures) === null || _a === void 0 ? void 0 : _a.call(overlay, { overlay, coordinates, bounding, barSpace, precision, dateTimeFormat, defaultStyles, xAxis, yAxis })) !== null && _b !== void 0 ? _b : [];
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CrosshairVerticalLabelView extends CrosshairHorizontalLabelView {
    checkPaneId(crosshair) {
        return crosshair.dataIndex === crosshair.realDataIndex;
    }
    getDirectionStyles(styles) {
        return styles.vertical;
    }
    getText(crosshair, chartStore, axis) {
        var _a;
        const timestamp = (_a = crosshair.kLineData) === null || _a === void 0 ? void 0 : _a.timestamp;
        return chartStore.getCustomApi().formatDate(chartStore.getTimeScaleStore().getDateTimeFormat(), timestamp, 'YYYY-MM-DD HH:mm', 1 /* FormatDateType.CROSSHAIR */);
    }
    getTextAttrs(text, textWidth, crosshair, bounding, axis, styles) {
        const x = crosshair.realX;
        let optimalX;
        if (x - textWidth / 2 - styles.paddingLeft < 0) {
            optimalX = styles.paddingLeft + textWidth / 2;
        }
        else if (x + textWidth / 2 + styles.paddingRight > bounding.width) {
            optimalX = bounding.width - styles.paddingRight - textWidth / 2;
        }
        else {
            optimalX = x;
        }
        return { x: optimalX, y: 0, text, align: 'center', baseline: 'top' };
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class XAxisWidget extends DrawWidget {
    constructor(rootContainer, pane) {
        super(rootContainer, pane);
        this._xAxisView = new XAxisView(this);
        this._overlayXAxisView = new OverlayXAxisView(this);
        this._crosshairVerticalLabelView = new CrosshairVerticalLabelView(this);
        this.getContainer().style.cursor = 'ew-resize';
        this.addChild(this._overlayXAxisView);
    }
    getName() {
        return WidgetNameConstants.XAXIS;
    }
    updateMain(ctx) {
        this._xAxisView.draw(ctx);
    }
    updateOverlay(ctx) {
        this._overlayXAxisView.draw(ctx);
        this._crosshairVerticalLabelView.draw(ctx);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class XAxisImp extends AxisImp {
    calcExtremum() {
        const chartStore = this.getParent().getChart().getChartStore();
        const { from, to } = chartStore.getTimeScaleStore().getVisibleRange();
        const min = from;
        const max = to - 1;
        const range = to - from;
        return {
            min, max, range, realMin: min, realMax: max, realRange: range
        };
    }
    optimalTicks(ticks) {
        var _a, _b;
        const chart = this.getParent().getChart();
        const chartStore = chart.getChartStore();
        const formatDate = chartStore.getCustomApi().formatDate;
        const optimalTicks = [];
        const tickLength = ticks.length;
        const dataList = chartStore.getDataList();
        if (tickLength > 0) {
            const dateTimeFormat = chartStore.getTimeScaleStore().getDateTimeFormat();
            const tickTextStyles = chart.getStyles().xAxis.tickText;
            const defaultLabelWidth = calcTextWidth('00-00 00:00', tickTextStyles.size, tickTextStyles.weight, tickTextStyles.family);
            const pos = parseInt(ticks[0].value, 10);
            const x = this.convertToPixel(pos);
            let tickCountDif = 1;
            if (tickLength > 1) {
                const nextPos = parseInt(ticks[1].value, 10);
                const nextX = this.convertToPixel(nextPos);
                const xDif = Math.abs(nextX - x);
                if (xDif < defaultLabelWidth) {
                    tickCountDif = Math.ceil(defaultLabelWidth / xDif);
                }
            }
            for (let i = 0; i < tickLength; i += tickCountDif) {
                const pos = parseInt(ticks[i].value, 10);
                const kLineData = dataList[pos];
                const timestamp = kLineData.timestamp;
                let text = formatDate(dateTimeFormat, timestamp, 'HH:mm', 2 /* FormatDateType.XAXIS */);
                if (i !== 0) {
                    const prevPos = parseInt(ticks[i - tickCountDif].value, 10);
                    const prevKLineData = dataList[prevPos];
                    const prevTimestamp = prevKLineData.timestamp;
                    text = (_a = this._optimalTickLabel(formatDate, dateTimeFormat, timestamp, prevTimestamp)) !== null && _a !== void 0 ? _a : text;
                }
                const x = this.convertToPixel(pos);
                optimalTicks.push({ text, coord: x, value: timestamp });
            }
            const optimalTickLength = optimalTicks.length;
            if (optimalTickLength === 1) {
                optimalTicks[0].text = formatDate(dateTimeFormat, optimalTicks[0].value, 'YYYY-MM-DD HH:mm', 2 /* FormatDateType.XAXIS */);
            }
            else {
                const firstTimestamp = optimalTicks[0].value;
                const secondTimestamp = optimalTicks[1].value;
                if (optimalTicks[2] !== undefined) {
                    const thirdText = optimalTicks[2].text;
                    if (/^[0-9]{2}-[0-9]{2}$/.test(thirdText)) {
                        optimalTicks[0].text = formatDate(dateTimeFormat, firstTimestamp, 'MM-DD', 2 /* FormatDateType.XAXIS */);
                    }
                    else if (/^[0-9]{4}-[0-9]{2}$/.test(thirdText)) {
                        optimalTicks[0].text = formatDate(dateTimeFormat, firstTimestamp, 'YYYY-MM', 2 /* FormatDateType.XAXIS */);
                    }
                    else if (/^[0-9]{4}$/.test(thirdText)) {
                        optimalTicks[0].text = formatDate(dateTimeFormat, firstTimestamp, 'YYYY', 2 /* FormatDateType.XAXIS */);
                    }
                }
                else {
                    optimalTicks[0].text = (_b = this._optimalTickLabel(formatDate, dateTimeFormat, firstTimestamp, secondTimestamp)) !== null && _b !== void 0 ? _b : optimalTicks[0].text;
                }
            }
        }
        return optimalTicks;
    }
    _optimalTickLabel(formatDate, dateTimeFormat, timestamp, comparedTimestamp) {
        const year = formatDate(dateTimeFormat, timestamp, 'YYYY', 2 /* FormatDateType.XAXIS */);
        const month = formatDate(dateTimeFormat, timestamp, 'YYYY-MM', 2 /* FormatDateType.XAXIS */);
        const day = formatDate(dateTimeFormat, timestamp, 'MM-DD', 2 /* FormatDateType.XAXIS */);
        if (year !== formatDate(dateTimeFormat, comparedTimestamp, 'YYYY', 2 /* FormatDateType.XAXIS */)) {
            return year;
        }
        else if (month !== formatDate(dateTimeFormat, comparedTimestamp, 'YYYY-MM', 2 /* FormatDateType.XAXIS */)) {
            return month;
        }
        else if (day !== formatDate(dateTimeFormat, comparedTimestamp, 'MM-DD', 2 /* FormatDateType.XAXIS */)) {
            return day;
        }
        return null;
    }
    getAutoSize() {
        const styles = this.getParent().getChart().getStyles();
        const xAxisStyles = styles.xAxis;
        const height = xAxisStyles.size;
        if (height !== 'auto') {
            return height;
        }
        const crosshairStyles = styles.crosshair;
        let xAxisHeight = 0;
        if (xAxisStyles.show) {
            if (xAxisStyles.axisLine.show) {
                xAxisHeight += xAxisStyles.axisLine.size;
            }
            if (xAxisStyles.tickLine.show) {
                xAxisHeight += xAxisStyles.tickLine.length;
            }
            if (xAxisStyles.tickText.show) {
                xAxisHeight += (xAxisStyles.tickText.marginStart + xAxisStyles.tickText.marginEnd + xAxisStyles.tickText.size);
            }
        }
        let crosshairVerticalTextHeight = 0;
        if (crosshairStyles.show &&
            crosshairStyles.vertical.show &&
            crosshairStyles.vertical.text.show) {
            crosshairVerticalTextHeight += (crosshairStyles.vertical.text.paddingTop +
                crosshairStyles.vertical.text.paddingBottom +
                crosshairStyles.vertical.text.borderSize * 2 +
                crosshairStyles.vertical.text.size);
        }
        return Math.max(xAxisHeight, crosshairVerticalTextHeight);
    }
    convertFromPixel(pixel) {
        return this.getParent().getChart().getChartStore().getTimeScaleStore().coordinateToDataIndex(pixel);
    }
    convertToPixel(value) {
        return this.getParent().getChart().getChartStore().getTimeScaleStore().dataIndexToCoordinate(value);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class XAxisPane extends Pane {
    getName() {
        return 'xAxis';
    }
    createAxisComponent() {
        return new XAxisImp(this);
    }
    createMainWidget(container) {
        return new XAxisWidget(container, this);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isFF() {
    var _a;
    if (typeof window === 'undefined') {
        return false;
    }
    return ((_a = window.navigator.userAgent.toLowerCase().indexOf('firefox')) !== null && _a !== void 0 ? _a : -1) > -1;
}
function isIOS() {
    if (typeof window === 'undefined') {
        return false;
    }
    return /iPhone|iPad|iPod/.test(window.navigator.platform);
}
function isChrome() {
    if (typeof window === 'undefined') {
        return false;
    }
    // @ts-expect-error
    return window.chrome !== undefined;
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const TOUCH_MIN_RADIUS = 10;
// TODO: get rid of a lot of boolean flags, probably we should replace it with some enum
class SyntheticEvent {
    constructor(target, handler, options) {
        this._clickCount = 0;
        this._clickTimeoutId = null;
        this._clickCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
        this._tapCount = 0;
        this._tapTimeoutId = null;
        this._tapCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
        this._longTapTimeoutId = null;
        this._longTapActive = false;
        this._mouseMoveStartCoordinate = null;
        this._touchMoveStartCoordinate = null;
        this._touchMoveExceededManhattanDistance = false;
        this._cancelClick = false;
        this._cancelTap = false;
        this._unsubscribeOutsideMouseEvents = null;
        this._unsubscribeOutsideTouchEvents = null;
        this._unsubscribeMobileSafariEvents = null;
        this._unsubscribeMousemove = null;
        this._unsubscribeMouseWheel = null;
        this._unsubscribeContextMenu = null;
        this._unsubscribeRootMouseEvents = null;
        this._unsubscribeRootTouchEvents = null;
        this._startPinchMiddleCoordinate = null;
        this._startPinchDistance = 0;
        this._pinchPrevented = false;
        this._preventTouchDragProcess = false;
        this._mousePressed = false;
        this._lastTouchEventTimeStamp = 0;
        // for touchstart/touchmove/touchend events we handle only first touch
        // i.e. we don't support several active touches at the same time (except pinch event)
        this._activeTouchId = null;
        // accept all mouse leave events if it's not an iOS device
        // see _mouseEnterHandler, _mouseMoveHandler, _mouseLeaveHandler
        this._acceptMouseLeave = !isIOS();
        /**
         * In Firefox mouse events dont't fire if the mouse position is outside of the browser's border.
         * To prevent the mouse from hanging while pressed we're subscribing on the mouseleave event of the document element.
         * We're subscribing on mouseleave, but this event is actually fired on mouseup outside of the browser's border.
         */
        this._onFirefoxOutsideMouseUp = (mouseUpEvent) => {
            this._mouseUpHandler(mouseUpEvent);
        };
        /**
         * Safari doesn't fire touchstart/mousedown events on double tap since iOS 13.
         * There are two possible solutions:
         * 1) Call preventDefault in touchEnd handler. But it also prevents click event from firing.
         * 2) Add listener on dblclick event that fires with the preceding mousedown/mouseup.
         * https://developer.apple.com/forums/thread/125073
         */
        this._onMobileSafariDoubleClick = (dblClickEvent) => {
            if (this._firesTouchEvents(dblClickEvent)) {
                ++this._tapCount;
                if (this._tapTimeoutId !== null && this._tapCount > 1) {
                    const { manhattanDistance } = this._mouseTouchMoveWithDownInfo(this._getCoordinate(dblClickEvent), this._tapCoordinate);
                    if (manhattanDistance < 30 /* ManhattanDistance.DoubleTap */ && !this._cancelTap) {
                        this._processEvent(this._makeCompatEvent(dblClickEvent), this._handler.doubleTapEvent);
                    }
                    this._resetTapTimeout();
                }
            }
            else {
                ++this._clickCount;
                if (this._clickTimeoutId !== null && this._clickCount > 1) {
                    const { manhattanDistance } = this._mouseTouchMoveWithDownInfo(this._getCoordinate(dblClickEvent), this._clickCoordinate);
                    if (manhattanDistance < 5 /* ManhattanDistance.DoubleClick */ && !this._cancelClick) {
                        this._processEvent(this._makeCompatEvent(dblClickEvent), this._handler.mouseDoubleClickEvent);
                    }
                    this._resetClickTimeout();
                }
            }
        };
        this._target = target;
        this._handler = handler;
        this._options = options;
        this._init();
    }
    destroy() {
        if (this._unsubscribeOutsideMouseEvents !== null) {
            this._unsubscribeOutsideMouseEvents();
            this._unsubscribeOutsideMouseEvents = null;
        }
        if (this._unsubscribeOutsideTouchEvents !== null) {
            this._unsubscribeOutsideTouchEvents();
            this._unsubscribeOutsideTouchEvents = null;
        }
        if (this._unsubscribeMousemove !== null) {
            this._unsubscribeMousemove();
            this._unsubscribeMousemove = null;
        }
        if (this._unsubscribeMouseWheel !== null) {
            this._unsubscribeMouseWheel();
            this._unsubscribeMouseWheel = null;
        }
        if (this._unsubscribeContextMenu !== null) {
            this._unsubscribeContextMenu();
            this._unsubscribeContextMenu = null;
        }
        if (this._unsubscribeRootMouseEvents !== null) {
            this._unsubscribeRootMouseEvents();
            this._unsubscribeRootMouseEvents = null;
        }
        if (this._unsubscribeRootTouchEvents !== null) {
            this._unsubscribeRootTouchEvents();
            this._unsubscribeRootTouchEvents = null;
        }
        if (this._unsubscribeMobileSafariEvents !== null) {
            this._unsubscribeMobileSafariEvents();
            this._unsubscribeMobileSafariEvents = null;
        }
        this._clearLongTapTimeout();
        this._resetClickTimeout();
    }
    _mouseEnterHandler(enterEvent) {
        var _a, _b, _c;
        (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);
        (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);
        (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);
        const boundMouseMoveHandler = this._mouseMoveHandler.bind(this);
        this._unsubscribeMousemove = () => {
            this._target.removeEventListener('mousemove', boundMouseMoveHandler);
        };
        this._target.addEventListener('mousemove', boundMouseMoveHandler);
        const boundMouseWheel = this._mouseWheelHandler.bind(this);
        this._unsubscribeMouseWheel = () => {
            this._target.removeEventListener('wheel', boundMouseWheel);
        };
        this._target.addEventListener('wheel', boundMouseWheel, { passive: false });
        const boundContextMenu = this._contextMenuHandler.bind(this);
        this._unsubscribeContextMenu = () => {
            this._target.removeEventListener('contextmenu', boundContextMenu);
        };
        this._target.addEventListener('contextmenu', boundContextMenu, { passive: false });
        if (this._firesTouchEvents(enterEvent)) {
            return;
        }
        this._processEvent(this._makeCompatEvent(enterEvent), this._handler.mouseEnterEvent);
        this._acceptMouseLeave = true;
    }
    _resetClickTimeout() {
        if (this._clickTimeoutId !== null) {
            clearTimeout(this._clickTimeoutId);
        }
        this._clickCount = 0;
        this._clickTimeoutId = null;
        this._clickCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
    }
    _resetTapTimeout() {
        if (this._tapTimeoutId !== null) {
            clearTimeout(this._tapTimeoutId);
        }
        this._tapCount = 0;
        this._tapTimeoutId = null;
        this._tapCoordinate = { x: Number.NEGATIVE_INFINITY, y: Number.POSITIVE_INFINITY };
    }
    _mouseMoveHandler(moveEvent) {
        if (this._mousePressed || this._touchMoveStartCoordinate !== null) {
            return;
        }
        if (this._firesTouchEvents(moveEvent)) {
            return;
        }
        this._processEvent(this._makeCompatEvent(moveEvent), this._handler.mouseMoveEvent);
        this._acceptMouseLeave = true;
    }
    _mouseWheelHandler(wheelEvent) {
        if (Math.abs(wheelEvent.deltaX) > Math.abs(wheelEvent.deltaY)) {
            if (this._handler.mouseWheelHortEvent === undefined) {
                return;
            }
            this._preventDefault(wheelEvent);
            if (Math.abs(wheelEvent.deltaX) === 0) {
                return;
            }
            this._handler.mouseWheelHortEvent(this._makeCompatEvent(wheelEvent), -wheelEvent.deltaX);
        }
        else {
            if (this._handler.mouseWheelVertEvent === undefined) {
                return;
            }
            let deltaY = -(wheelEvent.deltaY / 100);
            if (deltaY === 0) {
                return;
            }
            this._preventDefault(wheelEvent);
            switch (wheelEvent.deltaMode) {
                case wheelEvent.DOM_DELTA_PAGE:
                    deltaY *= 120;
                    break;
                case wheelEvent.DOM_DELTA_LINE:
                    deltaY *= 32;
                    break;
            }
            if (deltaY !== 0) {
                const scale = Math.sign(deltaY) * Math.min(1, Math.abs(deltaY));
                this._handler.mouseWheelVertEvent(this._makeCompatEvent(wheelEvent), scale);
            }
        }
    }
    _contextMenuHandler(mouseEvent) {
        this._preventDefault(mouseEvent);
    }
    _touchMoveHandler(moveEvent) {
        const touch = this._touchWithId(moveEvent.changedTouches, this._activeTouchId);
        if (touch === null) {
            return;
        }
        this._lastTouchEventTimeStamp = this._eventTimeStamp(moveEvent);
        if (this._startPinchMiddleCoordinate !== null) {
            return;
        }
        if (this._preventTouchDragProcess) {
            return;
        }
        // prevent pinch if move event comes faster than the second touch
        this._pinchPrevented = true;
        const moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._touchMoveStartCoordinate);
        const { xOffset, yOffset, manhattanDistance } = moveInfo;
        if (!this._touchMoveExceededManhattanDistance && manhattanDistance < 5 /* ManhattanDistance.CancelTap */) {
            return;
        }
        if (!this._touchMoveExceededManhattanDistance) {
            // first time when current position exceeded manhattan distance
            // vertical drag is more important than horizontal drag
            // because we scroll the page vertically often than horizontally
            const correctedXOffset = xOffset * 0.5;
            // a drag can be only if touch page scroll isn't allowed
            const isVertDrag = yOffset >= correctedXOffset && !this._options.treatVertDragAsPageScroll();
            const isHorzDrag = correctedXOffset > yOffset && !this._options.treatHorzDragAsPageScroll();
            // if drag event happened then we should revert preventDefault state to original one
            // and try to process the drag event
            // else we shouldn't prevent default of the event and ignore processing the drag event
            if (!isVertDrag && !isHorzDrag) {
                this._preventTouchDragProcess = true;
            }
            this._touchMoveExceededManhattanDistance = true;
            // if manhattan distance is more that 5 - we should cancel tap event
            this._cancelTap = true;
            this._clearLongTapTimeout();
            this._resetTapTimeout();
        }
        if (!this._preventTouchDragProcess) {
            this._processEvent(this._makeCompatEvent(moveEvent, touch), this._handler.touchMoveEvent);
            // we should prevent default in case of touch only
            // to prevent scroll of the page
            // preventDefault(moveEvent)
        }
    }
    _mouseMoveWithDownHandler(moveEvent) {
        if (moveEvent.button !== 0 /* MouseEventButton.Left */) {
            return;
        }
        const moveInfo = this._mouseTouchMoveWithDownInfo(this._getCoordinate(moveEvent), this._mouseMoveStartCoordinate);
        const { manhattanDistance } = moveInfo;
        if (manhattanDistance >= 5 /* ManhattanDistance.CancelClick */) {
            // if manhattan distance is more that 5 - we should cancel click event
            this._cancelClick = true;
            this._resetClickTimeout();
        }
        if (this._cancelClick) {
            // if this._cancelClick is true, that means that minimum manhattan distance is already exceeded
            this._processEvent(this._makeCompatEvent(moveEvent), this._handler.pressedMouseMoveEvent);
        }
    }
    _mouseTouchMoveWithDownInfo(currentCoordinate, startCoordinate) {
        const xOffset = Math.abs(startCoordinate.x - currentCoordinate.x);
        const yOffset = Math.abs(startCoordinate.y - currentCoordinate.y);
        const manhattanDistance = xOffset + yOffset;
        return { xOffset, yOffset, manhattanDistance };
    }
    // eslint-disable-next-line complexity
    _touchEndHandler(touchEndEvent) {
        let touch = this._touchWithId(touchEndEvent.changedTouches, this._activeTouchId);
        if (touch === null && touchEndEvent.touches.length === 0) {
            // something went wrong, somehow we missed the required touchend event
            // probably the browser has not sent this event
            touch = touchEndEvent.changedTouches[0];
        }
        if (touch === null) {
            return;
        }
        this._activeTouchId = null;
        this._lastTouchEventTimeStamp = this._eventTimeStamp(touchEndEvent);
        this._clearLongTapTimeout();
        this._touchMoveStartCoordinate = null;
        if (this._unsubscribeRootTouchEvents !== null) {
            this._unsubscribeRootTouchEvents();
            this._unsubscribeRootTouchEvents = null;
        }
        const compatEvent = this._makeCompatEvent(touchEndEvent, touch);
        this._processEvent(compatEvent, this._handler.touchEndEvent);
        ++this._tapCount;
        if (this._tapTimeoutId !== null && this._tapCount > 1) {
            // check that both clicks are near enough
            const { manhattanDistance } = this._mouseTouchMoveWithDownInfo(this._getCoordinate(touch), this._tapCoordinate);
            if (manhattanDistance < 30 /* ManhattanDistance.DoubleTap */ && !this._cancelTap) {
                this._processEvent(compatEvent, this._handler.doubleTapEvent);
            }
            this._resetTapTimeout();
        }
        else {
            if (!this._cancelTap) {
                this._processEvent(compatEvent, this._handler.tapEvent);
                // do not fire mouse events if tap handler was executed
                // prevent click event on new dom element (who appeared after tap)
                if (this._handler.tapEvent !== undefined) {
                    this._preventDefault(touchEndEvent);
                }
            }
        }
        // prevent, for example, safari's dblclick-to-zoom or fast-click after long-tap
        // we handle mouseDoubleClickEvent here ourselves
        if (this._tapCount === 0) {
            this._preventDefault(touchEndEvent);
        }
        if (touchEndEvent.touches.length === 0) {
            if (this._longTapActive) {
                this._longTapActive = false;
                // prevent native click event
                this._preventDefault(touchEndEvent);
            }
        }
    }
    _mouseUpHandler(mouseUpEvent) {
        if (mouseUpEvent.button !== 0 /* MouseEventButton.Left */) {
            return;
        }
        const compatEvent = this._makeCompatEvent(mouseUpEvent);
        this._mouseMoveStartCoordinate = null;
        this._mousePressed = false;
        if (this._unsubscribeRootMouseEvents !== null) {
            this._unsubscribeRootMouseEvents();
            this._unsubscribeRootMouseEvents = null;
        }
        if (isFF()) {
            const rootElement = this._target.ownerDocument.documentElement;
            rootElement.removeEventListener('mouseleave', this._onFirefoxOutsideMouseUp);
        }
        if (this._firesTouchEvents(mouseUpEvent)) {
            return;
        }
        this._processEvent(compatEvent, this._handler.mouseUpEvent);
        ++this._clickCount;
        if (this._clickTimeoutId !== null && this._clickCount > 1) {
            // check that both clicks are near enough
            const { manhattanDistance } = this._mouseTouchMoveWithDownInfo(this._getCoordinate(mouseUpEvent), this._clickCoordinate);
            if (manhattanDistance < 5 /* ManhattanDistance.DoubleClick */ && !this._cancelClick) {
                this._processEvent(compatEvent, this._handler.mouseDoubleClickEvent);
            }
            this._resetClickTimeout();
        }
        else {
            if (!this._cancelClick) {
                this._processEvent(compatEvent, this._handler.mouseClickEvent);
            }
        }
    }
    _clearLongTapTimeout() {
        if (this._longTapTimeoutId === null) {
            return;
        }
        clearTimeout(this._longTapTimeoutId);
        this._longTapTimeoutId = null;
    }
    _touchStartHandler(downEvent) {
        if (this._activeTouchId !== null) {
            return;
        }
        const touch = downEvent.changedTouches[0];
        this._activeTouchId = touch.identifier;
        this._lastTouchEventTimeStamp = this._eventTimeStamp(downEvent);
        const rootElement = this._target.ownerDocument.documentElement;
        this._cancelTap = false;
        this._touchMoveExceededManhattanDistance = false;
        this._preventTouchDragProcess = false;
        this._touchMoveStartCoordinate = this._getCoordinate(touch);
        if (this._unsubscribeRootTouchEvents !== null) {
            this._unsubscribeRootTouchEvents();
            this._unsubscribeRootTouchEvents = null;
        }
        {
            const boundTouchMoveWithDownHandler = this._touchMoveHandler.bind(this);
            const boundTouchEndHandler = this._touchEndHandler.bind(this);
            this._unsubscribeRootTouchEvents = () => {
                rootElement.removeEventListener('touchmove', boundTouchMoveWithDownHandler);
                rootElement.removeEventListener('touchend', boundTouchEndHandler);
            };
            rootElement.addEventListener('touchmove', boundTouchMoveWithDownHandler, { passive: false });
            rootElement.addEventListener('touchend', boundTouchEndHandler, { passive: false });
            this._clearLongTapTimeout();
            this._longTapTimeoutId = setTimeout(this._longTapHandler.bind(this, downEvent), 240 /* Delay.LongTap */);
        }
        this._processEvent(this._makeCompatEvent(downEvent, touch), this._handler.touchStartEvent);
        if (this._tapTimeoutId === null) {
            this._tapCount = 0;
            this._tapTimeoutId = setTimeout(this._resetTapTimeout.bind(this), 500 /* Delay.ResetClick */);
            this._tapCoordinate = this._getCoordinate(touch);
        }
    }
    _mouseDownHandler(downEvent) {
        if (downEvent.button === 2 /* MouseEventButton.Right */) {
            this._preventDefault(downEvent);
            this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseRightClickEvent);
            return;
        }
        if (downEvent.button !== 0 /* MouseEventButton.Left */) {
            return;
        }
        const rootElement = this._target.ownerDocument.documentElement;
        if (isFF()) {
            rootElement.addEventListener('mouseleave', this._onFirefoxOutsideMouseUp);
        }
        this._cancelClick = false;
        this._mouseMoveStartCoordinate = this._getCoordinate(downEvent);
        if (this._unsubscribeRootMouseEvents !== null) {
            this._unsubscribeRootMouseEvents();
            this._unsubscribeRootMouseEvents = null;
        }
        {
            const boundMouseMoveWithDownHandler = this._mouseMoveWithDownHandler.bind(this);
            const boundMouseUpHandler = this._mouseUpHandler.bind(this);
            this._unsubscribeRootMouseEvents = () => {
                rootElement.removeEventListener('mousemove', boundMouseMoveWithDownHandler);
                rootElement.removeEventListener('mouseup', boundMouseUpHandler);
            };
            rootElement.addEventListener('mousemove', boundMouseMoveWithDownHandler);
            rootElement.addEventListener('mouseup', boundMouseUpHandler);
        }
        this._mousePressed = true;
        if (this._firesTouchEvents(downEvent)) {
            return;
        }
        this._processEvent(this._makeCompatEvent(downEvent), this._handler.mouseDownEvent);
        if (this._clickTimeoutId === null) {
            this._clickCount = 0;
            this._clickTimeoutId = setTimeout(this._resetClickTimeout.bind(this), 500 /* Delay.ResetClick */);
            this._clickCoordinate = this._getCoordinate(downEvent);
        }
    }
    _init() {
        this._target.addEventListener('mouseenter', this._mouseEnterHandler.bind(this));
        // Do not show context menu when something went wrong
        this._target.addEventListener('touchcancel', this._clearLongTapTimeout.bind(this));
        {
            const doc = this._target.ownerDocument;
            const outsideHandler = (event) => {
                if (this._handler.mouseDownOutsideEvent == null) {
                    return;
                }
                if (event.composed && this._target.contains(event.composedPath()[0])) {
                    return;
                }
                if ((event.target !== null) && this._target.contains(event.target)) {
                    return;
                }
                this._handler.mouseDownOutsideEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });
            };
            this._unsubscribeOutsideTouchEvents = () => {
                doc.removeEventListener('touchstart', outsideHandler);
            };
            this._unsubscribeOutsideMouseEvents = () => {
                doc.removeEventListener('mousedown', outsideHandler);
            };
            doc.addEventListener('mousedown', outsideHandler);
            doc.addEventListener('touchstart', outsideHandler, { passive: true });
        }
        if (isIOS()) {
            this._unsubscribeMobileSafariEvents = () => {
                this._target.removeEventListener('dblclick', this._onMobileSafariDoubleClick);
            };
            this._target.addEventListener('dblclick', this._onMobileSafariDoubleClick);
        }
        this._target.addEventListener('mouseleave', this._mouseLeaveHandler.bind(this));
        this._target.addEventListener('touchstart', this._touchStartHandler.bind(this), { passive: true });
        // prevent scroll by wheel click
        if (!isChrome()) {
            return;
        }
        this._target.addEventListener('mousedown', (e) => {
            if (e.button === 1 /* MouseEventButton.Middle */) {
                // prevent incorrect scrolling event
                e.preventDefault();
                return false;
            }
            return undefined;
        });
        this._target.addEventListener('mousedown', this._mouseDownHandler.bind(this));
        this._initPinch();
        // Hey mobile Safari, what's up?
        // If mobile Safari doesn't have any touchmove handler with passive=false
        // it treats a touchstart and the following touchmove events as cancelable=false,
        // so we can't prevent them (as soon we subscribe on touchmove inside touchstart's handler).
        // And we'll get scroll of the page along with chart's one instead of only chart's scroll.
        this._target.addEventListener('touchmove', () => { }, { passive: false });
    }
    _initPinch() {
        if (this._handler.pinchStartEvent === undefined &&
            this._handler.pinchEvent === undefined &&
            this._handler.pinchEndEvent === undefined) {
            return;
        }
        this._target.addEventListener('touchstart', (event) => this._checkPinchState(event.touches), { passive: true });
        this._target.addEventListener('touchmove', (event) => {
            if (event.touches.length !== 2 || this._startPinchMiddleCoordinate === null) {
                return;
            }
            if (this._handler.pinchEvent !== undefined) {
                const currentDistance = this._getTouchDistance(event.touches[0], event.touches[1]);
                const scale = currentDistance / this._startPinchDistance;
                this._handler.pinchEvent({ ...this._startPinchMiddleCoordinate, pageX: 0, pageY: 0 }, scale);
                this._preventDefault(event);
            }
        }, { passive: false });
        this._target.addEventListener('touchend', (event) => {
            this._checkPinchState(event.touches);
        });
    }
    _checkPinchState(touches) {
        if (touches.length === 1) {
            this._pinchPrevented = false;
        }
        if (touches.length !== 2 || this._pinchPrevented || this._longTapActive) {
            this._stopPinch();
        }
        else {
            this._startPinch(touches);
        }
    }
    _startPinch(touches) {
        var _a;
        const box = (_a = this._target.getBoundingClientRect()) !== null && _a !== void 0 ? _a : { left: 0, top: 0 };
        this._startPinchMiddleCoordinate = {
            x: ((touches[0].clientX - box.left) + (touches[1].clientX - box.left)) / 2,
            y: ((touches[0].clientY - box.top) + (touches[1].clientY - box.top)) / 2
        };
        this._startPinchDistance = this._getTouchDistance(touches[0], touches[1]);
        if (this._handler.pinchStartEvent !== undefined) {
            this._handler.pinchStartEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });
        }
        this._clearLongTapTimeout();
    }
    _stopPinch() {
        if (this._startPinchMiddleCoordinate === null) {
            return;
        }
        this._startPinchMiddleCoordinate = null;
        if (this._handler.pinchEndEvent !== undefined) {
            this._handler.pinchEndEvent({ x: 0, y: 0, pageX: 0, pageY: 0 });
        }
    }
    _mouseLeaveHandler(event) {
        var _a, _b, _c;
        (_a = this._unsubscribeMousemove) === null || _a === void 0 ? void 0 : _a.call(this);
        (_b = this._unsubscribeMouseWheel) === null || _b === void 0 ? void 0 : _b.call(this);
        (_c = this._unsubscribeContextMenu) === null || _c === void 0 ? void 0 : _c.call(this);
        if (this._firesTouchEvents(event)) {
            return;
        }
        if (!this._acceptMouseLeave) {
            // mobile Safari sometimes emits mouse leave event for no reason, there is no way to handle it in other way
            // just ignore this event if there was no mouse move or mouse enter events
            return;
        }
        this._processEvent(this._makeCompatEvent(event), this._handler.mouseLeaveEvent);
        // accept all mouse leave events if it's not an iOS device
        this._acceptMouseLeave = !isIOS();
    }
    _longTapHandler(event) {
        const touch = this._touchWithId(event.touches, this._activeTouchId);
        if (touch === null) {
            return;
        }
        this._processEvent(this._makeCompatEvent(event, touch), this._handler.longTapEvent);
        this._cancelTap = true;
        // long tap is active until touchend event with 0 touches occurred
        this._longTapActive = true;
    }
    _firesTouchEvents(e) {
        var _a;
        // @ts-expect-error
        if (((_a = e.sourceCapabilities) === null || _a === void 0 ? void 0 : _a.firesTouchEvents) !== undefined) {
            // @ts-expect-error
            return e.sourceCapabilities.firesTouchEvents;
        }
        return this._eventTimeStamp(e) < this._lastTouchEventTimeStamp + 500 /* Delay.PreventFiresTouchEvents */;
    }
    _processEvent(event, callback) {
        callback === null || callback === void 0 ? void 0 : callback.call(this._handler, event);
    }
    _makeCompatEvent(event, touch) {
        var _a;
        // TouchEvent has no clientX/Y coordinates:
        // We have to use the last Touch instead
        const eventLike = touch !== null && touch !== void 0 ? touch : event;
        const box = (_a = this._target.getBoundingClientRect()) !== null && _a !== void 0 ? _a : { left: 0, top: 0 };
        return {
            x: eventLike.clientX - box.left,
            y: eventLike.clientY - box.top,
            pageX: eventLike.pageX,
            pageY: eventLike.pageY,
            isTouch: !event.type.startsWith('mouse') && event.type !== 'contextmenu' && event.type !== 'click',
            preventDefault: () => {
                if (event.type !== 'touchstart') {
                    // touchstart is passive and cannot be prevented
                    this._preventDefault(event);
                }
            }
        };
    }
    _getTouchDistance(p1, p2) {
        const xDiff = p1.clientX - p2.clientX;
        const yDiff = p1.clientY - p2.clientY;
        return Math.sqrt(xDiff * xDiff + yDiff * yDiff);
    }
    _preventDefault(event) {
        if (event.cancelable) {
            event.preventDefault();
        }
    }
    _getCoordinate(eventLike) {
        return {
            x: eventLike.pageX,
            y: eventLike.pageY
        };
    }
    _eventTimeStamp(e) {
        var _a;
        // for some reason e.timestamp is always 0 on iPad with magic mouse, so we use performance.now() as a fallback
        return (_a = e.timeStamp) !== null && _a !== void 0 ? _a : performance.now();
    }
    _touchWithId(touches, id) {
        for (let i = 0; i < touches.length; ++i) {
            if (touches[i].identifier === id) {
                return touches[i];
            }
        }
        return null;
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChartEvent {
    constructor(container, chart) {
        // 惯性滚动开始时间
        this._flingStartTime = new Date().getTime();
        // 惯性滚动定时器
        this._flingScrollTimerId = null;
        // 开始滚动时坐标点
        this._startScrollCoordinate = null;
        // 开始触摸时坐标
        this._touchCoordinate = null;
        // 是否是取消了十字光标
        this._touchCancelCrosshair = false;
        // 是否缩放过
        this._touchZoomed = false;
        // 用来记录捏合缩放的尺寸
        this._pinchScale = 1;
        this._mouseDownWidget = null;
        this._prevYAxisExtremum = null;
        this._xAxisStartScaleCoordinate = null;
        this._xAxisStartScaleDistance = 0;
        this._xAxisScale = 1;
        this._yAxisStartScaleDistance = 0;
        this._mouseMoveTriggerWidgetInfo = { pane: null, widget: null };
        this._boundKeyBoardDownEvent = (event) => {
            if (event.shiftKey) {
                switch (event.code) {
                    case 'Equal': {
                        this._chart.getChartStore().getTimeScaleStore().zoom(0.5);
                        break;
                    }
                    case 'Minus': {
                        this._chart.getChartStore().getTimeScaleStore().zoom(-0.5);
                        break;
                    }
                    case 'ArrowLeft': {
                        const timeScaleStore = this._chart.getChartStore().getTimeScaleStore();
                        timeScaleStore.startScroll();
                        timeScaleStore.scroll(-3 * timeScaleStore.getBarSpace().bar);
                        break;
                    }
                    case 'ArrowRight': {
                        const timeScaleStore = this._chart.getChartStore().getTimeScaleStore();
                        timeScaleStore.startScroll();
                        timeScaleStore.scroll(3 * timeScaleStore.getBarSpace().bar);
                        break;
                    }
                }
            }
        };
        this._container = container;
        this._chart = chart;
        this._event = new SyntheticEvent(container, this, {
            treatVertDragAsPageScroll: () => false,
            treatHorzDragAsPageScroll: () => false
        });
        container.addEventListener('keydown', this._boundKeyBoardDownEvent);
    }
    pinchStartEvent() {
        this._touchZoomed = true;
        this._pinchScale = 1;
        return true;
    }
    pinchEvent(e, scale) {
        const { pane, widget } = this._findWidgetByEvent(e);
        if ((pane === null || pane === void 0 ? void 0 : pane.getId()) !== PaneIdConstants.XAXIS && (widget === null || widget === void 0 ? void 0 : widget.getName()) === WidgetNameConstants.MAIN) {
            const event = this._makeWidgetEvent(e, widget);
            const zoomScale = (scale - this._pinchScale) * 5;
            this._pinchScale = scale;
            this._chart.getChartStore().getTimeScaleStore().zoom(zoomScale, { x: event.x, y: event.y });
            return true;
        }
        return false;
    }
    mouseWheelHortEvent(e, distance) {
        const timeScaleStore = this._chart.getChartStore().getTimeScaleStore();
        timeScaleStore.startScroll();
        timeScaleStore.scroll(distance);
        return true;
    }
    mouseWheelVertEvent(e, scale) {
        var _a, _b;
        const { widget } = this._findWidgetByEvent(e);
        const isTouch = (_a = e.isTouch) !== null && _a !== void 0 ? _a : false;
        const event = this._makeWidgetEvent(e, widget);
        let zoomCoordinate = null;
        const name = widget === null || widget === void 0 ? void 0 : widget.getName();
        if (isTouch) {
            if (name === WidgetNameConstants.MAIN || name === WidgetNameConstants.XAXIS) {
                zoomCoordinate = { x: event.x, y: event.y };
            }
            else {
                const bounding = (_b = this._chart.getPaneById(PaneIdConstants.CANDLE)) === null || _b === void 0 ? void 0 : _b.getBounding();
                zoomCoordinate = { x: bounding.width / 2, y: bounding.height / 2 };
            }
        }
        else {
            if (name === WidgetNameConstants.MAIN) {
                zoomCoordinate = { x: event.x, y: event.y };
            }
        }
        if (zoomCoordinate !== null) {
            this._chart.getChartStore().getTimeScaleStore().zoom(scale, { x: event.x, y: event.y });
            return true;
        }
        return false;
    }
    mouseDownEvent(e) {
        var _a, _b;
        const { pane, widget } = this._findWidgetByEvent(e);
        this._mouseDownWidget = widget;
        if (widget !== null) {
            const event = this._makeWidgetEvent(e, widget);
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.SEPARATOR: {
                    return widget.dispatchEvent('mouseDownEvent', event);
                }
                case WidgetNameConstants.MAIN: {
                    const extremum = (_a = pane === null || pane === void 0 ? void 0 : pane.getAxisComponent().getExtremum()) !== null && _a !== void 0 ? _a : null;
                    this._prevYAxisExtremum = extremum === null ? extremum : { ...extremum };
                    this._startScrollCoordinate = { x: event.x, y: event.y };
                    this._chart.getChartStore().getTimeScaleStore().startScroll();
                    return widget.dispatchEvent('mouseDownEvent', event);
                }
                case WidgetNameConstants.XAXIS: {
                    const consumed = widget.dispatchEvent('mouseDownEvent', event);
                    if (consumed) {
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                    }
                    this._xAxisStartScaleCoordinate = { x: event.x, y: event.y };
                    this._xAxisStartScaleDistance = event.pageX;
                    return consumed;
                }
                case WidgetNameConstants.YAXIS: {
                    const consumed = widget.dispatchEvent('mouseDownEvent', event);
                    if (consumed) {
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                    }
                    const extremum = (_b = pane === null || pane === void 0 ? void 0 : pane.getAxisComponent().getExtremum()) !== null && _b !== void 0 ? _b : null;
                    this._prevYAxisExtremum = extremum === null ? extremum : { ...extremum };
                    this._yAxisStartScaleDistance = event.pageY;
                    return consumed;
                }
            }
        }
        return false;
    }
    mouseMoveEvent(e) {
        var _a, _b, _c;
        const { pane, widget } = this._findWidgetByEvent(e);
        const event = this._makeWidgetEvent(e, widget);
        if (((_a = this._mouseMoveTriggerWidgetInfo.pane) === null || _a === void 0 ? void 0 : _a.getId()) !== (pane === null || pane === void 0 ? void 0 : pane.getId()) ||
            ((_b = this._mouseMoveTriggerWidgetInfo.widget) === null || _b === void 0 ? void 0 : _b.getName()) !== (widget === null || widget === void 0 ? void 0 : widget.getName())) {
            widget === null || widget === void 0 ? void 0 : widget.dispatchEvent('mouseEnterEvent', event);
            (_c = this._mouseMoveTriggerWidgetInfo.widget) === null || _c === void 0 ? void 0 : _c.dispatchEvent('mouseLeaveEvent', event);
            this._mouseMoveTriggerWidgetInfo = { pane, widget };
        }
        if (widget !== null) {
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.MAIN: {
                    this._chart.getChartStore().getCrosshairStore().set({ x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
                    return widget.dispatchEvent('mouseMoveEvent', event);
                }
                case WidgetNameConstants.SEPARATOR:
                case WidgetNameConstants.XAXIS:
                case WidgetNameConstants.YAXIS: {
                    const consumed = widget.dispatchEvent('mouseMoveEvent', event);
                    this._chart.getChartStore().getCrosshairStore().set();
                    return consumed;
                }
            }
        }
        return false;
    }
    pressedMouseMoveEvent(e) {
        var _a, _b, _c, _d;
        if (this._mouseDownWidget !== null && this._mouseDownWidget.getName() === WidgetNameConstants.SEPARATOR) {
            return this._mouseDownWidget.dispatchEvent('pressedMouseMoveEvent', e);
        }
        const { pane, widget } = this._findWidgetByEvent(e);
        if (widget !== null &&
            ((_a = this._mouseDownWidget) === null || _a === void 0 ? void 0 : _a.getPane().getId()) === (pane === null || pane === void 0 ? void 0 : pane.getId()) &&
            ((_b = this._mouseDownWidget) === null || _b === void 0 ? void 0 : _b.getName()) === widget.getName()) {
            const event = this._makeWidgetEvent(e, widget);
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.MAIN: {
                    const bounding = widget.getBounding();
                    const consumed = widget.dispatchEvent('pressedMouseMoveEvent', event);
                    if (!consumed && this._startScrollCoordinate !== null) {
                        const yAxis = pane === null || pane === void 0 ? void 0 : pane.getAxisComponent();
                        if (this._prevYAxisExtremum !== null && !yAxis.getAutoCalcTickFlag()) {
                            const { min, max, range } = this._prevYAxisExtremum;
                            let distance;
                            if ((_c = yAxis === null || yAxis === void 0 ? void 0 : yAxis.isReverse()) !== null && _c !== void 0 ? _c : false) {
                                distance = this._startScrollCoordinate.y - event.y;
                            }
                            else {
                                distance = event.y - this._startScrollCoordinate.y;
                            }
                            const scale = distance / bounding.height;
                            const difRange = range * scale;
                            const newMin = min + difRange;
                            const newMax = max + difRange;
                            const newRealMin = yAxis.convertToRealValue(newMin);
                            const newRealMax = yAxis.convertToRealValue(newMax);
                            yAxis.setExtremum({
                                min: newMin,
                                max: newMax,
                                range: newMax - newMin,
                                realMin: newRealMin,
                                realMax: newRealMax,
                                realRange: newRealMax - newRealMin
                            });
                        }
                        const distance = event.x - this._startScrollCoordinate.x;
                        this._chart.getChartStore().getTimeScaleStore().scroll(distance);
                    }
                    this._chart.getChartStore().getCrosshairStore().set({ x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
                    return consumed;
                }
                case WidgetNameConstants.XAXIS: {
                    const consumed = widget.dispatchEvent('pressedMouseMoveEvent', event);
                    if (!consumed) {
                        const scale = this._xAxisStartScaleDistance / event.pageX;
                        const zoomScale = (scale - this._xAxisScale) * 10;
                        this._xAxisScale = scale;
                        this._chart.getChartStore().getTimeScaleStore().zoom(zoomScale, (_d = this._xAxisStartScaleCoordinate) !== null && _d !== void 0 ? _d : undefined);
                    }
                    else {
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                    }
                    return consumed;
                }
                case WidgetNameConstants.YAXIS: {
                    const consumed = widget.dispatchEvent('pressedMouseMoveEvent', event);
                    if (!consumed) {
                        if (this._prevYAxisExtremum !== null) {
                            const { min, max, range } = this._prevYAxisExtremum;
                            const scale = event.pageY / this._yAxisStartScaleDistance;
                            const newRange = range * scale;
                            const difRange = (newRange - range) / 2;
                            const newMin = min - difRange;
                            const newMax = max + difRange;
                            const yAxis = pane === null || pane === void 0 ? void 0 : pane.getAxisComponent();
                            const newRealMin = yAxis.convertToRealValue(newMin);
                            const newRealMax = yAxis.convertToRealValue(newMax);
                            yAxis.setExtremum({
                                min: newMin,
                                max: newMax,
                                range: newRange,
                                realMin: newRealMin,
                                realMax: newRealMax,
                                realRange: newRealMax - newRealMin
                            });
                            this._chart.adjustPaneViewport(false, true, true, true);
                        }
                    }
                    else {
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                    }
                    return consumed;
                }
            }
        }
        return false;
    }
    mouseUpEvent(e) {
        const { widget } = this._findWidgetByEvent(e);
        let consumed = false;
        if (widget !== null) {
            const event = this._makeWidgetEvent(e, widget);
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.MAIN:
                case WidgetNameConstants.SEPARATOR:
                case WidgetNameConstants.XAXIS:
                case WidgetNameConstants.YAXIS: {
                    consumed = widget.dispatchEvent('mouseUpEvent', event);
                    break;
                }
            }
            if (consumed) {
                this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
            }
        }
        this._mouseDownWidget = null;
        this._startScrollCoordinate = null;
        this._prevYAxisExtremum = null;
        this._xAxisStartScaleCoordinate = null;
        this._xAxisStartScaleDistance = 0;
        this._xAxisScale = 1;
        this._yAxisStartScaleDistance = 0;
        return consumed;
    }
    mouseRightClickEvent(e) {
        const { widget } = this._findWidgetByEvent(e);
        let consumed = false;
        if (widget !== null) {
            const event = this._makeWidgetEvent(e, widget);
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.MAIN:
                case WidgetNameConstants.XAXIS:
                case WidgetNameConstants.YAXIS: {
                    consumed = widget.dispatchEvent('mouseRightClickEvent', event);
                    break;
                }
            }
            if (consumed) {
                this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
            }
        }
        return false;
    }
    mouseDoubleClickEvent(e) {
        const { pane, widget } = this._findWidgetByEvent(e);
        if (widget !== null && widget.getName() === WidgetNameConstants.YAXIS) {
            const yAxis = pane === null || pane === void 0 ? void 0 : pane.getAxisComponent();
            if (!yAxis.getAutoCalcTickFlag()) {
                yAxis.setAutoCalcTickFlag(true);
                this._chart.adjustPaneViewport(false, true, true, true);
                return true;
            }
        }
        return false;
    }
    mouseLeaveEvent() {
        this._chart.getChartStore().getCrosshairStore().set();
        return true;
    }
    touchStartEvent(e) {
        const { pane, widget } = this._findWidgetByEvent(e);
        if (widget !== null) {
            const event = this._makeWidgetEvent(e, widget);
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.MAIN: {
                    const chartStore = this._chart.getChartStore();
                    const crosshairStore = chartStore.getCrosshairStore();
                    if (widget.dispatchEvent('mouseDownEvent', event)) {
                        this._touchCancelCrosshair = true;
                        this._touchCoordinate = null;
                        crosshairStore.set(undefined, true);
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                        return true;
                    }
                    if (this._flingScrollTimerId !== null) {
                        clearTimeout(this._flingScrollTimerId);
                        this._flingScrollTimerId = null;
                    }
                    this._flingStartTime = new Date().getTime();
                    this._startScrollCoordinate = { x: event.x, y: event.y };
                    chartStore.getTimeScaleStore().startScroll();
                    this._touchZoomed = false;
                    if (this._touchCoordinate !== null) {
                        const xDif = event.x - this._touchCoordinate.x;
                        const yDif = event.y - this._touchCoordinate.y;
                        const radius = Math.sqrt(xDif * xDif + yDif * yDif);
                        if (radius < TOUCH_MIN_RADIUS) {
                            this._touchCoordinate = { x: event.x, y: event.y };
                            crosshairStore.set({ x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
                        }
                        else {
                            this._touchCancelCrosshair = true;
                            this._touchCoordinate = null;
                            crosshairStore.set();
                        }
                    }
                    else {
                        this._touchCancelCrosshair = false;
                    }
                    return true;
                }
                case WidgetNameConstants.XAXIS:
                case WidgetNameConstants.YAXIS: {
                    const consumed = widget.dispatchEvent('mouseDownEvent', event);
                    if (consumed) {
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                    }
                    return consumed;
                }
            }
        }
        return false;
    }
    touchMoveEvent(e) {
        var _a, _b, _c;
        const { pane, widget } = this._findWidgetByEvent(e);
        if (widget !== null) {
            const event = this._makeWidgetEvent(e, widget);
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.MAIN: {
                    if (widget.dispatchEvent('pressedMouseMoveEvent', event)) {
                        (_a = event.preventDefault) === null || _a === void 0 ? void 0 : _a.call(event);
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                        return true;
                    }
                    const chartStore = this._chart.getChartStore();
                    if (this._touchCoordinate !== null) {
                        (_b = event.preventDefault) === null || _b === void 0 ? void 0 : _b.call(event);
                        chartStore.getCrosshairStore().set({ x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
                    }
                    else {
                        if (this._startScrollCoordinate !== null &&
                            Math.abs(this._startScrollCoordinate.x - event.x) > this._startScrollCoordinate.y - event.y) {
                            const distance = event.x - this._startScrollCoordinate.x;
                            chartStore.getTimeScaleStore().scroll(distance);
                        }
                    }
                    return true;
                }
                case WidgetNameConstants.XAXIS:
                case WidgetNameConstants.YAXIS: {
                    const consumed = widget.dispatchEvent('pressedMouseMoveEvent', event);
                    if (consumed) {
                        (_c = event.preventDefault) === null || _c === void 0 ? void 0 : _c.call(event);
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                    }
                    return consumed;
                }
            }
        }
        return false;
    }
    touchEndEvent(e) {
        const { widget } = this._findWidgetByEvent(e);
        if (widget !== null) {
            const event = this._makeWidgetEvent(e, widget);
            const name = widget.getName();
            switch (name) {
                case WidgetNameConstants.MAIN: {
                    widget.dispatchEvent('mouseUpEvent', event);
                    if (this._startScrollCoordinate !== null) {
                        const time = new Date().getTime() - this._flingStartTime;
                        const distance = event.x - this._startScrollCoordinate.x;
                        let v = distance / (time > 0 ? time : 1) * 20;
                        if (time < 200 && Math.abs(v) > 0) {
                            const timeScaleStore = this._chart.getChartStore().getTimeScaleStore();
                            const flingScroll = () => {
                                this._flingScrollTimerId = setTimeout(() => {
                                    timeScaleStore.startScroll();
                                    timeScaleStore.scroll(v);
                                    v = v * (1 - 0.025);
                                    if (Math.abs(v) < 1) {
                                        if (this._flingScrollTimerId !== null) {
                                            clearTimeout(this._flingScrollTimerId);
                                            this._flingScrollTimerId = null;
                                        }
                                    }
                                    else {
                                        flingScroll();
                                    }
                                }, 20);
                            };
                            flingScroll();
                        }
                    }
                    return true;
                }
                case WidgetNameConstants.XAXIS:
                case WidgetNameConstants.YAXIS: {
                    const consumed = widget.dispatchEvent('mouseUpEvent', event);
                    if (consumed) {
                        this._chart.updatePane(1 /* UpdateLevel.OVERLAY */);
                    }
                }
            }
        }
        return false;
    }
    tapEvent(e) {
        const { pane, widget } = this._findWidgetByEvent(e);
        if (widget !== null && widget.getName() === WidgetNameConstants.MAIN && this._touchCoordinate === null && !this._touchCancelCrosshair && !this._touchZoomed) {
            const event = this._makeWidgetEvent(e, widget);
            this._touchCoordinate = { x: event.x, y: event.y };
            this._chart.getChartStore().getCrosshairStore().set({ x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
            return true;
        }
        return false;
    }
    longTapEvent(e) {
        const { pane, widget } = this._findWidgetByEvent(e);
        if (widget !== null && widget.getName() === WidgetNameConstants.MAIN) {
            const event = this._makeWidgetEvent(e, widget);
            this._touchCoordinate = { x: event.x, y: event.y };
            this._chart.getChartStore().getCrosshairStore().set({ x: event.x, y: event.y, paneId: pane === null || pane === void 0 ? void 0 : pane.getId() });
            return true;
        }
        return false;
    }
    _findWidgetByEvent(event) {
        const panes = this._chart.getAllPanes();
        const { x, y } = event;
        let pane = null;
        for (const [, p] of panes) {
            const bounding = p.getBounding();
            if (x >= bounding.left && x <= bounding.left + bounding.width &&
                y >= bounding.top && y <= bounding.top + bounding.height) {
                pane = p;
                break;
            }
        }
        if (pane === null) {
            pane = this._chart.getPaneById(PaneIdConstants.XAXIS);
        }
        let widget = null;
        if (pane !== null) {
            const separatorWidget = pane.getSeparatorWidget();
            if (separatorWidget !== null) {
                const separatorBounding = separatorWidget.getBounding();
                if (x >= separatorBounding.left && x <= separatorBounding.left + separatorBounding.width &&
                    y >= separatorBounding.top && y <= separatorBounding.top + REAL_SEPARATOR_HEIGHT) {
                    widget = separatorWidget;
                }
            }
            if (widget === null) {
                const mainWidget = pane.getMainWidget();
                const mainBounding = mainWidget.getBounding();
                if (x >= mainBounding.left && x <= mainBounding.left + mainBounding.width &&
                    y >= mainBounding.top && y <= mainBounding.top + mainBounding.height) {
                    widget = mainWidget;
                }
            }
            if (widget === null) {
                const yAxisWidget = pane.getYAxisWidget();
                if (yAxisWidget !== null) {
                    const yAxisBounding = yAxisWidget.getBounding();
                    if (x >= yAxisBounding.left && x <= yAxisBounding.left + yAxisBounding.width &&
                        y >= yAxisBounding.top && y <= yAxisBounding.top + yAxisBounding.height) {
                        widget = yAxisWidget;
                    }
                }
            }
        }
        return { pane, widget };
    }
    _makeWidgetEvent(event, widget) {
        var _a, _b, _c;
        const bounding = (_a = widget === null || widget === void 0 ? void 0 : widget.getBounding()) !== null && _a !== void 0 ? _a : null;
        return {
            ...event,
            x: event.x - ((_b = bounding === null || bounding === void 0 ? void 0 : bounding.left) !== null && _b !== void 0 ? _b : 0),
            y: event.y - ((_c = bounding === null || bounding === void 0 ? void 0 : bounding.top) !== null && _c !== void 0 ? _c : 0)
        };
    }
    destroy() {
        this._container.removeEventListener('keydown', this._boundKeyBoardDownEvent);
        this._event.destroy();
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChartImp {
    constructor(container, options) {
        this._panes = new Map();
        this._initContainer(container);
        this._chartEvent = new ChartEvent(this._chartContainer, this);
        this._chartStore = new ChartStore(this, options);
        this._xAxisPane = new XAxisPane(this._chartContainer, this, PaneIdConstants.XAXIS);
        this._panes.set(PaneIdConstants.CANDLE, new CandlePane(this._chartContainer, this, PaneIdConstants.CANDLE));
        this.adjustPaneViewport(true, true, true);
    }
    _initContainer(container) {
        this._container = container;
        this._chartContainer = createDom('div', {
            position: 'relative',
            width: '100%',
            outline: 'none',
            borderStyle: 'none',
            cursor: 'crosshair',
            boxSizing: 'border-box',
            userSelect: 'none',
            webkitUserSelect: 'none',
            // @ts-expect-error
            msUserSelect: 'none',
            MozUserSelect: 'none',
            webkitTapHighlightColor: 'transparent'
        });
        this._chartContainer.tabIndex = 1;
        container.appendChild(this._chartContainer);
    }
    _measurePaneHeight() {
        var _a;
        const totalHeight = this._container.offsetHeight;
        const xAxisHeight = this._xAxisPane.getAxisComponent().getAutoSize();
        let paneExcludeXAxisHeight = totalHeight - xAxisHeight;
        if (paneExcludeXAxisHeight < 0) {
            paneExcludeXAxisHeight = 0;
        }
        let indicatorPaneTotalHeight = 0;
        this._panes.forEach(pane => {
            if (pane.getId() !== PaneIdConstants.CANDLE) {
                let paneHeight = pane.getBounding().height;
                const paneMinHeight = pane.getOptions().minHeight;
                if (paneHeight < paneMinHeight) {
                    paneHeight = paneMinHeight;
                }
                if (indicatorPaneTotalHeight + paneHeight > paneExcludeXAxisHeight) {
                    indicatorPaneTotalHeight = paneExcludeXAxisHeight;
                    paneHeight = Math.max(paneExcludeXAxisHeight - indicatorPaneTotalHeight, 0);
                }
                else {
                    indicatorPaneTotalHeight += paneHeight;
                }
                pane.setBounding({ height: paneHeight });
            }
        });
        const candlePaneHeight = paneExcludeXAxisHeight - indicatorPaneTotalHeight;
        (_a = this._panes.get(PaneIdConstants.CANDLE)) === null || _a === void 0 ? void 0 : _a.setBounding({ height: candlePaneHeight });
        let top = 0;
        this._panes.forEach(pane => {
            pane.setBounding({ top });
            top += pane.getBounding().height;
        });
        this._xAxisPane.setBounding({ height: xAxisHeight, top });
    }
    _measurePaneWidth() {
        const styles = this._chartStore.getStyles();
        const yAxisStyles = styles.yAxis;
        const isYAxisLeft = yAxisStyles.position === "left" /* YAxisPosition.LEFT */;
        const isOutside = !yAxisStyles.inside;
        const totolWidth = this._container.offsetWidth;
        let mainWidth = 0;
        let yAxisWidth = Number.MIN_SAFE_INTEGER;
        let yAxisLeft = 0;
        let mainLeft = 0;
        this._panes.forEach(pane => {
            yAxisWidth = Math.max(yAxisWidth, pane.getAxisComponent().getAutoSize());
        });
        if (yAxisWidth > totolWidth) {
            yAxisWidth = totolWidth;
        }
        if (isOutside) {
            mainWidth = totolWidth - yAxisWidth;
            if (isYAxisLeft) {
                yAxisLeft = 0;
                mainLeft = yAxisWidth;
            }
            else {
                yAxisLeft = totolWidth - yAxisWidth;
                mainLeft = 0;
            }
        }
        else {
            mainWidth = totolWidth;
            mainLeft = 0;
            if (isYAxisLeft) {
                yAxisLeft = 0;
            }
            else {
                yAxisLeft = totolWidth - yAxisWidth;
            }
        }
        this._chartStore.getTimeScaleStore().setTotalBarSpace(mainWidth);
        const paneBounding = { width: totolWidth };
        const mainBounding = { width: mainWidth, left: mainLeft };
        const yAxisBounding = { width: yAxisWidth, left: yAxisLeft };
        this._panes.forEach((pane) => {
            pane.setBounding(paneBounding, mainBounding, yAxisBounding);
        });
        this._xAxisPane.setBounding(paneBounding, mainBounding, yAxisBounding);
    }
    _setPaneOptions(options, forceShouldAdjust) {
        var _a, _b;
        const pane = this._panes.get((_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : '');
        let shouldMeasureHeight = false;
        if (pane !== undefined) {
            let shouldAdjust = forceShouldAdjust;
            if (options.id !== PaneIdConstants.CANDLE && options.height !== undefined && options.height > 0) {
                const minHeight = Math.max((_b = options.minHeight) !== null && _b !== void 0 ? _b : pane.getOptions().minHeight, 0);
                const height = Math.max(minHeight, options.height);
                pane.setBounding({ height });
                shouldAdjust = true;
                shouldMeasureHeight = true;
            }
            pane.setOptions(options);
            if (shouldAdjust) {
                this.adjustPaneViewport(shouldMeasureHeight, true, true, true, true);
            }
        }
    }
    getContainer() { return this._container; }
    getChartStore() { return this._chartStore; }
    getAllPanes() { return this._panes; }
    adjustPaneViewport(shouldMeasureHeight, shouldMeasureWidth, shouldUpdate, shouldAdjustYAxis, shouldForceAdjustYAxis) {
        if (shouldMeasureHeight) {
            this._measurePaneHeight();
        }
        let forceMeasureWidth = shouldMeasureWidth;
        const adjustYAxis = shouldAdjustYAxis !== null && shouldAdjustYAxis !== void 0 ? shouldAdjustYAxis : false;
        const forceAdjustYAxis = shouldForceAdjustYAxis !== null && shouldForceAdjustYAxis !== void 0 ? shouldForceAdjustYAxis : false;
        if (adjustYAxis || forceAdjustYAxis) {
            this._panes.forEach(pane => {
                const adjust = pane.getAxisComponent().buildTicks(forceAdjustYAxis);
                if (!forceMeasureWidth) {
                    forceMeasureWidth = adjust;
                }
            });
        }
        if (forceMeasureWidth) {
            this._measurePaneWidth();
        }
        if (shouldUpdate !== null && shouldUpdate !== void 0 ? shouldUpdate : false) {
            this._xAxisPane.getAxisComponent().buildTicks(true);
            this.updatePane(4 /* UpdateLevel.ALL */);
        }
    }
    updatePane(level, paneId) {
        var _a;
        if (paneId !== undefined) {
            (_a = this.getPaneById(paneId)) === null || _a === void 0 ? void 0 : _a.update(level);
        }
        else {
            this._xAxisPane.update(level);
            this._panes.forEach(pane => {
                pane.update(level);
            });
        }
    }
    getPaneById(paneId) {
        var _a;
        if (paneId === PaneIdConstants.XAXIS) {
            return this._xAxisPane;
        }
        return (_a = this._panes.get(paneId)) !== null && _a !== void 0 ? _a : null;
    }
    crosshairChange(crosshair) {
        const actionStore = this._chartStore.getActionStore();
        if (actionStore.has("onCrosshairChange" /* ActionType.onCrosshairChange */)) {
            const indicatorData = {};
            this._panes.forEach((_, id) => {
                const paneIndicatorData = {};
                const indicators = this._chartStore.getIndicatorStore().getInstances(id);
                indicators.forEach(indicator => {
                    var _a;
                    const result = indicator.result;
                    paneIndicatorData[indicator.name] = result[(_a = crosshair.dataIndex) !== null && _a !== void 0 ? _a : result.length - 1];
                });
                indicatorData[id] = paneIndicatorData;
            });
            if (crosshair.paneId !== undefined) {
                actionStore.execute("onCrosshairChange" /* ActionType.onCrosshairChange */, {
                    ...crosshair,
                    indicatorData
                });
            }
        }
    }
    getDom(paneId, position) {
        var _a, _b;
        if (paneId !== undefined) {
            const pane = this.getPaneById(paneId);
            if (pane !== null) {
                const pos = position !== null && position !== void 0 ? position : "root" /* DomPosition.ROOT */;
                switch (pos) {
                    case "root" /* DomPosition.ROOT */: {
                        return pane.getContainer();
                    }
                    case "main" /* DomPosition.MAIN */: {
                        return pane.getMainWidget().getContainer();
                    }
                    case "yAxis" /* DomPosition.YAXIS */: {
                        return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getContainer()) !== null && _b !== void 0 ? _b : null;
                    }
                }
            }
        }
        else {
            return this._chartContainer;
        }
        return null;
    }
    getSize(paneId, position) {
        var _a, _b;
        if (paneId !== undefined) {
            const pane = this.getPaneById(paneId);
            if (pane !== null) {
                const pos = position !== null && position !== void 0 ? position : "root" /* DomPosition.ROOT */;
                switch (pos) {
                    case "root" /* DomPosition.ROOT */: {
                        return pane.getBounding();
                    }
                    case "main" /* DomPosition.MAIN */: {
                        return pane.getMainWidget().getBounding();
                    }
                    case "yAxis" /* DomPosition.YAXIS */: {
                        return (_b = (_a = pane.getYAxisWidget()) === null || _a === void 0 ? void 0 : _a.getBounding()) !== null && _b !== void 0 ? _b : null;
                    }
                }
            }
        }
        else {
            return {
                width: this._chartContainer.offsetWidth,
                height: this._chartContainer.offsetHeight,
                left: 0,
                top: 0,
                right: 0,
                bottom: 0
            };
        }
        return null;
    }
    setStyles(styles) {
        var _a, _b;
        this._chartStore.setOptions({ styles });
        let realStyles;
        if (isString(styles)) {
            realStyles = getStyles(styles);
        }
        else {
            realStyles = styles;
        }
        if (((_a = realStyles === null || realStyles === void 0 ? void 0 : realStyles.yAxis) === null || _a === void 0 ? void 0 : _a.type) !== undefined) {
            (_b = this.getPaneById(PaneIdConstants.CANDLE)) === null || _b === void 0 ? void 0 : _b.getAxisComponent().setAutoCalcTickFlag(true);
        }
        this.adjustPaneViewport(true, true, true, true, true);
    }
    getStyles() {
        return this._chartStore.getStyles();
    }
    setLocale(locale) {
        this._chartStore.setOptions({ locale });
        this.adjustPaneViewport(true, true, true, true, true);
    }
    getLocale() {
        return this._chartStore.getLocale();
    }
    setCustomApi(customApi) {
        this._chartStore.setOptions({ customApi });
        this.adjustPaneViewport(true, true, true, true, true);
    }
    setPriceVolumePrecision(pricePrecision, volumePrecision) {
        this._chartStore.setPrecision({ price: pricePrecision, volume: volumePrecision });
    }
    getPriceVolumePrecision() {
        return this._chartStore.getPrecision();
    }
    setTimezone(timezone) {
        this._chartStore.setOptions({ timezone });
        this._xAxisPane.getAxisComponent().buildTicks(true);
        this._xAxisPane.update(3 /* UpdateLevel.DRAWER */);
    }
    getTimezone() {
        return this._chartStore.getTimeScaleStore().getTimezone();
    }
    setOffsetRightDistance(space) {
        this._chartStore.getTimeScaleStore().setOffsetRightDistance(space, true);
    }
    setLeftMinVisibleBarCount(barCount) {
        if (barCount > 0) {
            this._chartStore.getTimeScaleStore().setLeftMinVisibleBarCount(Math.ceil(barCount));
        }
        else {
            logWarn('setLeftMinVisibleBarCount', 'barCount', 'barCount must greater than zero!!!');
        }
    }
    setRightMinVisibleBarCount(barCount) {
        if (barCount > 0) {
            this._chartStore.getTimeScaleStore().setRightMinVisibleBarCount(Math.ceil(barCount));
        }
        else {
            logWarn('setRightMinVisibleBarCount', 'barCount', 'barCount must be a number and greater than zero!!!');
        }
    }
    setBarSpace(space) {
        this._chartStore.getTimeScaleStore().setBarSpace(space);
    }
    getBarSpace() {
        return this._chartStore.getTimeScaleStore().getBarSpace().bar;
    }
    getVisibleRange() {
        return this._chartStore.getTimeScaleStore().getVisibleRange();
    }
    clearData() {
        this._chartStore.clearDataList();
    }
    getDataList() {
        return this._chartStore.getDataList();
    }
    applyNewData(dataList, more) {
        this._chartStore.clearDataList();
        this.applyMoreData(dataList, more);
    }
    applyMoreData(dataList, more) {
        this._chartStore.addData(dataList, 0, more);
        this._chartStore.getIndicatorStore().calcInstance().then(result => {
            if (result.length === 0 || result.includes(true)) {
                this.adjustPaneViewport(false, true, true, true);
            }
        }).catch(_ => { });
    }
    updateData(data) {
        const dataList = this._chartStore.getDataList();
        const dataCount = dataList.length;
        // Determine where individual data should be added
        const timestamp = data.timestamp;
        const lastDataTimestamp = formatValue(dataList[dataCount - 1], 'timestamp', 0);
        if (timestamp >= lastDataTimestamp) {
            let pos = dataCount;
            if (timestamp === lastDataTimestamp) {
                pos = dataCount - 1;
            }
            this._chartStore.addData(data, pos);
            this._chartStore.getIndicatorStore().calcInstance().then(result => {
                if (result.length === 0 || result.includes(true)) {
                    this.adjustPaneViewport(false, true, true, true);
                }
            }).catch(_ => { });
        }
    }
    loadMore(cb) {
        this._chartStore.getTimeScaleStore().setLoadMoreCallback(cb);
    }
    createIndicator(value, isStack, paneOptions, callback) {
        var _a, _b;
        const indicator = isString(value) ? { name: value } : value;
        if (getIndicatorClass(indicator.name) === null) {
            logWarn('createIndicator', 'value', 'indicator not supported, you may need to use registerIndicator to add one!!!');
            return null;
        }
        let paneId;
        if ((paneOptions === null || paneOptions === void 0 ? void 0 : paneOptions.id) !== undefined && this._panes.has(paneOptions.id)) {
            paneId = paneOptions.id;
            this._chartStore.getIndicatorStore().addInstance(indicator, paneId, isStack !== null && isStack !== void 0 ? isStack : false).then(_ => {
                var _a, _b;
                this._setPaneOptions(paneOptions, (_b = (_a = this._panes.get(paneId)) === null || _a === void 0 ? void 0 : _a.getAxisComponent().buildTicks(true)) !== null && _b !== void 0 ? _b : false);
            }).catch(_ => { });
        }
        else {
            paneId = (_a = paneOptions === null || paneOptions === void 0 ? void 0 : paneOptions.id) !== null && _a !== void 0 ? _a : createId(PaneIdConstants.INDICATOR);
            const topPane = Array.from(this._panes.values()).pop();
            const pane = new IndicatorPane(this._chartContainer, this, paneId, topPane);
            topPane.setBottomPane(pane);
            const height = (_b = paneOptions === null || paneOptions === void 0 ? void 0 : paneOptions.height) !== null && _b !== void 0 ? _b : PANE_DEFAULT_HEIGHT;
            pane.setBounding({ height });
            if (paneOptions !== undefined && paneOptions !== null) {
                pane.setOptions(paneOptions);
            }
            this._panes.set(paneId, pane);
            this._chartStore.getIndicatorStore().addInstance(indicator, paneId, isStack !== null && isStack !== void 0 ? isStack : false).finally(() => {
                this.adjustPaneViewport(true, true, true, true, true);
                callback === null || callback === void 0 ? void 0 : callback();
            });
        }
        return paneId;
    }
    overrideIndicator(override, paneId, callback) {
        this._chartStore.getIndicatorStore().override(override, paneId !== null && paneId !== void 0 ? paneId : null).then(result => {
            if (result.length > 0) {
                this.adjustPaneViewport(false, true, true, true);
                callback === null || callback === void 0 ? void 0 : callback();
            }
        }).catch(() => { });
    }
    getIndicatorByPaneId(paneId, name) {
        return this._chartStore.getIndicatorStore().getInstanceByPaneId(paneId, name);
    }
    removeIndicator(paneId, name) {
        const indicatorStore = this._chartStore.getIndicatorStore();
        const removed = indicatorStore.removeInstance(paneId, name);
        if (removed) {
            let shouldMeasureHeight = false;
            if (paneId !== PaneIdConstants.CANDLE) {
                if (!indicatorStore.hasInstances(paneId)) {
                    const deletePane = this._panes.get(paneId);
                    if (deletePane !== undefined) {
                        shouldMeasureHeight = true;
                        const deleteTopPane = deletePane.getTopPane();
                        const deleteBottomPane = deletePane.getBottomPane();
                        deleteBottomPane === null || deleteBottomPane === void 0 ? void 0 : deleteBottomPane.setTopPane(deleteTopPane);
                        deleteTopPane === null || deleteTopPane === void 0 ? void 0 : deleteTopPane.setBottomPane(deleteBottomPane);
                        deletePane === null || deletePane === void 0 ? void 0 : deletePane.destroy();
                        this._panes.delete(paneId);
                    }
                }
            }
            this.adjustPaneViewport(shouldMeasureHeight, true, true, true, true);
        }
    }
    createOverlay(value, paneId) {
        const overlay = isString(value) ? { name: value } : value;
        if (getOverlayClass(overlay.name) === null) {
            logWarn('createOverlay', 'value', 'overlay not supported, you may need to use registerOverlay to add one!!!');
            return null;
        }
        let appointPaneFlag = true;
        if (paneId === undefined || this.getPaneById(paneId) === null) {
            paneId = PaneIdConstants.CANDLE;
            appointPaneFlag = false;
        }
        const id = this._chartStore.getOverlayStore().addInstance(overlay, paneId, appointPaneFlag);
        if (id === null) {
            logWarn('createOverlay', 'options.id', 'duplicate id!!!');
        }
        return id;
    }
    getOverlayById(id) {
        return this._chartStore.getOverlayStore().getInstanceById(id);
    }
    overrideOverlay(override) {
        this._chartStore.getOverlayStore().override(override);
    }
    removeOverlay(remove) {
        let overlayRemove;
        if (remove !== undefined) {
            if (isString(remove)) {
                overlayRemove = { id: remove };
            }
            else {
                overlayRemove = remove;
            }
        }
        this._chartStore.getOverlayStore().removeInstance(overlayRemove);
    }
    setPaneOptions(options) {
        this._setPaneOptions(options, false);
    }
    setZoomEnabled(enabled) {
        this._chartStore.getTimeScaleStore().setZoomEnabled(enabled);
    }
    isZoomEnabled() {
        return this._chartStore.getTimeScaleStore().getZoomEnabled();
    }
    setScrollEnabled(enabled) {
        this._chartStore.getTimeScaleStore().setScrollEnabled(enabled);
    }
    isScrollEnabled() {
        return this._chartStore.getTimeScaleStore().getScrollEnabled();
    }
    scrollByDistance(distance, animationDuration) {
        const duration = animationDuration === undefined || animationDuration < 0 ? 0 : animationDuration;
        const timeScaleStore = this._chartStore.getTimeScaleStore();
        if (duration > 0) {
            timeScaleStore.startScroll();
            const startTime = new Date().getTime();
            const animation = () => {
                const progress = (new Date().getTime() - startTime) / duration;
                const finished = progress >= 1;
                const dis = finished ? distance : distance * progress;
                timeScaleStore.scroll(dis);
                if (!finished) {
                    requestAnimationFrame(animation);
                }
            };
            animation();
        }
        else {
            timeScaleStore.startScroll();
            timeScaleStore.scroll(distance);
        }
    }
    scrollToRealTime(animationDuration) {
        const timeScaleStore = this._chartStore.getTimeScaleStore();
        const { bar: barSpace } = timeScaleStore.getBarSpace();
        const difBarCount = timeScaleStore.getOffsetRightBarCount() - timeScaleStore.getOffsetRightDistance() / barSpace;
        const distance = difBarCount * barSpace;
        this.scrollByDistance(distance, animationDuration);
    }
    scrollToDataIndex(dataIndex, animationDuration) {
        const timeScaleStore = this._chartStore.getTimeScaleStore();
        const distance = (timeScaleStore.getOffsetRightBarCount() + (this.getDataList().length - 1 - dataIndex)) * timeScaleStore.getBarSpace().bar;
        this.scrollByDistance(distance, animationDuration);
    }
    scrollToTimestamp(timestamp, animationDuration) {
        const dataIndex = binarySearchNearest(this.getDataList(), 'timestamp', timestamp);
        this.scrollToDataIndex(dataIndex, animationDuration);
    }
    zoomAtCoordinate(scale, coordinate, animationDuration) {
        const duration = animationDuration === undefined || animationDuration < 0 ? 0 : animationDuration;
        const timeScaleStore = this._chartStore.getTimeScaleStore();
        if (duration > 0) {
            const { bar: barSpace } = timeScaleStore.getBarSpace();
            const scaleDataSpace = barSpace * scale;
            const difSpace = scaleDataSpace - barSpace;
            const startTime = new Date().getTime();
            const animation = () => {
                const progress = (new Date().getTime() - startTime) / duration;
                const finished = progress >= 1;
                const progressDataSpace = finished ? difSpace : difSpace * progress;
                timeScaleStore.zoom(progressDataSpace / barSpace, coordinate);
                if (!finished) {
                    requestAnimationFrame(animation);
                }
            };
            animation();
        }
        else {
            timeScaleStore.zoom(scale, coordinate);
        }
    }
    zoomAtDataIndex(scale, dataIndex, animationDuration) {
        const x = this._chartStore.getTimeScaleStore().dataIndexToCoordinate(dataIndex);
        this.zoomAtCoordinate(scale, { x, y: 0 }, animationDuration);
    }
    zoomAtTimestamp(scale, timestamp, animationDuration) {
        const dataIndex = binarySearchNearest(this.getDataList(), 'timestamp', timestamp);
        this.zoomAtDataIndex(scale, dataIndex, animationDuration);
    }
    convertToPixel(points, finder) {
        var _a;
        const { paneId = PaneIdConstants.CANDLE, absolute = false } = finder;
        let coordinates = [];
        if (paneId !== PaneIdConstants.XAXIS) {
            const pane = this.getPaneById(paneId);
            if (pane !== null) {
                const timeScaleStore = this._chartStore.getTimeScaleStore();
                const bounding = pane.getBounding();
                const ps = new Array().concat(points);
                const xAxis = this._xAxisPane.getAxisComponent();
                const yAxis = pane.getAxisComponent();
                coordinates = ps.map(point => {
                    const coordinate = {};
                    let dataIndex = point.dataIndex;
                    if (point.timestamp !== undefined) {
                        dataIndex = timeScaleStore.timestampToDataIndex(point.timestamp);
                    }
                    if (dataIndex !== undefined) {
                        coordinate.x = xAxis === null || xAxis === void 0 ? void 0 : xAxis.convertToPixel(dataIndex);
                    }
                    if (point.value !== undefined) {
                        const y = yAxis === null || yAxis === void 0 ? void 0 : yAxis.convertToPixel(point.value);
                        coordinate.y = absolute ? bounding.top + y : y;
                    }
                    return coordinate;
                });
            }
        }
        return isArray(points) ? coordinates : ((_a = coordinates[0]) !== null && _a !== void 0 ? _a : {});
    }
    convertFromPixel(coordinates, finder) {
        var _a;
        const { paneId = PaneIdConstants.CANDLE, absolute = false } = finder;
        let points = [];
        if (paneId !== PaneIdConstants.XAXIS) {
            const pane = this.getPaneById(paneId);
            if (pane !== null) {
                const timeScaleStore = this._chartStore.getTimeScaleStore();
                const bounding = pane.getBounding();
                const cs = new Array().concat(coordinates);
                const xAxis = this._xAxisPane.getAxisComponent();
                const yAxis = pane.getAxisComponent();
                points = cs.map(coordinate => {
                    var _a;
                    const point = {};
                    if (coordinate.x !== undefined) {
                        const dataIndex = xAxis.convertFromPixel(coordinate.x);
                        point.dataIndex = dataIndex;
                        point.timestamp = (_a = timeScaleStore.dataIndexToTimestamp(dataIndex)) !== null && _a !== void 0 ? _a : undefined;
                    }
                    if (coordinate.y !== undefined) {
                        const y = absolute ? coordinate.y - bounding.top : coordinate.y;
                        point.value = yAxis.convertFromPixel(y);
                    }
                    return point;
                });
            }
        }
        return isArray(coordinates) ? points : ((_a = points[0]) !== null && _a !== void 0 ? _a : {});
    }
    subscribeAction(type, callback) {
        this._chartStore.getActionStore().subscribe(type, callback);
    }
    unsubscribeAction(type, callback) {
        this._chartStore.getActionStore().unsubscribe(type, callback);
    }
    getConvertPictureUrl(includeOverlay, type, backgroundColor) {
        const width = this._chartContainer.offsetWidth;
        const height = this._chartContainer.offsetHeight;
        const canvas = createDom('canvas', {
            width: `${width}px`,
            height: `${height}px`,
            boxSizing: 'border-box'
        });
        const ctx = canvas.getContext('2d');
        const pixelRatio = getPixelRatio(canvas);
        canvas.width = width * pixelRatio;
        canvas.height = height * pixelRatio;
        ctx.scale(pixelRatio, pixelRatio);
        ctx.fillStyle = backgroundColor !== null && backgroundColor !== void 0 ? backgroundColor : '#FFFFFF';
        ctx.fillRect(0, 0, width, height);
        const overlayFlag = includeOverlay !== null && includeOverlay !== void 0 ? includeOverlay : false;
        this._panes.forEach(pane => {
            const bounding = pane.getBounding();
            ctx.drawImage(pane.getImage(overlayFlag), 0, bounding.top, width, bounding.height);
        });
        const xAxisBounding = this._xAxisPane.getBounding();
        ctx.drawImage(this._xAxisPane.getImage(overlayFlag), 0, xAxisBounding.top, width, xAxisBounding.height);
        return canvas.toDataURL(`image/${type !== null && type !== void 0 ? type : 'jpeg'}`);
    }
    resize() {
        this.adjustPaneViewport(true, true, true, true, true);
    }
    destroy() {
        this._chartEvent.destroy();
        this._panes.forEach(pane => {
            pane.destroy();
        });
        this._panes.clear();
        this._xAxisPane.destroy();
        this._container.removeChild(this._chartContainer);
    }
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getDistance(coordinate1, coordinate2) {
    const xDif = coordinate1.x - coordinate2.x;
    const yDif = coordinate1.y - coordinate2.y;
    return Math.sqrt(xDif * xDif + yDif * yDif);
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function checkCoordinateOnArc(coordinate, arc) {
    if (Math.abs(getDistance(coordinate, arc) - arc.r) < DEVIATION) {
        const { r, startAngle, endAngle } = arc;
        const startCoordinateX = r * Math.cos(startAngle) + arc.x;
        const startCoordinateY = r * Math.sin(startAngle) + arc.y;
        const endCoordinateX = r * Math.cos(endAngle) + arc.x;
        const endCoordinateY = r * Math.sin(endAngle) + arc.y;
        return (coordinate.x <= Math.max(startCoordinateX, endCoordinateX) + DEVIATION &&
            coordinate.x >= Math.min(startCoordinateX, endCoordinateX) - DEVIATION &&
            coordinate.y <= Math.max(startCoordinateY, endCoordinateY) + DEVIATION &&
            coordinate.y >= Math.min(startCoordinateY, endCoordinateY) - DEVIATION);
    }
    return false;
}
function drawArc(ctx, attrs, styles) {
    const { x, y, r, startAngle, endAngle } = attrs;
    const { style = "solid" /* LineType.SOLID */, size = 1, color = 'currentColor', dashedValue = [2, 2] } = styles;
    ctx.lineWidth = size;
    ctx.strokeStyle = color;
    if (style === "dashed" /* LineType.DASHED */) {
        ctx.setLineDash(dashedValue);
    }
    else {
        ctx.setLineDash([]);
    }
    ctx.beginPath();
    ctx.arc(x, y, r, startAngle, endAngle);
    ctx.stroke();
    ctx.closePath();
}

/**
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at

 * http://www.apache.org/licenses/LICENSE-2.0

 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const instances = {};
let chartBaseId = 1;
/**
 * Chart version
 * @return {string}
 */
function version() {
    return '9.0.0-alpha7';
}
/**
 * Init chart instance
 * @param ds
 * @param options
 * @returns {Chart}
 */
function init(ds, options) {
    var _a;
    logTag();
    const errorMessage = 'The chart cannot be initialized correctly. Please check the parameters. The chart container cannot be null and child elements need to be added!!!';
    let dom;
    if (isString(ds)) {
        dom = document.getElementById(ds);
    }
    else {
        dom = ds;
    }
    if (dom === null) {
        logError('', '', errorMessage);
        return null;
    }
    let chart = instances[(_a = dom.chartId) !== null && _a !== void 0 ? _a : ''];
    if (chart !== undefined) {
        logWarn('', '', 'The chart has been initialized on the dom！！！');
        return chart;
    }
    const id = `k_line_chart_${chartBaseId++}`;
    chart = new ChartImp(dom, options);
    // @ts-expect-error
    chart.id = id;
    dom.chartId = id;
    instances[id] = chart;
    return chart;
}
/**
 * Destory chart instace
 * @param dcs
 */
function dispose(dcs) {
    var _a;
    let id;
    if (isString(dcs)) {
        const dom = document.getElementById(dcs);
        id = (_a = dom === null || dom === void 0 ? void 0 : dom.getAttribute('chartId')) !== null && _a !== void 0 ? _a : null;
    }
    else if (dcs instanceof ChartImp) {
        // @ts-expect-error
        id = dcs.id;
    }
    else {
        // @ts-expect-error
        id = dcs !== null && dcs !== void 0 ? dcs : dcs.chartId;
    }
    if (id !== null) {
        instances[id].destroy();
        // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
        delete instances[id];
    }
}
const utils = {
    clone,
    merge,
    isString,
    isNumber,
    isValid,
    isObject,
    isArray,
    isFunction,
    isBoolean,
    formatValue,
    formatPrecision,
    formatBigNumber,
    formatDate,
    getLinearSlopeIntercept,
    getLinearYFromSlopeIntercept,
    getLinearYFromCoordinates,
    checkCoordinateOnArc,
    checkCoordinateOnCircle,
    checkCoordinateOnLine,
    checkCoordinateOnPolygon,
    checkCoordinateOnRect,
    checkCoordinateOnText,
    drawArc,
    drawCircle,
    drawLine,
    drawPolygon,
    drawRect,
    drawText,
    drawRectText
};

exports.dispose = dispose;
exports.getFigureClass = getFigureClass;
exports.getSupportedFigures = getSupportedFigures;
exports.getSupportedIndicators = getSupportedIndicators;
exports.getSupportedLocales = getSupportedLocales;
exports.getSupportedOverlays = getSupportedOverlays;
exports.init = init;
exports.registerFigure = registerFigure;
exports.registerIndicator = registerIndicator;
exports.registerLocale = registerLocale;
exports.registerOverlay = registerOverlay;
exports.registerStyles = registerStyles;
exports.utils = utils;
exports.version = version;

}));
//# sourceMappingURL=klinecharts.js.map
